/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
var path = require('path');
var fs = require('fs');
var crypto = require('crypto');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/* Cryptsidian
* By: triumphantomato
* https://github.com/triumphantomato
*/ 

/*
* crypto primitives
*/
const ALGORITHM = 'aes-256-ctr';
const SALT = Buffer.alloc(32, '3170ebab43b9ccaaacbbb0ee72285a21c39fa324315db3ddcc11da1e3ff816e5', 'hex');
const KEY_LENGTH = 32; // length in bytes

/*
* global variables
*/
let secretKey; //will be derived from user input later 


/**
************************
************************
* API Functions
************************
************************
**/

/* all of these are implemented in the main.ts file, in onOpen() on class CryptoModal

* Registering Cryptsidian with the Obsidian Plugin API
* Prompting the user to enter their password for encryption/decryption. 
* Retrieving the path to the user's Obsidian vault
*/


/**
************************
************************
* Backend Functions
************************
************************
**/


/**
************************
* Backend: passwords
************************
**/


/**
* Takes a user-supplied string and checks for safety.
* @param {string} input - user supplied string
* @return {false|string} - false when input fails checks or string of user input if it passes.
**/
function stringSanitizer( input ){
	if (typeof(input) !== 'string'){
		throw new Error("Password must be a string, received " + typeof(input) + " instead\n");
	}

	//deal with accents - normalize Unicode
	input = input.normalize('NFC'); 

	//validate entropy
	if (hasEnoughEntropy(input)){
		return input;
	}

	return false;
}

/**
* Takes a string and checks for sufficient entropy. 
* If a user's password has all character types (number, lower and uppercase, special chars), it will require 13 characters minimum at level=80.
* @param {string} input - input string
* @param {number} [level = 80] - entropy level in bits. 64 - okay but iffy, 80 - okay, 112 - recommended, 256 - probably quantum secure. Take these guidelines with a grain of salt and consult a cryptographer for your application.
* @return {bool} judgment - true if sufficient, false if not
**/
function hasEnoughEntropy( input, level=80 ){
	if (level < 64){
		throw new Error('Function hasEnoughEntropy() called with < 64 bits of entropy. This is unsafe, aborting.\n');
	}
	
	let charspace = 0;
	let minlength = Math.ceil(level/Math.log2(10+26+26+32));

	if (level >= 64){

		//test entropy (via minlength)
		if (input.length < minlength){
			throw {
				name: "PasswordError",
				message: "Your password is not long enough. It must be " + minlength + " characters or longer.\n"
			}
		}

		//test entropy (via explicit entropy calculation)
		if (/\d+/g.test(input)) charspace += 10; //digits in charspace
		if (/[a-z]/g.test(input)) charspace += 26; //lowercase in charspace
		if (/[A-Z]/g.test(input)) charspace += 26; //uppercase in charspace
		if (/[`~!@#$%^&*()-=_+\[\]{};':"\\|,.<>\/?]/g.test(input)) charspace += 32; //special chars in charspace
		
		let entropy = input.length * Math.log2(charspace);

		if (entropy < level){
			throw {
				name: "PasswordError",
				message: "Your password is not strong enough. Try adding different kinds of characters, like numbers, special characters, or uppercase letters.\n"
			}
		}

		else if (entropy >= level){
			return true;
		}

		return false;

	}

	return false;
}


/**
************************
* Backend: keys
************************
**/


/**
* Takes a user password and sets the secretKey global variable by calling keyDeriver(password). 
* Is the isolation boundary between backend and frontend.
* @param {string} password - user password to derive encryption key from
* @returns <void>
**/
function setUserSecretKey( password ){
	secretKey = Buffer.alloc(KEY_LENGTH); //zero-fills secretKey to be a buffer of length KEY_LENGTH
	secretKey = keyDeriver(password);
	return;
}

/**
* Takes an input string and returns a secret key of length key_length (default is value of constant KEY_LENGTH).
* @param {string} input
* @param {number} [key_length = KEY_LENGTH]
* @return {Buffer} secretKey
**/
function keyDeriver( input, key_length=KEY_LENGTH ){
	if(input == null || typeof(input) !== 'string'){
		throw new Error("Function keyDeriver received bad input. Expected a non-null string.");
	}

	let password = stringSanitizer(input);
	if (password){
		secretKey = crypto__namespace.scryptSync(password, SALT, KEY_LENGTH);
		return secretKey;
	}
}

/**
* Checks to ensure secretKey is correctly set and then returns it. Accessing secretKey outside of this function is unsafe.
* @returns {Buffer} secretKey
**/

function getSecretKey( ){
	if (secretKey == null){ // (== null) checks null and undefined
		throw {
				name: "KeyError",
				message: "secretKey is null or undefined. Uh-oh.\n"
			}
	}

	if (secretKey.length !== KEY_LENGTH){
		throw {
			name: "KeyError",
			message: "secretKey is not the right length. Got: " + secretKey.length + " bytes, but expected: " + KEY_LENGTH + " bytes"
		}
	}

	return secretKey;
}


/**
**************************
* Backend: encrypt/decrypt
**************************
**/


/**
* Overwrites an encrypted version of the file to disk
* @param {string} file_path - location of file to encrypt
* @returns <void>
**/
function encryptFile( file_path ){
	//get data and file descriptor
	let data = getFileBuffer(file_path);
	let fd = openFile(file_path);
	
	//generate IV
	let iv = crypto__namespace.randomBytes(16);

	//validate secretKey not empty
	let key = getSecretKey();

	//make a ciphertext
	const cipher = crypto__namespace.createCipheriv(ALGORITHM, key, iv);
	const encrypted_data = Buffer.concat([cipher.update(data), cipher.final()]); 
	//cipher.final() not necessary for aes-256-ctr but this construciton should also
	//work with other algorithms
		
	//prepend IV and write encrypted data back to file
	fs__namespace.writeSync(fd, iv, 0, iv.length, 0); 
	fs__namespace.writeSync(fd, encrypted_data, 0, encrypted_data.length, iv.length);

	//cleanup
	fs__namespace.close(fd, (err) => {
		if (err){
			console.error("failed to close file descriptor when attempting to encrypt file: \n" + file_path + "\n in function encryptFile()\n");
			throw new Error(err);
		}
	});

}

/**
* Decrypts a file and writes it to disk, in place
* @param {string} file_path - file to decrypt
* @returns <void>
**/ 
function decryptFile( file_path ){

	//get this to calculate cipher_data_length later
	let stats = fs__namespace.statSync(file_path); //must be done before opening the fd or it errors

	//get secretKey
	let key = getSecretKey();

	//get file descriptor
	let fd = openFile(file_path);

	//calculate cipher_data_length
	let cipher_data_length = (stats.size - 16); //in bytes, minus the 16-byte IV

	//we'll walk through the file to extract IV and then content instead of using getFileBuffer() helper function
	//read first 16 bytes for the IV
	let iv = Buffer.alloc(16);
	try{
		fs__namespace.readSync(fd, iv, 0, 16, null); //should advance file position to 16 bytes in
	}
	catch (err){
		console.error("Error using fs.readSync(fd, iv, 0, 16, null) to get the IV back");
		throw new Error(err);
	}

	//read the rest for the data
	let cipher_data = Buffer.alloc(cipher_data_length);
	fs__namespace.readSync(fd, cipher_data, 0, cipher_data_length, null); //should start the read from 16 bytes in

	//now make a decipher object and decrypt the file
	const decipher = crypto__namespace.createDecipheriv(ALGORITHM, key, iv);
	const decrypted_data = Buffer.concat([decipher.update(cipher_data), decipher.final()]);

	//write the cleartext data back to file
	fs__namespace.writeSync(fd, decrypted_data, 0, decrypted_data.length, 0);

	//truncate the remaining crypto bytes from the overwritten file
	try{
		fs__namespace.ftruncateSync(fd, cipher_data_length); 
	}
	catch (err){
		console.error("Error truncating file after decryption in decryptFile(), for file: \n" + file_path);
		throw new Error(err);
	}

	//cleanup
	fs__namespace.close(fd, (err) => {
		if (err){
			console.error("failed to close file descriptor when attempting to decrypt file: \n" + file_path + "\n in function decryptFile()\n");
			throw new Error(err);
		}
	});

}


/**
************************
* Backend: files
************************
**/

/**
* Returns an fd or error for a file.
* @param {string} file_path
* @returns {number} fd
**/
function openFile( file_path ){
	let fd;
	try{
		fd = fs__namespace.openSync(file_path, 'r+');
	}
	catch (err){
		throw new Error(err);
	}

	return fd;
}

/** 
* Returns the contents of a file as a buffer.
* @param {string} file_path - a single file path to read
* @return {Buffer} buf - buffer of an individual file
**/
function getFileBuffer( file_path ){
	file_path = path__namespace.normalize(file_path);
	let buf;
	try{
		buf = fs__namespace.readFileSync(file_path);
	}
	catch (err){
		console.error("failed calling getFileBuffer() on file_path: " + file_path);
		throw new Error(err);
	}
	return buf;
}

/**
* Takes an array of filepaths and encrypts or decrypts them depending on operation.
* @param {Array}<string> file_array
* @param {string} operation
**/
function fileProcessor( file_array, operation ){
	if (operation === 'ENCRYPT'){
		for (const file of file_array){
			encryptFile(file);
		}
		return;
	}
	if (operation === 'DECRYPT'){
		for (const file of file_array){
			decryptFile(file);
		}
		return;
	}
	else throw new Error("fileProcessor(file_array, operation) called with invalid operation argument. \n Got " + operation + ". Must be ENCRYPT or DECRYPT.");
}

/**
* Returns array of all files with absolute paths in Vault dir and all sub-dirs
* @param {string} vault - absolute path to the user's Obsidian vault
* @return {Array}<string> vault_files
**/
function getVaultFiles( vault ){
	vault = path__namespace.normalize(vault);

	let vault_files = [];
	let files = [];

	try {
		files = fs__namespace.readdirSync(vault, {withFileTypes: true});
	} 
	catch (err) {
		console.error('failed calling fsreaddirSync(vault, {withFileTypes: true} on this directory: \'' + vault + '\'\n');
		throw new Error(err);
	}
	
	for (const file of files){
		if (file.name[0] === '.') continue; //skip dotfiles -- do i need to change this to be Windows compatible?

		if (file.isFile()){
			let absolutePath = path__namespace.resolve(vault, file.name);
			vault_files.push(absolutePath);
		
		}

		else if (file.isDirectory()){
			vault_files.push(...getVaultFiles(path__namespace.resolve(vault, file.name))); 
			//... is spread syntax unpacking the returned vault_files array from the recursed call
		}
	
	}

	return vault_files;

	//todo: make vault_files a TS array of only strings

}

const DEFAULT_SETTINGS = {
    mySetting: 'default'
};
class MyPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('loading plugin');
            yield this.loadSettings();
            this.addCommand({
                id: 'open-encrypt-modal',
                name: 'Open Encrypt Modal',
                checkCallback: (checking) => {
                    let leaf = this.app.workspace.activeLeaf;
                    if (leaf) {
                        if (!checking) {
                            new CryptoModal(this.app, 'Encrypt').open();
                        }
                        return true;
                    }
                    return false;
                }
            });
            this.addCommand({
                id: 'open-decrypt-modal',
                name: 'Open Decrypt Modal',
                checkCallback: (checking) => {
                    let leaf = this.app.workspace.activeLeaf;
                    if (leaf) {
                        if (!checking) {
                            new CryptoModal(this.app, 'Decrypt').open();
                        }
                        return true;
                    }
                    return false;
                }
            });
        });
    }
    onunload() {
        console.log('unloading plugin');
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}
class CryptoModal extends obsidian.Modal {
    constructor(app, operation) {
        super(app);
        this.password = null;
        this.operation = null;
        this.operation = operation;
    }
    onOpen() {
        // get vault dir
        let vault_dir = this.app.vault.adapter.getBasePath();
        //initiailze an empty DOM object to hold our modal
        let { contentEl } = this;
        contentEl.empty();
        //title - to let the user know which mode (encrypt/decrypt) they're in
        const titleEl = contentEl.createDiv();
        titleEl.style.fontWeight = 'bold';
        titleEl.style.marginBottom = '1em';
        titleEl.setText(`${this.operation}`);
        //notice - to let the user know which folder will be encrypted/decrypted
        const folderNotice = contentEl.createDiv();
        folderNotice.style.marginBottom = '1em';
        folderNotice.setText('This operation will apply to all files and folders in: ' + vault_dir);
        folderNotice.style.color = 'red';
        //notice - tell user not to open encrpyted files
        const corrputionNotice = contentEl.createDiv();
        corrputionNotice.style.marginBottom = '1.5em';
        corrputionNotice.setText('Do not open files with Obsidian after encrypting - they can become corrupted and irrecoverable. Always use the Decrypt command prior to re-opening files!');
        corrputionNotice.style.color = 'red';
        //make a div for user's pw input
        const inputPwContainerEl = contentEl.createDiv();
        const pwInputEl = inputPwContainerEl.createEl('input', { type: 'password', value: '' });
        pwInputEl.placeholder = 'Please enter your password';
        pwInputEl.style.width = '70%';
        pwInputEl.focus();
        //make a div for pw confirmation
        const confirmPwContainerEl = contentEl.createDiv();
        confirmPwContainerEl.style.marginTop = '1em';
        const pwConfirmEl = confirmPwContainerEl.createEl('input', { type: 'password', value: '' });
        pwConfirmEl.placeholder = 'Confirm your password';
        pwConfirmEl.style.width = '70%';
        //make a submit button for the crypto operation
        const confirmBtnEl = confirmPwContainerEl.createEl('button', { text: `${this.operation}` });
        confirmBtnEl.style.marginLeft = '1em';
        //message modal - to fire if passwords don't match
        const messageMatchEl = contentEl.createDiv();
        messageMatchEl.style.marginTop = '1em';
        messageMatchEl.style.color = 'red';
        messageMatchEl.setText('Passwords must match');
        messageMatchEl.hide();
        //message modal - to fire if either input is empty
        const messageEmptyEl = contentEl.createDiv();
        messageEmptyEl.style.marginTop = '1em';
        messageEmptyEl.style.color = 'red';
        messageEmptyEl.setText('Please enter your password in both boxes.');
        messageEmptyEl.hide();
        //message modal - to fire with cryptoSource.stringSanitizer() error message, if any
        const messageEl = contentEl.createDiv();
        messageEl.style.color = 'red';
        messageEl.style.marginTop = '1em';
        messageEl.hide();
        // check the input
        const pwChecker = (ev) => {
            ev.preventDefault();
            let good_to_go = false;
            // is either input field empty?
            if (pwInputEl.value == '' || pwInputEl.value == null || pwConfirmEl.value == '' || pwConfirmEl.value == null) {
                good_to_go = false;
                messageEmptyEl.show();
            }
            if (pwInputEl.value !== '' && pwInputEl.value !== null && pwConfirmEl.value !== '' && pwConfirmEl.value !== null) {
                good_to_go = true;
                messageEmptyEl.hide();
            }
            // do both password inputs match?
            if (pwInputEl.value !== pwConfirmEl.value) {
                good_to_go = false;
                messageMatchEl.show();
            }
            if (pwInputEl.value === pwConfirmEl.value) {
                good_to_go = true;
                messageMatchEl.hide();
            }
            // is the user's password strong enough for crypto?
            if (good_to_go) {
                try {
                    messageEl.hide();
                    good_to_go = Boolean(stringSanitizer(pwInputEl.value));
                    //true if user input had enough entropy, false otherwise
                }
                catch (error) {
                    good_to_go = false;
                    messageEl.setText(error.message);
                    messageEl.show();
                }
            }
            // if all checks pass, execute the crypto operation
            if (good_to_go) {
                this.password = pwConfirmEl.value;
                setUserSecretKey(this.password); //derive the secret key via scrypt from user's password
                // close open notes to prevent post-encryption access, which can corrupt files and make them irrecoverable
                const emptyLeaf = (leaf) => __awaiter(this, void 0, void 0, function* () {
                    leaf.setViewState({ type: 'empty' });
                });
                const closeLeaves = () => __awaiter(this, void 0, void 0, function* () {
                    let leaves = [];
                    this.app.workspace.iterateAllLeaves((leaf) => {
                        leaves.push(leaf);
                    });
                    for (const leaf of leaves) {
                        if (leaf.view instanceof obsidian.FileView) {
                            yield emptyLeaf(leaf);
                            leaf.detach();
                        }
                    }
                });
                const processFiles = () => __awaiter(this, void 0, void 0, function* () {
                    yield closeLeaves();
                    fileProcessor(files, this.operation.toUpperCase());
                });
                //run the encryption or decryption
                let files = getVaultFiles(vault_dir);
                processFiles();
                this.close();
            }
        };
        //register the button's event handler
        confirmBtnEl.addEventListener('click', pwChecker);
        //allow enter to submit
        const enterSubmits = function (ev, value) {
            if ((ev.code === 'Enter' || ev.code === 'NumpadEnter')
                && value.length > 0
                && confirmBtnEl.disabled === false) {
                ev.preventDefault();
                confirmBtnEl.click();
            }
        };
        pwInputEl.addEventListener('keypress', function (ev) { enterSubmits(ev, pwInputEl.value); });
        pwConfirmEl.addEventListener('keypress', function (ev) { enterSubmits(ev, pwInputEl.value); });
    }
    onClose() {
        let { contentEl } = this;
        contentEl.empty();
    }
}

module.exports = MyPlugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsImNyeXB0c2lkaWFuLm1qcyIsIm1haW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iLCIvKiBDcnlwdHNpZGlhblxuKiBCeTogdHJpdW1waGFudG9tYXRvXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS90cml1bXBoYW50b21hdG9cbiovIFxuXG4vKlxuKioqKioqKioqKioqKioqKioqKioqKioqXG4qKioqKioqKioqKioqKioqKioqKioqKipcbiogQXJjaGl0ZWN0dXJlIE92ZXJ2aWV3XG4qKioqKioqKioqKioqKioqKioqKioqKipcbioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gY3JlYXRlZCB3aXRoIGFzY2lpZmxvdy5jb21cblxuIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCAgICAgICAgICAgICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJAgICAgICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4g4pSCICAgICAgICAgICAgICDilILil4TilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKQgICAgICAgICAgICAgICAgICAg4pSCICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuIOKUgiBPYnNpZGlhbiBBUEkg4pSCICAgICAgICAgICAgIOKUgiBBUEkgRnVuY3Rpb25zICAgICDilJzilIDilIDilIDilIDilIDilIDilrrilIIgQmFja2VuZCBGdW5jdGlvbnMgICAgICDilIJcbiDilIIgICAgICAgICAgICAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKWuuKUgiAgICAgICAgICAgICAgICAgICDilIIgICAgICAg4pSCICAgICAgICDilIIgICDilrIgICAgICAgICAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICDilIIgICAgICAg4pSCICAgICAgICDilIIgICDilIIgICAgICAgICAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICDilIIgICAgICAg4pSCICAgICAgICDilIIgICDilIIgICAgICAgICAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICDilIIgICAgICAg4pSCICAgICAgICDilIIgICDilIIgICAgICAgICAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICDilIIgICAgICAg4pSCICAgICAgICDilrwgICAgICAgICAgICAgICDilIJcbiDilIIgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAg4pSCICAgICAgIOKUgiAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQICAg4pSCXG4g4pSCICAgICAgICAgICAgICDilIIgICAgICAgICAgICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAgICAgIOKUgiAg4pSCIEVuY3J5cHQvRGVjcnlwdCDilIIgICDilIJcbiDilIIgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICDilIIgICAgIEZpbGVzICAgICAgIOKUgiAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICAgICAg4pSCICAg4pSCXG4g4pSCICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAg4pSCICAgICAgICAgICAgICAgICDilIIgICDilIJcbiDilIIgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICDilIIgICAgICAgICAgICAgICAgIOKUgiAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgIOKUgiAgICAgICAgICAgICAgICAg4pSCICAg4pSCXG4g4pSCICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYICAg4pSCXG4g4pSCICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuIOKUgiAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiDilIIgICAgICAgICAgICAgIOKUglxuIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuKi9cblxuLypcbiogbGlicmFyaWVzXG4qL1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG4vKlxuKiBjcnlwdG8gcHJpbWl0aXZlc1xuKi9cbmV4cG9ydCBjb25zdCBBTEdPUklUSE0gPSAnYWVzLTI1Ni1jdHInO1xuZXhwb3J0IGNvbnN0IFNBTFQgPSBCdWZmZXIuYWxsb2MoMzIsICczMTcwZWJhYjQzYjljY2FhYWNiYmIwZWU3MjI4NWEyMWMzOWZhMzI0MzE1ZGIzZGRjYzExZGExZTNmZjgxNmU1JywgJ2hleCcpO1xuXHQvL3NhbHQgdXNlZCBpbiBzY3J5cHQgUEJLREYsIGRlcml2ZWQgZnJvbSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpIC0geW91IGNhbiByZXBsYWNlIHdpdGggeW91ciBvd24sIGJ1dCB3aWxsIG5lZWQgdG8ga2VlcCB0cmFja1xuXHQvL29mIHRoaXMgdG8gZGVjcnlwdCB5b3VyIGZpbGVzIGluIHRoZSBmdXR1cmUgaWYgeW91IGNoYW5nZSBpdC4gUmVjb21tZW5kYXRpb246IGxlYXZlIGl0IGFsb25lLlxuXG4vKlxuKiBrZXl3b3Jkc1xuKi9cbmV4cG9ydCBjb25zdCBFTkNSWVBUID0gJ0VOQ1JZUFQnO1xuZXhwb3J0IGNvbnN0IERFQ1JZUFQgPSAnREVDUllQVCc7XG5leHBvcnQgY29uc3QgS0VZX0xFTkdUSCA9IDMyOyAvLyBsZW5ndGggaW4gYnl0ZXNcblxuLypcbiogZ2xvYmFsIHZhcmlhYmxlc1xuKi9cbmxldCBzZWNyZXRLZXk7IC8vd2lsbCBiZSBkZXJpdmVkIGZyb20gdXNlciBpbnB1dCBsYXRlciBcblxuXG4vKipcbioqKioqKioqKioqKioqKioqKioqKioqKlxuKioqKioqKioqKioqKioqKioqKioqKioqXG4qIEFQSSBGdW5jdGlvbnNcbioqKioqKioqKioqKioqKioqKioqKioqKlxuKioqKioqKioqKioqKioqKioqKioqKioqXG4qKi9cblxuLyogYWxsIG9mIHRoZXNlIGFyZSBpbXBsZW1lbnRlZCBpbiB0aGUgbWFpbi50cyBmaWxlLCBpbiBvbk9wZW4oKSBvbiBjbGFzcyBDcnlwdG9Nb2RhbFxuXG4qIFJlZ2lzdGVyaW5nIENyeXB0c2lkaWFuIHdpdGggdGhlIE9ic2lkaWFuIFBsdWdpbiBBUElcbiogUHJvbXB0aW5nIHRoZSB1c2VyIHRvIGVudGVyIHRoZWlyIHBhc3N3b3JkIGZvciBlbmNyeXB0aW9uL2RlY3J5cHRpb24uIFxuKiBSZXRyaWV2aW5nIHRoZSBwYXRoIHRvIHRoZSB1c2VyJ3MgT2JzaWRpYW4gdmF1bHRcbiovXG5cblxuLyoqXG4qKioqKioqKioqKioqKioqKioqKioqKipcbioqKioqKioqKioqKioqKioqKioqKioqKlxuKiBCYWNrZW5kIEZ1bmN0aW9uc1xuKioqKioqKioqKioqKioqKioqKioqKioqXG4qKioqKioqKioqKioqKioqKioqKioqKipcbioqL1xuXG5cbi8qKlxuKioqKioqKioqKioqKioqKioqKioqKioqXG4qIEJhY2tlbmQ6IHBhc3N3b3Jkc1xuKioqKioqKioqKioqKioqKioqKioqKioqXG4qKi9cblxuXG4vKipcbiogVGFrZXMgYSB1c2VyLXN1cHBsaWVkIHN0cmluZyBhbmQgY2hlY2tzIGZvciBzYWZldHkuXG4qIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIHVzZXIgc3VwcGxpZWQgc3RyaW5nXG4qIEByZXR1cm4ge2ZhbHNlfHN0cmluZ30gLSBmYWxzZSB3aGVuIGlucHV0IGZhaWxzIGNoZWNrcyBvciBzdHJpbmcgb2YgdXNlciBpbnB1dCBpZiBpdCBwYXNzZXMuXG4qKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdTYW5pdGl6ZXIoIGlucHV0ICl7XG5cdGlmICh0eXBlb2YoaW5wdXQpICE9PSAnc3RyaW5nJyl7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiUGFzc3dvcmQgbXVzdCBiZSBhIHN0cmluZywgcmVjZWl2ZWQgXCIgKyB0eXBlb2YoaW5wdXQpICsgXCIgaW5zdGVhZFxcblwiKTtcblx0fVxuXG5cdC8vZGVhbCB3aXRoIGFjY2VudHMgLSBub3JtYWxpemUgVW5pY29kZVxuXHRpbnB1dCA9IGlucHV0Lm5vcm1hbGl6ZSgnTkZDJyk7IFxuXG5cdC8vdmFsaWRhdGUgZW50cm9weVxuXHRpZiAoaGFzRW5vdWdoRW50cm9weShpbnB1dCkpe1xuXHRcdHJldHVybiBpbnB1dDtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4qIFRha2VzIGEgc3RyaW5nIGFuZCBjaGVja3MgZm9yIHN1ZmZpY2llbnQgZW50cm9weS4gXG4qIElmIGEgdXNlcidzIHBhc3N3b3JkIGhhcyBhbGwgY2hhcmFjdGVyIHR5cGVzIChudW1iZXIsIGxvd2VyIGFuZCB1cHBlcmNhc2UsIHNwZWNpYWwgY2hhcnMpLCBpdCB3aWxsIHJlcXVpcmUgMTMgY2hhcmFjdGVycyBtaW5pbXVtIGF0IGxldmVsPTgwLlxuKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBpbnB1dCBzdHJpbmdcbiogQHBhcmFtIHtudW1iZXJ9IFtsZXZlbCA9IDgwXSAtIGVudHJvcHkgbGV2ZWwgaW4gYml0cy4gNjQgLSBva2F5IGJ1dCBpZmZ5LCA4MCAtIG9rYXksIDExMiAtIHJlY29tbWVuZGVkLCAyNTYgLSBwcm9iYWJseSBxdWFudHVtIHNlY3VyZS4gVGFrZSB0aGVzZSBndWlkZWxpbmVzIHdpdGggYSBncmFpbiBvZiBzYWx0IGFuZCBjb25zdWx0IGEgY3J5cHRvZ3JhcGhlciBmb3IgeW91ciBhcHBsaWNhdGlvbi5cbiogQHJldHVybiB7Ym9vbH0ganVkZ21lbnQgLSB0cnVlIGlmIHN1ZmZpY2llbnQsIGZhbHNlIGlmIG5vdFxuKiovXG5leHBvcnQgZnVuY3Rpb24gaGFzRW5vdWdoRW50cm9weSggaW5wdXQsIGxldmVsPTgwICl7XG5cdGlmIChsZXZlbCA8IDY0KXtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGhhc0Vub3VnaEVudHJvcHkoKSBjYWxsZWQgd2l0aCA8IDY0IGJpdHMgb2YgZW50cm9weS4gVGhpcyBpcyB1bnNhZmUsIGFib3J0aW5nLlxcbicpO1xuXHR9XG5cdFxuXHRsZXQgY2hhcnNwYWNlID0gMDtcblx0bGV0IG1pbmxlbmd0aCA9IE1hdGguY2VpbChsZXZlbC9NYXRoLmxvZzIoMTArMjYrMjYrMzIpKTtcblxuXHRpZiAobGV2ZWwgPj0gNjQpe1xuXG5cdFx0Ly90ZXN0IGVudHJvcHkgKHZpYSBtaW5sZW5ndGgpXG5cdFx0aWYgKGlucHV0Lmxlbmd0aCA8IG1pbmxlbmd0aCl7XG5cdFx0XHR0aHJvd3tcblx0XHRcdFx0bmFtZTogXCJQYXNzd29yZEVycm9yXCIsXG5cdFx0XHRcdG1lc3NhZ2U6IFwiWW91ciBwYXNzd29yZCBpcyBub3QgbG9uZyBlbm91Z2guIEl0IG11c3QgYmUgXCIgKyBtaW5sZW5ndGggKyBcIiBjaGFyYWN0ZXJzIG9yIGxvbmdlci5cXG5cIlxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vdGVzdCBlbnRyb3B5ICh2aWEgZXhwbGljaXQgZW50cm9weSBjYWxjdWxhdGlvbilcblx0XHRpZiAoL1xcZCsvZy50ZXN0KGlucHV0KSkgY2hhcnNwYWNlICs9IDEwOyAvL2RpZ2l0cyBpbiBjaGFyc3BhY2Vcblx0XHRpZiAoL1thLXpdL2cudGVzdChpbnB1dCkpIGNoYXJzcGFjZSArPSAyNjsgLy9sb3dlcmNhc2UgaW4gY2hhcnNwYWNlXG5cdFx0aWYgKC9bQS1aXS9nLnRlc3QoaW5wdXQpKSBjaGFyc3BhY2UgKz0gMjY7IC8vdXBwZXJjYXNlIGluIGNoYXJzcGFjZVxuXHRcdGlmICgvW2B+IUAjJCVeJiooKS09XytcXFtcXF17fTsnOlwiXFxcXHwsLjw+XFwvP10vZy50ZXN0KGlucHV0KSkgY2hhcnNwYWNlICs9IDMyOyAvL3NwZWNpYWwgY2hhcnMgaW4gY2hhcnNwYWNlXG5cdFx0XG5cdFx0bGV0IGVudHJvcHkgPSBpbnB1dC5sZW5ndGggKiBNYXRoLmxvZzIoY2hhcnNwYWNlKTtcblxuXHRcdGlmIChlbnRyb3B5IDwgbGV2ZWwpe1xuXHRcdFx0dGhyb3d7XG5cdFx0XHRcdG5hbWU6IFwiUGFzc3dvcmRFcnJvclwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcIllvdXIgcGFzc3dvcmQgaXMgbm90IHN0cm9uZyBlbm91Z2guIFRyeSBhZGRpbmcgZGlmZmVyZW50IGtpbmRzIG9mIGNoYXJhY3RlcnMsIGxpa2UgbnVtYmVycywgc3BlY2lhbCBjaGFyYWN0ZXJzLCBvciB1cHBlcmNhc2UgbGV0dGVycy5cXG5cIlxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGVsc2UgaWYgKGVudHJvcHkgPj0gbGV2ZWwpe1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4qKioqKioqKioqKioqKioqKioqKioqKipcbiogQmFja2VuZDoga2V5c1xuKioqKioqKioqKioqKioqKioqKioqKioqXG4qKi9cblxuXG4vKipcbiogVGFrZXMgYSB1c2VyIHBhc3N3b3JkIGFuZCBzZXRzIHRoZSBzZWNyZXRLZXkgZ2xvYmFsIHZhcmlhYmxlIGJ5IGNhbGxpbmcga2V5RGVyaXZlcihwYXNzd29yZCkuIFxuKiBJcyB0aGUgaXNvbGF0aW9uIGJvdW5kYXJ5IGJldHdlZW4gYmFja2VuZCBhbmQgZnJvbnRlbmQuXG4qIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIHVzZXIgcGFzc3dvcmQgdG8gZGVyaXZlIGVuY3J5cHRpb24ga2V5IGZyb21cbiogQHJldHVybnMgPHZvaWQ+XG4qKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRVc2VyU2VjcmV0S2V5KCBwYXNzd29yZCApe1xuXHRzZWNyZXRLZXkgPSBCdWZmZXIuYWxsb2MoS0VZX0xFTkdUSCk7IC8vemVyby1maWxscyBzZWNyZXRLZXkgdG8gYmUgYSBidWZmZXIgb2YgbGVuZ3RoIEtFWV9MRU5HVEhcblx0c2VjcmV0S2V5ID0ga2V5RGVyaXZlcihwYXNzd29yZCk7XG5cdHJldHVybjtcbn1cblxuLyoqXG4qIFRha2VzIGFuIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBhIHNlY3JldCBrZXkgb2YgbGVuZ3RoIGtleV9sZW5ndGggKGRlZmF1bHQgaXMgdmFsdWUgb2YgY29uc3RhbnQgS0VZX0xFTkdUSCkuXG4qIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuKiBAcGFyYW0ge251bWJlcn0gW2tleV9sZW5ndGggPSBLRVlfTEVOR1RIXVxuKiBAcmV0dXJuIHtCdWZmZXJ9IHNlY3JldEtleVxuKiovXG5leHBvcnQgZnVuY3Rpb24ga2V5RGVyaXZlciggaW5wdXQsIGtleV9sZW5ndGg9S0VZX0xFTkdUSCApe1xuXHRpZihpbnB1dCA9PSBudWxsIHx8IHR5cGVvZihpbnB1dCkgIT09ICdzdHJpbmcnKXtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBrZXlEZXJpdmVyIHJlY2VpdmVkIGJhZCBpbnB1dC4gRXhwZWN0ZWQgYSBub24tbnVsbCBzdHJpbmcuXCIpO1xuXHR9XG5cblx0bGV0IHBhc3N3b3JkID0gc3RyaW5nU2FuaXRpemVyKGlucHV0KTtcblx0aWYgKHBhc3N3b3JkKXtcblx0XHRzZWNyZXRLZXkgPSBjcnlwdG8uc2NyeXB0U3luYyhwYXNzd29yZCwgU0FMVCwgS0VZX0xFTkdUSCk7XG5cdFx0cmV0dXJuIHNlY3JldEtleTtcblx0fVxufVxuXG4vKipcbiogQ2hlY2tzIHRvIGVuc3VyZSBzZWNyZXRLZXkgaXMgY29ycmVjdGx5IHNldCBhbmQgdGhlbiByZXR1cm5zIGl0LiBBY2Nlc3Npbmcgc2VjcmV0S2V5IG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiBpcyB1bnNhZmUuXG4qIEByZXR1cm5zIHtCdWZmZXJ9IHNlY3JldEtleVxuKiovXG5cbmZ1bmN0aW9uIGdldFNlY3JldEtleSggKXtcblx0aWYgKHNlY3JldEtleSA9PSBudWxsKXsgLy8gKD09IG51bGwpIGNoZWNrcyBudWxsIGFuZCB1bmRlZmluZWRcblx0XHR0aHJvd3tcblx0XHRcdFx0bmFtZTogXCJLZXlFcnJvclwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcInNlY3JldEtleSBpcyBudWxsIG9yIHVuZGVmaW5lZC4gVWgtb2guXFxuXCJcblx0XHRcdH1cblx0fVxuXG5cdGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBLRVlfTEVOR1RIKXtcblx0XHR0aHJvd3tcblx0XHRcdG5hbWU6IFwiS2V5RXJyb3JcIixcblx0XHRcdG1lc3NhZ2U6IFwic2VjcmV0S2V5IGlzIG5vdCB0aGUgcmlnaHQgbGVuZ3RoLiBHb3Q6IFwiICsgc2VjcmV0S2V5Lmxlbmd0aCArIFwiIGJ5dGVzLCBidXQgZXhwZWN0ZWQ6IFwiICsgS0VZX0xFTkdUSCArIFwiIGJ5dGVzXCJcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc2VjcmV0S2V5O1xufVxuXG5cbi8qKlxuKioqKioqKioqKioqKioqKioqKioqKioqKipcbiogQmFja2VuZDogZW5jcnlwdC9kZWNyeXB0XG4qKioqKioqKioqKioqKioqKioqKioqKioqKlxuKiovXG5cblxuLyoqXG4qIE92ZXJ3cml0ZXMgYW4gZW5jcnlwdGVkIHZlcnNpb24gb2YgdGhlIGZpbGUgdG8gZGlza1xuKiBAcGFyYW0ge3N0cmluZ30gZmlsZV9wYXRoIC0gbG9jYXRpb24gb2YgZmlsZSB0byBlbmNyeXB0XG4qIEByZXR1cm5zIDx2b2lkPlxuKiovXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdEZpbGUoIGZpbGVfcGF0aCApe1xuXHQvL2dldCBkYXRhIGFuZCBmaWxlIGRlc2NyaXB0b3Jcblx0bGV0IGRhdGEgPSBnZXRGaWxlQnVmZmVyKGZpbGVfcGF0aCk7XG5cdGxldCBmZCA9IG9wZW5GaWxlKGZpbGVfcGF0aCk7XG5cdFxuXHQvL2dlbmVyYXRlIElWXG5cdGxldCBpdiA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG5cblx0Ly92YWxpZGF0ZSBzZWNyZXRLZXkgbm90IGVtcHR5XG5cdGxldCBrZXkgPSBnZXRTZWNyZXRLZXkoKTtcblxuXHQvL21ha2UgYSBjaXBoZXJ0ZXh0XG5cdGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihBTEdPUklUSE0sIGtleSwgaXYpO1xuXHRjb25zdCBlbmNyeXB0ZWRfZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUoZGF0YSksIGNpcGhlci5maW5hbCgpXSk7IFxuXHQvL2NpcGhlci5maW5hbCgpIG5vdCBuZWNlc3NhcnkgZm9yIGFlcy0yNTYtY3RyIGJ1dCB0aGlzIGNvbnN0cnVjaXRvbiBzaG91bGQgYWxzb1xuXHQvL3dvcmsgd2l0aCBvdGhlciBhbGdvcml0aG1zXG5cdFx0XG5cdC8vcHJlcGVuZCBJViBhbmQgd3JpdGUgZW5jcnlwdGVkIGRhdGEgYmFjayB0byBmaWxlXG5cdGZzLndyaXRlU3luYyhmZCwgaXYsIDAsIGl2Lmxlbmd0aCwgMCk7IFxuXHRmcy53cml0ZVN5bmMoZmQsIGVuY3J5cHRlZF9kYXRhLCAwLCBlbmNyeXB0ZWRfZGF0YS5sZW5ndGgsIGl2Lmxlbmd0aCk7XG5cblx0Ly9jbGVhbnVwXG5cdGZzLmNsb3NlKGZkLCAoZXJyKSA9PiB7XG5cdFx0aWYgKGVycil7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGNsb3NlIGZpbGUgZGVzY3JpcHRvciB3aGVuIGF0dGVtcHRpbmcgdG8gZW5jcnlwdCBmaWxlOiBcXG5cIiArIGZpbGVfcGF0aCArIFwiXFxuIGluIGZ1bmN0aW9uIGVuY3J5cHRGaWxlKClcXG5cIik7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyKTtcblx0XHR9XG5cdH0pO1xuXG59XG5cbi8qKlxuKiBEZWNyeXB0cyBhIGZpbGUgYW5kIHdyaXRlcyBpdCB0byBkaXNrLCBpbiBwbGFjZVxuKiBAcGFyYW0ge3N0cmluZ30gZmlsZV9wYXRoIC0gZmlsZSB0byBkZWNyeXB0XG4qIEByZXR1cm5zIDx2b2lkPlxuKiovIFxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRGaWxlKCBmaWxlX3BhdGggKXtcblxuXHQvL2dldCB0aGlzIHRvIGNhbGN1bGF0ZSBjaXBoZXJfZGF0YV9sZW5ndGggbGF0ZXJcblx0bGV0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZV9wYXRoKTsgLy9tdXN0IGJlIGRvbmUgYmVmb3JlIG9wZW5pbmcgdGhlIGZkIG9yIGl0IGVycm9yc1xuXG5cdC8vZ2V0IHNlY3JldEtleVxuXHRsZXQga2V5ID0gZ2V0U2VjcmV0S2V5KCk7XG5cblx0Ly9nZXQgZmlsZSBkZXNjcmlwdG9yXG5cdGxldCBmZCA9IG9wZW5GaWxlKGZpbGVfcGF0aCk7XG5cblx0Ly9jYWxjdWxhdGUgY2lwaGVyX2RhdGFfbGVuZ3RoXG5cdGxldCBjaXBoZXJfZGF0YV9sZW5ndGggPSAoc3RhdHMuc2l6ZSAtIDE2KTsgLy9pbiBieXRlcywgbWludXMgdGhlIDE2LWJ5dGUgSVZcblxuXHQvL3dlJ2xsIHdhbGsgdGhyb3VnaCB0aGUgZmlsZSB0byBleHRyYWN0IElWIGFuZCB0aGVuIGNvbnRlbnQgaW5zdGVhZCBvZiB1c2luZyBnZXRGaWxlQnVmZmVyKCkgaGVscGVyIGZ1bmN0aW9uXG5cdC8vcmVhZCBmaXJzdCAxNiBieXRlcyBmb3IgdGhlIElWXG5cdGxldCBpdiA9IEJ1ZmZlci5hbGxvYygxNik7XG5cdHRyeXtcblx0XHRmcy5yZWFkU3luYyhmZCwgaXYsIDAsIDE2LCBudWxsKTsgLy9zaG91bGQgYWR2YW5jZSBmaWxlIHBvc2l0aW9uIHRvIDE2IGJ5dGVzIGluXG5cdH1cblx0Y2F0Y2ggKGVycil7XG5cdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIHVzaW5nIGZzLnJlYWRTeW5jKGZkLCBpdiwgMCwgMTYsIG51bGwpIHRvIGdldCB0aGUgSVYgYmFja1wiKTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyKTtcblx0fVxuXG5cdC8vcmVhZCB0aGUgcmVzdCBmb3IgdGhlIGRhdGFcblx0bGV0IGNpcGhlcl9kYXRhID0gQnVmZmVyLmFsbG9jKGNpcGhlcl9kYXRhX2xlbmd0aCk7XG5cdGZzLnJlYWRTeW5jKGZkLCBjaXBoZXJfZGF0YSwgMCwgY2lwaGVyX2RhdGFfbGVuZ3RoLCBudWxsKTsgLy9zaG91bGQgc3RhcnQgdGhlIHJlYWQgZnJvbSAxNiBieXRlcyBpblxuXG5cdC8vbm93IG1ha2UgYSBkZWNpcGhlciBvYmplY3QgYW5kIGRlY3J5cHQgdGhlIGZpbGVcblx0Y29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihBTEdPUklUSE0sIGtleSwgaXYpO1xuXHRjb25zdCBkZWNyeXB0ZWRfZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShjaXBoZXJfZGF0YSksIGRlY2lwaGVyLmZpbmFsKCldKTtcblxuXHQvL3dyaXRlIHRoZSBjbGVhcnRleHQgZGF0YSBiYWNrIHRvIGZpbGVcblx0ZnMud3JpdGVTeW5jKGZkLCBkZWNyeXB0ZWRfZGF0YSwgMCwgZGVjcnlwdGVkX2RhdGEubGVuZ3RoLCAwKTtcblxuXHQvL3RydW5jYXRlIHRoZSByZW1haW5pbmcgY3J5cHRvIGJ5dGVzIGZyb20gdGhlIG92ZXJ3cml0dGVuIGZpbGVcblx0dHJ5e1xuXHRcdGZzLmZ0cnVuY2F0ZVN5bmMoZmQsIGNpcGhlcl9kYXRhX2xlbmd0aCk7IFxuXHR9XG5cdGNhdGNoIChlcnIpe1xuXHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciB0cnVuY2F0aW5nIGZpbGUgYWZ0ZXIgZGVjcnlwdGlvbiBpbiBkZWNyeXB0RmlsZSgpLCBmb3IgZmlsZTogXFxuXCIgKyBmaWxlX3BhdGgpO1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnIpO1xuXHR9XG5cblx0Ly9jbGVhbnVwXG5cdGZzLmNsb3NlKGZkLCAoZXJyKSA9PiB7XG5cdFx0aWYgKGVycil7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGNsb3NlIGZpbGUgZGVzY3JpcHRvciB3aGVuIGF0dGVtcHRpbmcgdG8gZGVjcnlwdCBmaWxlOiBcXG5cIiArIGZpbGVfcGF0aCArIFwiXFxuIGluIGZ1bmN0aW9uIGRlY3J5cHRGaWxlKClcXG5cIik7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyKTtcblx0XHR9XG5cdH0pO1xuXG59XG5cblxuLyoqXG4qKioqKioqKioqKioqKioqKioqKioqKipcbiogQmFja2VuZDogZmlsZXNcbioqKioqKioqKioqKioqKioqKioqKioqKlxuKiovXG5cbi8qKlxuKiBSZXR1cm5zIGFuIGZkIG9yIGVycm9yIGZvciBhIGZpbGUuXG4qIEBwYXJhbSB7c3RyaW5nfSBmaWxlX3BhdGhcbiogQHJldHVybnMge251bWJlcn0gZmRcbioqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wZW5GaWxlKCBmaWxlX3BhdGggKXtcblx0bGV0IGZkO1xuXHR0cnl7XG5cdFx0ZmQgPSBmcy5vcGVuU3luYyhmaWxlX3BhdGgsICdyKycpO1xuXHR9XG5cdGNhdGNoIChlcnIpe1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnIpO1xuXHR9XG5cblx0cmV0dXJuIGZkO1xufVxuXG4vKiogXG4qIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZSBhcyBhIGJ1ZmZlci5cbiogQHBhcmFtIHtzdHJpbmd9IGZpbGVfcGF0aCAtIGEgc2luZ2xlIGZpbGUgcGF0aCB0byByZWFkXG4qIEByZXR1cm4ge0J1ZmZlcn0gYnVmIC0gYnVmZmVyIG9mIGFuIGluZGl2aWR1YWwgZmlsZVxuKiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZUJ1ZmZlciggZmlsZV9wYXRoICl7XG5cdGZpbGVfcGF0aCA9IHBhdGgubm9ybWFsaXplKGZpbGVfcGF0aCk7XG5cdGxldCBidWY7XG5cdHRyeXtcblx0XHRidWYgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZV9wYXRoKTtcblx0fVxuXHRjYXRjaCAoZXJyKXtcblx0XHRjb25zb2xlLmVycm9yKFwiZmFpbGVkIGNhbGxpbmcgZ2V0RmlsZUJ1ZmZlcigpIG9uIGZpbGVfcGF0aDogXCIgKyBmaWxlX3BhdGgpO1xuXHRcdHRocm93IG5ldyBFcnJvcihlcnIpO1xuXHR9XG5cdHJldHVybiBidWY7XG59XG5cbi8qKlxuKiBUYWtlcyBhbiBhcnJheSBvZiBmaWxlcGF0aHMgYW5kIGVuY3J5cHRzIG9yIGRlY3J5cHRzIHRoZW0gZGVwZW5kaW5nIG9uIG9wZXJhdGlvbi5cbiogQHBhcmFtIHtBcnJheX08c3RyaW5nPiBmaWxlX2FycmF5XG4qIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRpb25cbioqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGVQcm9jZXNzb3IoIGZpbGVfYXJyYXksIG9wZXJhdGlvbiApe1xuXHRpZiAob3BlcmF0aW9uID09PSAnRU5DUllQVCcpe1xuXHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlX2FycmF5KXtcblx0XHRcdGVuY3J5cHRGaWxlKGZpbGUpO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG9wZXJhdGlvbiA9PT0gJ0RFQ1JZUFQnKXtcblx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZV9hcnJheSl7XG5cdFx0XHRkZWNyeXB0RmlsZShmaWxlKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiZmlsZVByb2Nlc3NvcihmaWxlX2FycmF5LCBvcGVyYXRpb24pIGNhbGxlZCB3aXRoIGludmFsaWQgb3BlcmF0aW9uIGFyZ3VtZW50LiBcXG4gR290IFwiICsgb3BlcmF0aW9uICsgXCIuIE11c3QgYmUgRU5DUllQVCBvciBERUNSWVBULlwiKTtcbn1cblxuLyoqXG4qIFJldHVybnMgYXJyYXkgb2YgYWxsIGZpbGVzIHdpdGggYWJzb2x1dGUgcGF0aHMgaW4gVmF1bHQgZGlyIGFuZCBhbGwgc3ViLWRpcnNcbiogQHBhcmFtIHtzdHJpbmd9IHZhdWx0IC0gYWJzb2x1dGUgcGF0aCB0byB0aGUgdXNlcidzIE9ic2lkaWFuIHZhdWx0XG4qIEByZXR1cm4ge0FycmF5fTxzdHJpbmc+IHZhdWx0X2ZpbGVzXG4qKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXVsdEZpbGVzKCB2YXVsdCApe1xuXHR2YXVsdCA9IHBhdGgubm9ybWFsaXplKHZhdWx0KTtcblxuXHRsZXQgdmF1bHRfZmlsZXMgPSBbXTtcblx0bGV0IGZpbGVzID0gW107XG5cblx0dHJ5IHtcblx0XHRmaWxlcyA9IGZzLnJlYWRkaXJTeW5jKHZhdWx0LCB7d2l0aEZpbGVUeXBlczogdHJ1ZX0pO1xuXHR9IFxuXHRjYXRjaCAoZXJyKSB7XG5cdFx0Y29uc29sZS5lcnJvcignZmFpbGVkIGNhbGxpbmcgZnNyZWFkZGlyU3luYyh2YXVsdCwge3dpdGhGaWxlVHlwZXM6IHRydWV9IG9uIHRoaXMgZGlyZWN0b3J5OiBcXCcnICsgdmF1bHQgKyAnXFwnXFxuJyk7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVycik7XG5cdH1cblx0XG5cdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcyl7XG5cdFx0aWYgKGZpbGUubmFtZVswXSA9PT0gJy4nKSBjb250aW51ZTsgLy9za2lwIGRvdGZpbGVzIC0tIGRvIGkgbmVlZCB0byBjaGFuZ2UgdGhpcyB0byBiZSBXaW5kb3dzIGNvbXBhdGlibGU/XG5cblx0XHRpZiAoZmlsZS5pc0ZpbGUoKSl7XG5cdFx0XHRsZXQgYWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKHZhdWx0LCBmaWxlLm5hbWUpO1xuXHRcdFx0dmF1bHRfZmlsZXMucHVzaChhYnNvbHV0ZVBhdGgpO1xuXHRcdFxuXHRcdH1cblxuXHRcdGVsc2UgaWYgKGZpbGUuaXNEaXJlY3RvcnkoKSl7XG5cdFx0XHR2YXVsdF9maWxlcy5wdXNoKC4uLmdldFZhdWx0RmlsZXMocGF0aC5yZXNvbHZlKHZhdWx0LCBmaWxlLm5hbWUpKSk7IFxuXHRcdFx0Ly8uLi4gaXMgc3ByZWFkIHN5bnRheCB1bnBhY2tpbmcgdGhlIHJldHVybmVkIHZhdWx0X2ZpbGVzIGFycmF5IGZyb20gdGhlIHJlY3Vyc2VkIGNhbGxcblx0XHR9XG5cdFxuXHR9XG5cblx0cmV0dXJuIHZhdWx0X2ZpbGVzO1xuXG5cdC8vdG9kbzogbWFrZSB2YXVsdF9maWxlcyBhIFRTIGFycmF5IG9mIG9ubHkgc3RyaW5nc1xuXG59IiwiaW1wb3J0IHsgQXBwLCBNb2RhbCwgRmlsZVZpZXcsIFdvcmtzcGFjZSwgUGx1Z2luLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgKiBhcyBjcnlwdG9Tb3VyY2UgZnJvbSAnLi9jcnlwdHNpZGlhbi5tanMnOyAvL2RvZXMgdGhpcyBuZWVkIHRvIGJlIGNvbnZlcnRlZCB3LyBwYXRoIGZvciB4LU9TP1xyXG4vKlxyXG4vLyBmdW5jdGlvbnMgd2UncmUgaW1wb3J0aW5nXHJcbmltcG9ydCB7aGFzRW5vdWdoRW50cm9weSwgc3RyaW5nU2FuaXRpemVyLCBzZXRVc2VyU2VjcmV0S2V5LCBrZXlEZXJpdmVyLCBlbmNyeXB0RmlsZSwgZGVjcnlwdEZpbGUsIGdldFZhdWx0RmlsZXMsIGZpbGVQcm9jZXNzb3IsIGdldEZpbGVCdWZmZXIsIG9wZW5GaWxlfSBmcm9tICcuL3RtcGNyeXB0c2lkaWFuLm1qcyc7XHJcblxyXG4vLyB2YXJpYWJsZXMgd2UncmUgaW1wb3J0aW5nXHJcbmltcG9ydCB7QUxHT1JJVEhNLCBTQUxULCBFTkNSWVBULCBERUNSWVBULCBLRVlfTEVOR1RIfSBmcm9tICcuL3RtcGNyeXB0c2lkaWFuLmpzJztcclxuKi9cclxuXHJcbmludGVyZmFjZSBNeVBsdWdpblNldHRpbmdzIHtcclxuXHRteVNldHRpbmcgOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XHJcblx0bXlTZXR0aW5nIDogJ2RlZmF1bHQnXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcclxuXHRzZXR0aW5ncyA6IE15UGx1Z2luU2V0dGluZ3M7XHJcblxyXG5cdGFzeW5jIG9ubG9hZCgpIHtcclxuXHRcdGNvbnNvbGUubG9nKCdsb2FkaW5nIHBsdWdpbicpO1xyXG5cclxuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQgICA6ICdvcGVuLWVuY3J5cHQtbW9kYWwnLFxyXG5cdFx0XHRuYW1lIDogJ09wZW4gRW5jcnlwdCBNb2RhbCcsXHJcblx0XHRcdFxyXG5cdFx0XHRjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcclxuXHRcdFx0XHRsZXQgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmO1xyXG5cdFx0XHRcdGlmIChsZWFmKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNoZWNraW5nKSB7XHJcblx0XHRcdFx0XHRcdG5ldyBDcnlwdG9Nb2RhbCh0aGlzLmFwcCwgJ0VuY3J5cHQnKS5vcGVuKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQgICA6ICdvcGVuLWRlY3J5cHQtbW9kYWwnLFxyXG5cdFx0XHRuYW1lIDogJ09wZW4gRGVjcnlwdCBNb2RhbCcsXHJcblx0XHRcdFxyXG5cdFx0XHRjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmc6IGJvb2xlYW4pID0+IHtcclxuXHRcdFx0XHRsZXQgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5hY3RpdmVMZWFmO1xyXG5cdFx0XHRcdGlmIChsZWFmKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNoZWNraW5nKSB7XHJcblx0XHRcdFx0XHRcdG5ldyBDcnlwdG9Nb2RhbCh0aGlzLmFwcCwgJ0RlY3J5cHQnKS5vcGVuKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRvbnVubG9hZCgpIHtcclxuXHRcdGNvbnNvbGUubG9nKCd1bmxvYWRpbmcgcGx1Z2luJyk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgQ3J5cHRvTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XHJcblx0cGFzc3dvcmQgIDogc3RyaW5nID0gbnVsbDtcclxuXHRvcGVyYXRpb24gOiBzdHJpbmcgPSBudWxsO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgb3BlcmF0aW9uOiBzdHJpbmcpIHtcclxuXHRcdHN1cGVyKGFwcCk7XHJcblx0XHR0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcclxuXHR9XHJcblxyXG5cdG9uT3BlbigpIHtcclxuXHJcblx0XHQvLyBnZXQgdmF1bHQgZGlyXHJcblx0XHRsZXQgdmF1bHRfZGlyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xyXG5cclxuXHRcdC8vaW5pdGlhaWx6ZSBhbiBlbXB0eSBET00gb2JqZWN0IHRvIGhvbGQgb3VyIG1vZGFsXHJcblx0XHRsZXQgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHJcblx0XHQvL3RpdGxlIC0gdG8gbGV0IHRoZSB1c2VyIGtub3cgd2hpY2ggbW9kZSAoZW5jcnlwdC9kZWNyeXB0KSB0aGV5J3JlIGluXHJcblx0XHRjb25zdCB0aXRsZUVsID0gY29udGVudEVsLmNyZWF0ZURpdigpO1xyXG5cdFx0dGl0bGVFbC5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xyXG5cdFx0dGl0bGVFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMWVtJztcclxuXHRcdHRpdGxlRWwuc2V0VGV4dChgJHt0aGlzLm9wZXJhdGlvbn1gKTtcclxuXHJcblx0XHQvL25vdGljZSAtIHRvIGxldCB0aGUgdXNlciBrbm93IHdoaWNoIGZvbGRlciB3aWxsIGJlIGVuY3J5cHRlZC9kZWNyeXB0ZWRcclxuXHRcdGNvbnN0IGZvbGRlck5vdGljZSA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoKTtcclxuXHRcdGZvbGRlck5vdGljZS5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMWVtJztcclxuXHRcdGZvbGRlck5vdGljZS5zZXRUZXh0KCdUaGlzIG9wZXJhdGlvbiB3aWxsIGFwcGx5IHRvIGFsbCBmaWxlcyBhbmQgZm9sZGVycyBpbjogJyArIHZhdWx0X2Rpcik7XHJcblx0XHRmb2xkZXJOb3RpY2Uuc3R5bGUuY29sb3IgPSAncmVkJztcclxuXHJcblx0XHQvL25vdGljZSAtIHRlbGwgdXNlciBub3QgdG8gb3BlbiBlbmNycHl0ZWQgZmlsZXNcclxuXHRcdGNvbnN0IGNvcnJwdXRpb25Ob3RpY2UgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XHJcblx0XHRjb3JycHV0aW9uTm90aWNlLnN0eWxlLm1hcmdpbkJvdHRvbSA9ICcxLjVlbSc7XHJcblx0XHRjb3JycHV0aW9uTm90aWNlLnNldFRleHQoJ0RvIG5vdCBvcGVuIGZpbGVzIHdpdGggT2JzaWRpYW4gYWZ0ZXIgZW5jcnlwdGluZyAtIHRoZXkgY2FuIGJlY29tZSBjb3JydXB0ZWQgYW5kIGlycmVjb3ZlcmFibGUuIEFsd2F5cyB1c2UgdGhlIERlY3J5cHQgY29tbWFuZCBwcmlvciB0byByZS1vcGVuaW5nIGZpbGVzIScpO1xyXG5cdFx0Y29ycnB1dGlvbk5vdGljZS5zdHlsZS5jb2xvciA9ICdyZWQnO1xyXG5cdFx0XHJcblx0XHQvL21ha2UgYSBkaXYgZm9yIHVzZXIncyBwdyBpbnB1dFxyXG4gICAgICAgIGNvbnN0IGlucHV0UHdDb250YWluZXJFbCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoKTtcclxuICAgICAgICBjb25zdCBwd0lucHV0RWwgPSBpbnB1dFB3Q29udGFpbmVyRWwuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAncGFzc3dvcmQnLCB2YWx1ZTogJycgfSk7XHJcbiAgICAgICAgcHdJbnB1dEVsLnBsYWNlaG9sZGVyID0gJ1BsZWFzZSBlbnRlciB5b3VyIHBhc3N3b3JkJztcclxuICAgICAgICBwd0lucHV0RWwuc3R5bGUud2lkdGggPSAnNzAlJztcclxuICAgICAgICBwd0lucHV0RWwuZm9jdXMoKTtcclxuXHJcblx0XHQvL21ha2UgYSBkaXYgZm9yIHB3IGNvbmZpcm1hdGlvblxyXG5cdFx0Y29uc3QgY29uZmlybVB3Q29udGFpbmVyRWwgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XHJcblx0XHRjb25maXJtUHdDb250YWluZXJFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMWVtJztcclxuXHRcdGNvbnN0IHB3Q29uZmlybUVsID0gY29uZmlybVB3Q29udGFpbmVyRWwuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAncGFzc3dvcmQnLCB2YWx1ZTogJyd9KTtcclxuXHRcdHB3Q29uZmlybUVsLnBsYWNlaG9sZGVyID0gJ0NvbmZpcm0geW91ciBwYXNzd29yZCc7XHJcblx0XHRwd0NvbmZpcm1FbC5zdHlsZS53aWR0aCA9ICc3MCUnO1xyXG5cclxuXHRcdC8vbWFrZSBhIHN1Ym1pdCBidXR0b24gZm9yIHRoZSBjcnlwdG8gb3BlcmF0aW9uXHJcblx0XHRjb25zdCBjb25maXJtQnRuRWwgPSBjb25maXJtUHdDb250YWluZXJFbC5jcmVhdGVFbCgnYnV0dG9uJywgeyB0ZXh0OiBgJHt0aGlzLm9wZXJhdGlvbn1gIH0pO1xyXG5cdFx0Y29uZmlybUJ0bkVsLnN0eWxlLm1hcmdpbkxlZnQgPSAnMWVtJztcclxuXHRcdFxyXG5cdFx0Ly9tZXNzYWdlIG1vZGFsIC0gdG8gZmlyZSBpZiBwYXNzd29yZHMgZG9uJ3QgbWF0Y2hcclxuXHRcdGNvbnN0IG1lc3NhZ2VNYXRjaEVsID0gY29udGVudEVsLmNyZWF0ZURpdigpO1xyXG5cdFx0bWVzc2FnZU1hdGNoRWwuc3R5bGUubWFyZ2luVG9wID0gJzFlbSc7XHJcblx0XHRtZXNzYWdlTWF0Y2hFbC5zdHlsZS5jb2xvciA9ICdyZWQnO1xyXG5cdFx0bWVzc2FnZU1hdGNoRWwuc2V0VGV4dCgnUGFzc3dvcmRzIG11c3QgbWF0Y2gnKTtcclxuXHRcdG1lc3NhZ2VNYXRjaEVsLmhpZGUoKTtcclxuXHJcblx0XHQvL21lc3NhZ2UgbW9kYWwgLSB0byBmaXJlIGlmIGVpdGhlciBpbnB1dCBpcyBlbXB0eVxyXG5cdFx0Y29uc3QgbWVzc2FnZUVtcHR5RWwgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XHJcblx0XHRtZXNzYWdlRW1wdHlFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMWVtJztcclxuXHRcdG1lc3NhZ2VFbXB0eUVsLnN0eWxlLmNvbG9yID0gJ3JlZCc7XHJcblx0XHRtZXNzYWdlRW1wdHlFbC5zZXRUZXh0KCdQbGVhc2UgZW50ZXIgeW91ciBwYXNzd29yZCBpbiBib3RoIGJveGVzLicpO1xyXG5cdFx0bWVzc2FnZUVtcHR5RWwuaGlkZSgpO1xyXG5cclxuXHRcdC8vbWVzc2FnZSBtb2RhbCAtIHRvIGZpcmUgd2l0aCBjcnlwdG9Tb3VyY2Uuc3RyaW5nU2FuaXRpemVyKCkgZXJyb3IgbWVzc2FnZSwgaWYgYW55XHJcblx0XHRjb25zdCBtZXNzYWdlRWwgPSBjb250ZW50RWwuY3JlYXRlRGl2KCk7XHJcblx0XHRtZXNzYWdlRWwuc3R5bGUuY29sb3IgPSAncmVkJztcclxuXHRcdG1lc3NhZ2VFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnMWVtJztcclxuXHRcdG1lc3NhZ2VFbC5oaWRlKCk7XHJcblx0XHRcclxuXHRcdC8vIGNoZWNrIHRoZSBpbnB1dFxyXG5cdFx0Y29uc3QgcHdDaGVja2VyID0gKGV2KSA9PiB7IC8vIHdlIHVzZSBhbiBhcnJvdyBmdW5jdGlvbiB0byBwcmVzZXJ2ZSBhY2Nlc3MgdG8gdGhlIFwidGhpc1wiIHdlIHdhbnRcclxuXHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0bGV0IGdvb2RfdG9fZ28gPSBmYWxzZTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIGlzIGVpdGhlciBpbnB1dCBmaWVsZCBlbXB0eT9cclxuXHRcdFx0aWYgKHB3SW5wdXRFbC52YWx1ZSA9PSAnJyB8fCBwd0lucHV0RWwudmFsdWUgPT0gbnVsbCB8fCBwd0NvbmZpcm1FbC52YWx1ZSA9PSAnJyB8fCBwd0NvbmZpcm1FbC52YWx1ZSA9PSBudWxsKXtcclxuXHRcdFx0XHRnb29kX3RvX2dvID0gZmFsc2U7XHJcblx0XHRcdFx0bWVzc2FnZUVtcHR5RWwuc2hvdygpO1x0XHRcdFx0XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChwd0lucHV0RWwudmFsdWUgIT09ICcnICYmIHB3SW5wdXRFbC52YWx1ZSAhPT0gbnVsbCAmJiBwd0NvbmZpcm1FbC52YWx1ZSAhPT0gJycgJiYgcHdDb25maXJtRWwudmFsdWUgIT09IG51bGwpe1xyXG5cdFx0XHRcdGdvb2RfdG9fZ28gPSB0cnVlO1xyXG5cdFx0XHRcdG1lc3NhZ2VFbXB0eUVsLmhpZGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZG8gYm90aCBwYXNzd29yZCBpbnB1dHMgbWF0Y2g/XHJcblx0XHRcdGlmIChwd0lucHV0RWwudmFsdWUgIT09IHB3Q29uZmlybUVsLnZhbHVlKXtcclxuXHRcdFx0XHRnb29kX3RvX2dvID0gZmFsc2U7XHJcblx0XHRcdFx0bWVzc2FnZU1hdGNoRWwuc2hvdygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocHdJbnB1dEVsLnZhbHVlID09PSBwd0NvbmZpcm1FbC52YWx1ZSl7XHJcblx0XHRcdFx0Z29vZF90b19nbyA9IHRydWU7XHJcblx0XHRcdFx0bWVzc2FnZU1hdGNoRWwuaGlkZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpcyB0aGUgdXNlcidzIHBhc3N3b3JkIHN0cm9uZyBlbm91Z2ggZm9yIGNyeXB0bz9cclxuXHRcdFx0aWYgKGdvb2RfdG9fZ28pe1xyXG5cdFx0XHRcdHRyeXtcclxuXHRcdFx0XHRcdG1lc3NhZ2VFbC5oaWRlKCk7XHJcblx0XHRcdFx0XHRnb29kX3RvX2dvID0gQm9vbGVhbihjcnlwdG9Tb3VyY2Uuc3RyaW5nU2FuaXRpemVyKHB3SW5wdXRFbC52YWx1ZSkpOyBcclxuXHRcdFx0XHRcdC8vdHJ1ZSBpZiB1c2VyIGlucHV0IGhhZCBlbm91Z2ggZW50cm9weSwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoKGVycm9yKXtcclxuXHRcdFx0XHRcdGdvb2RfdG9fZ28gPSBmYWxzZTtcclxuXHRcdFx0XHRcdG1lc3NhZ2VFbC5zZXRUZXh0KGVycm9yLm1lc3NhZ2UpO1xyXG5cdFx0XHRcdFx0bWVzc2FnZUVsLnNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIGFsbCBjaGVja3MgcGFzcywgZXhlY3V0ZSB0aGUgY3J5cHRvIG9wZXJhdGlvblxyXG5cdFx0XHRpZiAoZ29vZF90b19nbyl7XHJcblx0XHRcdFx0dGhpcy5wYXNzd29yZCA9IHB3Q29uZmlybUVsLnZhbHVlO1xyXG5cdFx0XHRcdGNyeXB0b1NvdXJjZS5zZXRVc2VyU2VjcmV0S2V5KHRoaXMucGFzc3dvcmQpOyAvL2Rlcml2ZSB0aGUgc2VjcmV0IGtleSB2aWEgc2NyeXB0IGZyb20gdXNlcidzIHBhc3N3b3JkXHJcblxyXG5cdFx0XHRcdC8vIGNsb3NlIG9wZW4gbm90ZXMgdG8gcHJldmVudCBwb3N0LWVuY3J5cHRpb24gYWNjZXNzLCB3aGljaCBjYW4gY29ycnVwdCBmaWxlcyBhbmQgbWFrZSB0aGVtIGlycmVjb3ZlcmFibGVcclxuXHRcdFx0XHRjb25zdCBlbXB0eUxlYWYgPSBhc3luYyAobGVhZjogV29ya3NwYWNlTGVhZik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG5cdFx0XHRcdFx0bGVhZi5zZXRWaWV3U3RhdGUoe3R5cGU6J2VtcHR5J30pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgY2xvc2VMZWF2ZXMgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7IC8vIHdlIHVzZSB0aGlzIGZ1bmN0aW9uIGNvbnN0cnVjdGlvbiB0byBnZXQgYXN5bmMvYXdhaXQgYW5kIGtlZXAgdGhlIHJpZ2h0IFwidGhpc1wiXHJcblx0XHRcdFx0XHRsZXQgbGVhdmVzOiBXb3Jrc3BhY2VMZWFmW10gPSBbXTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2UuaXRlcmF0ZUFsbExlYXZlcyggKGxlYWYpID0+IHtcclxuXHRcdFx0XHRcdFx0bGVhdmVzLnB1c2gobGVhZik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKXtcclxuXHRcdFx0XHRcdFx0aWYoIGxlYWYudmlldyBpbnN0YW5jZW9mIEZpbGVWaWV3ICl7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgZW1wdHlMZWFmKGxlYWYpO1xyXG5cdFx0XHRcdFx0XHRcdGxlYWYuZGV0YWNoKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRcdGNvbnN0IHByb2Nlc3NGaWxlcyA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuXHRcdFx0XHRcdGF3YWl0IGNsb3NlTGVhdmVzKCk7XHJcblx0XHRcdFx0XHRjcnlwdG9Tb3VyY2UuZmlsZVByb2Nlc3NvcihmaWxlcywgdGhpcy5vcGVyYXRpb24udG9VcHBlckNhc2UoKSk7IFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvL3J1biB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXHJcblx0XHRcdFx0bGV0IGZpbGVzID0gY3J5cHRvU291cmNlLmdldFZhdWx0RmlsZXModmF1bHRfZGlyKTtcclxuXHRcdFx0XHRwcm9jZXNzRmlsZXMoKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvL3JlZ2lzdGVyIHRoZSBidXR0b24ncyBldmVudCBoYW5kbGVyXHJcblx0XHRjb25maXJtQnRuRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwd0NoZWNrZXIpO1xyXG5cclxuXHRcdC8vYWxsb3cgZW50ZXIgdG8gc3VibWl0XHJcblx0XHRjb25zdCBlbnRlclN1Ym1pdHMgPSBmdW5jdGlvbihldiwgdmFsdWUpe1xyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0KCBldi5jb2RlID09PSAnRW50ZXInIHx8IGV2LmNvZGUgPT09ICdOdW1wYWRFbnRlcicgKVxyXG5cdFx0XHRcdCYmIHZhbHVlLmxlbmd0aCA+IDBcclxuXHRcdFx0XHQmJiBjb25maXJtQnRuRWwuZGlzYWJsZWQgPT09IGZhbHNlXHJcblx0XHRcdCl7XHJcblx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRjb25maXJtQnRuRWwuY2xpY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cHdJbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24oZXYpeyBlbnRlclN1Ym1pdHMoZXYsIHB3SW5wdXRFbC52YWx1ZSkgfSk7XHJcblx0XHRwd0NvbmZpcm1FbC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGV2KXsgZW50ZXJTdWJtaXRzKGV2LCBwd0lucHV0RWwudmFsdWUpIH0pO1xyXG5cclxuXHR9XHJcblxyXG5cdG9uQ2xvc2UoKSB7XHJcblx0XHRsZXQgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHR9XHJcbn1cclxuIl0sIm5hbWVzIjpbImNyeXB0byIsImZzIiwicGF0aCIsIlBsdWdpbiIsIk1vZGFsIiwiY3J5cHRvU291cmNlLnN0cmluZ1Nhbml0aXplciIsImNyeXB0b1NvdXJjZS5zZXRVc2VyU2VjcmV0S2V5IiwiRmlsZVZpZXciLCJjcnlwdG9Tb3VyY2UuZmlsZVByb2Nlc3NvciIsImNyeXB0b1NvdXJjZS5nZXRWYXVsdEZpbGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdURBO0FBQ08sU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFO0FBQzdELElBQUksU0FBUyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsT0FBTyxLQUFLLFlBQVksQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxVQUFVLE9BQU8sRUFBRSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0FBQ2hILElBQUksT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFDLEVBQUUsVUFBVSxPQUFPLEVBQUUsTUFBTSxFQUFFO0FBQy9ELFFBQVEsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtBQUNuRyxRQUFRLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtBQUN0RyxRQUFRLFNBQVMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsRUFBRTtBQUN0SCxRQUFRLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxVQUFVLElBQUksRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztBQUM5RSxLQUFLLENBQUMsQ0FBQztBQUNQOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQztBQUNoQyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxrRUFBa0UsRUFBRSxLQUFLLENBQUMsQ0FBQztBQVN6RyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsQ0FBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsZUFBZSxFQUFFLEtBQUssRUFBRTtBQUN4QyxDQUFDLElBQUksT0FBTyxLQUFLLENBQUMsS0FBSyxRQUFRLENBQUM7QUFDaEMsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxHQUFHLE9BQU8sS0FBSyxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUM7QUFDekYsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hDO0FBQ0E7QUFDQSxDQUFDLElBQUksZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0IsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUNmLEVBQUU7QUFDRjtBQUNBLENBQUMsT0FBTyxLQUFLLENBQUM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7QUFDbkQsQ0FBQyxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDaEIsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLDJGQUEyRixDQUFDLENBQUM7QUFDL0csRUFBRTtBQUNGO0FBQ0EsQ0FBQyxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDbkIsQ0FBQyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDekQ7QUFDQSxDQUFDLElBQUksS0FBSyxJQUFJLEVBQUUsQ0FBQztBQUNqQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO0FBQy9CLEdBQUcsTUFBSztBQUNSLElBQUksSUFBSSxFQUFFLGVBQWU7QUFDekIsSUFBSSxPQUFPLEVBQUUsK0NBQStDLEdBQUcsU0FBUyxHQUFHLDBCQUEwQjtBQUNyRyxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxTQUFTLElBQUksRUFBRSxDQUFDO0FBQzFDLEVBQUUsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLFNBQVMsSUFBSSxFQUFFLENBQUM7QUFDNUMsRUFBRSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsU0FBUyxJQUFJLEVBQUUsQ0FBQztBQUM1QyxFQUFFLElBQUkseUNBQXlDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLFNBQVMsSUFBSSxFQUFFLENBQUM7QUFDN0U7QUFDQSxFQUFFLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNwRDtBQUNBLEVBQUUsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3RCLEdBQUcsTUFBSztBQUNSLElBQUksSUFBSSxFQUFFLGVBQWU7QUFDekIsSUFBSSxPQUFPLEVBQUUseUlBQXlJO0FBQ3RKLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxPQUFPLElBQUksT0FBTyxJQUFJLEtBQUssQ0FBQztBQUM1QixHQUFHLE9BQU8sSUFBSSxDQUFDO0FBQ2YsR0FBRztBQUNIO0FBQ0EsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUNmO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQyxPQUFPLEtBQUssQ0FBQztBQUNkLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLGdCQUFnQixFQUFFLFFBQVEsRUFBRTtBQUM1QyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3RDLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNsQyxDQUFDLE9BQU87QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLFVBQVUsRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDLFVBQVUsRUFBRTtBQUMxRCxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLFFBQVEsQ0FBQztBQUNoRCxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMscUVBQXFFLENBQUMsQ0FBQztBQUN6RixFQUFFO0FBQ0Y7QUFDQSxDQUFDLElBQUksUUFBUSxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2QyxDQUFDLElBQUksUUFBUSxDQUFDO0FBQ2QsRUFBRSxTQUFTLEdBQUdBLGlCQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDNUQsRUFBRSxPQUFPLFNBQVMsQ0FBQztBQUNuQixFQUFFO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsWUFBWSxHQUFHO0FBQ3hCLENBQUMsSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDO0FBQ3ZCLEVBQUUsTUFBSztBQUNQLElBQUksSUFBSSxFQUFFLFVBQVU7QUFDcEIsSUFBSSxPQUFPLEVBQUUsMENBQTBDO0FBQ3ZELElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQSxDQUFDLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxVQUFVLENBQUM7QUFDckMsRUFBRSxNQUFLO0FBQ1AsR0FBRyxJQUFJLEVBQUUsVUFBVTtBQUNuQixHQUFHLE9BQU8sRUFBRSwwQ0FBMEMsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLHdCQUF3QixHQUFHLFVBQVUsR0FBRyxRQUFRO0FBQzVILEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQSxDQUFDLE9BQU8sU0FBUyxDQUFDO0FBQ2xCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxXQUFXLEVBQUUsU0FBUyxFQUFFO0FBQ3hDO0FBQ0EsQ0FBQyxJQUFJLElBQUksR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDckMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDOUI7QUFDQTtBQUNBLENBQUMsSUFBSSxFQUFFLEdBQUdBLGlCQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDLElBQUksR0FBRyxHQUFHLFlBQVksRUFBRSxDQUFDO0FBQzFCO0FBQ0E7QUFDQSxDQUFDLE1BQU0sTUFBTSxHQUFHQSxpQkFBTSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzFELENBQUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUNDLGFBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN2QyxDQUFDQSxhQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZFO0FBQ0E7QUFDQSxDQUFDQSxhQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSztBQUN2QixFQUFFLElBQUksR0FBRyxDQUFDO0FBQ1YsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLHFFQUFxRSxHQUFHLFNBQVMsR0FBRyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ3ZJLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4QixHQUFHO0FBQ0gsRUFBRSxDQUFDLENBQUM7QUFDSjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLFdBQVcsRUFBRSxTQUFTLEVBQUU7QUFDeEM7QUFDQTtBQUNBLENBQUMsSUFBSSxLQUFLLEdBQUdBLGFBQUUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDcEM7QUFDQTtBQUNBLENBQUMsSUFBSSxHQUFHLEdBQUcsWUFBWSxFQUFFLENBQUM7QUFDMUI7QUFDQTtBQUNBLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCO0FBQ0E7QUFDQSxDQUFDLElBQUksa0JBQWtCLElBQUksS0FBSyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDM0IsQ0FBQyxHQUFHO0FBQ0osRUFBRUEsYUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDbkMsRUFBRTtBQUNGLENBQUMsT0FBTyxHQUFHLENBQUM7QUFDWixFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUVBQWlFLENBQUMsQ0FBQztBQUNuRixFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkIsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDLElBQUksV0FBVyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNwRCxDQUFDQSxhQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxFQUFFLGtCQUFrQixFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzNEO0FBQ0E7QUFDQSxDQUFDLE1BQU0sUUFBUSxHQUFHRCxpQkFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDOUQsQ0FBQyxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3hGO0FBQ0E7QUFDQSxDQUFDQyxhQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0Q7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKLEVBQUVBLGFBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLGtCQUFrQixDQUFDLENBQUM7QUFDM0MsRUFBRTtBQUNGLENBQUMsT0FBTyxHQUFHLENBQUM7QUFDWixFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsdUVBQXVFLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDckcsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLEVBQUU7QUFDRjtBQUNBO0FBQ0EsQ0FBQ0EsYUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUs7QUFDdkIsRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUNWLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxxRUFBcUUsR0FBRyxTQUFTLEdBQUcsZ0NBQWdDLENBQUMsQ0FBQztBQUN2SSxHQUFHLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDeEIsR0FBRztBQUNILEVBQUUsQ0FBQyxDQUFDO0FBQ0o7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLFFBQVEsRUFBRSxTQUFTLEVBQUU7QUFDckMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNSLENBQUMsR0FBRztBQUNKLEVBQUUsRUFBRSxHQUFHQSxhQUFFLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNwQyxFQUFFO0FBQ0YsQ0FBQyxPQUFPLEdBQUcsQ0FBQztBQUNaLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixFQUFFO0FBQ0Y7QUFDQSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ1gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsYUFBYSxFQUFFLFNBQVMsRUFBRTtBQUMxQyxDQUFDLFNBQVMsR0FBR0MsZUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUN2QyxDQUFDLElBQUksR0FBRyxDQUFDO0FBQ1QsQ0FBQyxHQUFHO0FBQ0osRUFBRSxHQUFHLEdBQUdELGFBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDbkMsRUFBRTtBQUNGLENBQUMsT0FBTyxHQUFHLENBQUM7QUFDWixFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsK0NBQStDLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDN0UsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLEVBQUU7QUFDRixDQUFDLE9BQU8sR0FBRyxDQUFDO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsYUFBYSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUU7QUFDdEQsQ0FBQyxJQUFJLFNBQVMsS0FBSyxTQUFTLENBQUM7QUFDN0IsRUFBRSxLQUFLLE1BQU0sSUFBSSxJQUFJLFVBQVUsQ0FBQztBQUNoQyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQixHQUFHO0FBQ0gsRUFBRSxPQUFPO0FBQ1QsRUFBRTtBQUNGLENBQUMsSUFBSSxTQUFTLEtBQUssU0FBUyxDQUFDO0FBQzdCLEVBQUUsS0FBSyxNQUFNLElBQUksSUFBSSxVQUFVLENBQUM7QUFDaEMsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckIsR0FBRztBQUNILEVBQUUsT0FBTztBQUNULEVBQUU7QUFDRixNQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsc0ZBQXNGLEdBQUcsU0FBUyxHQUFHLCtCQUErQixDQUFDLENBQUM7QUFDNUosQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsYUFBYSxFQUFFLEtBQUssRUFBRTtBQUN0QyxDQUFDLEtBQUssR0FBR0MsZUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMvQjtBQUNBLENBQUMsSUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLENBQUMsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2hCO0FBQ0EsQ0FBQyxJQUFJO0FBQ0wsRUFBRSxLQUFLLEdBQUdELGFBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDdkQsRUFBRTtBQUNGLENBQUMsT0FBTyxHQUFHLEVBQUU7QUFDYixFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUZBQWlGLEdBQUcsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQ3BILEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixFQUFFO0FBQ0Y7QUFDQSxDQUFDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxDQUFDO0FBQzFCLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxTQUFTO0FBQ3JDO0FBQ0EsRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNwQixHQUFHLElBQUksWUFBWSxHQUFHQyxlQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckQsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2xDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUM5QixHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxhQUFhLENBQUNBLGVBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDLE9BQU8sV0FBVyxDQUFDO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQSxNQUFNLGdCQUFnQixHQUFxQjtJQUMxQyxTQUFTLEVBQUcsU0FBUztDQUNyQixDQUFBO01BRW9CLFFBQVMsU0FBUUMsZUFBTTtJQUdyQyxNQUFNOztZQUNYLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUU5QixNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUUxQixJQUFJLENBQUMsVUFBVSxDQUFDO2dCQUNmLEVBQUUsRUFBSyxvQkFBb0I7Z0JBQzNCLElBQUksRUFBRyxvQkFBb0I7Z0JBRTNCLGFBQWEsRUFBRSxDQUFDLFFBQWlCO29CQUNoQyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7b0JBQ3pDLElBQUksSUFBSSxFQUFFO3dCQUNULElBQUksQ0FBQyxRQUFRLEVBQUU7NEJBQ2QsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzt5QkFDNUM7d0JBQ0QsT0FBTyxJQUFJLENBQUM7cUJBQ1o7b0JBQ0QsT0FBTyxLQUFLLENBQUM7aUJBQ2I7YUFFRCxDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsVUFBVSxDQUFDO2dCQUNmLEVBQUUsRUFBSyxvQkFBb0I7Z0JBQzNCLElBQUksRUFBRyxvQkFBb0I7Z0JBRTNCLGFBQWEsRUFBRSxDQUFDLFFBQWlCO29CQUNoQyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7b0JBQ3pDLElBQUksSUFBSSxFQUFFO3dCQUNULElBQUksQ0FBQyxRQUFRLEVBQUU7NEJBQ2QsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzt5QkFDNUM7d0JBQ0QsT0FBTyxJQUFJLENBQUM7cUJBQ1o7b0JBQ0QsT0FBTyxLQUFLLENBQUM7aUJBQ2I7YUFFRCxDQUFDLENBQUM7U0FDSDtLQUFBO0lBRUQsUUFBUTtRQUNQLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQztLQUNoQztJQUVLLFlBQVk7O1lBQ2pCLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztTQUMzRTtLQUFBO0lBRUssWUFBWTs7WUFDakIsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNuQztLQUFBO0NBRUQ7QUFFRCxNQUFNLFdBQVksU0FBUUMsY0FBSztJQUk5QixZQUFZLEdBQVEsRUFBRSxTQUFpQjtRQUN0QyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFKWixhQUFRLEdBQWEsSUFBSSxDQUFDO1FBQzFCLGNBQVMsR0FBWSxJQUFJLENBQUM7UUFJekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7S0FDM0I7SUFFRCxNQUFNOztRQUdMLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7UUFHckQsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQztRQUN6QixTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7O1FBR2xCLE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN0QyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7UUFDbEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQ25DLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQzs7UUFHckMsTUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzNDLFlBQVksQ0FBQyxLQUFLLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUN4QyxZQUFZLENBQUMsT0FBTyxDQUFDLHlEQUF5RCxHQUFHLFNBQVMsQ0FBQyxDQUFDO1FBQzVGLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7UUFHakMsTUFBTSxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDL0MsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUM7UUFDOUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLDJKQUEySixDQUFDLENBQUM7UUFDdEwsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7O1FBRy9CLE1BQU0sa0JBQWtCLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pELE1BQU0sU0FBUyxHQUFHLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3hGLFNBQVMsQ0FBQyxXQUFXLEdBQUcsNEJBQTRCLENBQUM7UUFDckQsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQzlCLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7UUFHeEIsTUFBTSxvQkFBb0IsR0FBRyxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbkQsb0JBQW9CLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDN0MsTUFBTSxXQUFXLEdBQUcsb0JBQW9CLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBQyxDQUFDLENBQUM7UUFDM0YsV0FBVyxDQUFDLFdBQVcsR0FBRyx1QkFBdUIsQ0FBQztRQUNsRCxXQUFXLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7O1FBR2hDLE1BQU0sWUFBWSxHQUFHLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVGLFlBQVksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQzs7UUFHdEMsTUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzdDLGNBQWMsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN2QyxjQUFjLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQy9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7UUFHdEIsTUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzdDLGNBQWMsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN2QyxjQUFjLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkMsY0FBYyxDQUFDLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO1FBQ3BFLGNBQWMsQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7UUFHdEIsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3hDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUM5QixTQUFTLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDbEMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDOztRQUdqQixNQUFNLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDcEIsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3BCLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQzs7WUFHdkIsSUFBSSxTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUUsSUFBSSxTQUFTLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxXQUFXLENBQUMsS0FBSyxJQUFJLEVBQUUsSUFBSSxXQUFXLENBQUMsS0FBSyxJQUFJLElBQUksRUFBQztnQkFDNUcsVUFBVSxHQUFHLEtBQUssQ0FBQztnQkFDbkIsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3RCO1lBRUQsSUFBSSxTQUFTLENBQUMsS0FBSyxLQUFLLEVBQUUsSUFBSSxTQUFTLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxXQUFXLENBQUMsS0FBSyxLQUFLLEVBQUUsSUFBSSxXQUFXLENBQUMsS0FBSyxLQUFLLElBQUksRUFBQztnQkFDaEgsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDbEIsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3RCOztZQUdELElBQUksU0FBUyxDQUFDLEtBQUssS0FBSyxXQUFXLENBQUMsS0FBSyxFQUFDO2dCQUN6QyxVQUFVLEdBQUcsS0FBSyxDQUFDO2dCQUNuQixjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDdEI7WUFFRCxJQUFJLFNBQVMsQ0FBQyxLQUFLLEtBQUssV0FBVyxDQUFDLEtBQUssRUFBQztnQkFDekMsVUFBVSxHQUFHLElBQUksQ0FBQztnQkFDbEIsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3RCOztZQUdELElBQUksVUFBVSxFQUFDO2dCQUNkLElBQUc7b0JBQ0YsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO29CQUNqQixVQUFVLEdBQUcsT0FBTyxDQUFDQyxlQUE0QixDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOztpQkFFcEU7Z0JBQ0QsT0FBTSxLQUFLLEVBQUM7b0JBQ1gsVUFBVSxHQUFHLEtBQUssQ0FBQztvQkFDbkIsU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ2pDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDakI7YUFDRDs7WUFHRCxJQUFJLFVBQVUsRUFBQztnQkFDZCxJQUFJLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUM7Z0JBQ2xDQyxnQkFBNkIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7O2dCQUc3QyxNQUFNLFNBQVMsR0FBRyxDQUFPLElBQW1CO29CQUMzQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUMsSUFBSSxFQUFDLE9BQU8sRUFBQyxDQUFDLENBQUM7aUJBQ2xDLENBQUEsQ0FBQTtnQkFFRCxNQUFNLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxNQUFNLEdBQW9CLEVBQUUsQ0FBQztvQkFFakMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUUsQ0FBQyxJQUFJO3dCQUN6QyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO3FCQUNsQixDQUFDLENBQUM7b0JBRUgsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLEVBQUM7d0JBQ3pCLElBQUksSUFBSSxDQUFDLElBQUksWUFBWUMsaUJBQVEsRUFBRTs0QkFDbEMsTUFBTSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQ3RCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzt5QkFDZDtxQkFDRDtpQkFDRCxDQUFBLENBQUE7Z0JBRUQsTUFBTSxZQUFZLEdBQUc7b0JBQ3BCLE1BQU0sV0FBVyxFQUFFLENBQUM7b0JBQ3BCQyxhQUEwQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7aUJBQ2hFLENBQUEsQ0FBQTs7Z0JBR0QsSUFBSSxLQUFLLEdBQUdDLGFBQTBCLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ2xELFlBQVksRUFBRSxDQUFDO2dCQUVmLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNiO1NBQ0QsQ0FBQTs7UUFHRCxZQUFZLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDOztRQUdsRCxNQUFNLFlBQVksR0FBRyxVQUFTLEVBQUUsRUFBRSxLQUFLO1lBQ3RDLElBQ0MsQ0FBRSxFQUFFLENBQUMsSUFBSSxLQUFLLE9BQU8sSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLGFBQWE7bUJBQy9DLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQzttQkFDaEIsWUFBWSxDQUFDLFFBQVEsS0FBSyxLQUFLLEVBQ2xDO2dCQUNBLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDcEIsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ3JCO1NBQ0QsQ0FBQTtRQUNELFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsVUFBUyxFQUFFLElBQUcsWUFBWSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUEsRUFBRSxDQUFDLENBQUM7UUFDMUYsV0FBVyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxVQUFTLEVBQUUsSUFBRyxZQUFZLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQSxFQUFFLENBQUMsQ0FBQztLQUU1RjtJQUVELE9BQU87UUFDTixJQUFJLEVBQUUsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNsQjs7Ozs7In0=
