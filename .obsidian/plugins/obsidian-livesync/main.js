/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/diff-match-patch/index.js
var require_diff_match_patch = __commonJS({
  "node_modules/diff-match-patch/index.js"(exports, module2) {
    var diff_match_patch3 = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = 0.5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = 0.5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    };
    var DIFF_DELETE3 = -1;
    var DIFF_INSERT3 = 1;
    var DIFF_EQUAL3 = 0;
    diff_match_patch3.Diff = function(op, text2) {
      return [op, text2];
    };
    diff_match_patch3.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
      if (typeof opt_deadline == "undefined") {
        if (this.Diff_Timeout <= 0) {
          opt_deadline = Number.MAX_VALUE;
        } else {
          opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
        }
      }
      var deadline = opt_deadline;
      if (text1 == null || text2 == null) {
        throw new Error("Null input. (diff_main)");
      }
      if (text1 == text2) {
        if (text1) {
          return [new diff_match_patch3.Diff(DIFF_EQUAL3, text1)];
        }
        return [];
      }
      if (typeof opt_checklines == "undefined") {
        opt_checklines = true;
      }
      var checklines = opt_checklines;
      var commonlength = this.diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = this.diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = this.diff_compute_(text1, text2, checklines, deadline);
      if (commonprefix) {
        diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL3, commonprefix));
      }
      if (commonsuffix) {
        diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, commonsuffix));
      }
      this.diff_cleanupMerge(diffs);
      return diffs;
    };
    diff_match_patch3.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
      var diffs;
      if (!text1) {
        return [new diff_match_patch3.Diff(DIFF_INSERT3, text2)];
      }
      if (!text2) {
        return [new diff_match_patch3.Diff(DIFF_DELETE3, text1)];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i2 = longtext.indexOf(shorttext);
      if (i2 != -1) {
        diffs = [
          new diff_match_patch3.Diff(DIFF_INSERT3, longtext.substring(0, i2)),
          new diff_match_patch3.Diff(DIFF_EQUAL3, shorttext),
          new diff_match_patch3.Diff(DIFF_INSERT3, longtext.substring(i2 + shorttext.length))
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE3;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [
          new diff_match_patch3.Diff(DIFF_DELETE3, text1),
          new diff_match_patch3.Diff(DIFF_INSERT3, text2)
        ];
      }
      var hm = this.diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        return diffs_a.concat([new diff_match_patch3.Diff(DIFF_EQUAL3, mid_common)], diffs_b);
      }
      if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
      }
      return this.diff_bisect_(text1, text2, deadline);
    };
    diff_match_patch3.prototype.diff_lineMode_ = function(text1, text2, deadline) {
      var a = this.diff_linesToChars_(text1, text2);
      text1 = a.chars1;
      text2 = a.chars2;
      var linearray = a.lineArray;
      var diffs = this.diff_main(text1, text2, false, deadline);
      this.diff_charsToLines_(diffs, linearray);
      this.diff_cleanupSemantic(diffs);
      diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT3:
            count_insert++;
            text_insert += diffs[pointer][1];
            break;
          case DIFF_DELETE3:
            count_delete++;
            text_delete += diffs[pointer][1];
            break;
          case DIFF_EQUAL3:
            if (count_delete >= 1 && count_insert >= 1) {
              diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
              pointer = pointer - count_delete - count_insert;
              var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
              for (var j = subDiff.length - 1; j >= 0; j--) {
                diffs.splice(pointer, 0, subDiff[j]);
              }
              pointer = pointer + subDiff.length;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
        pointer++;
      }
      diffs.pop();
      return diffs;
    };
    diff_match_patch3.prototype.diff_bisect_ = function(text1, text2, deadline) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        if (new Date().getTime() > deadline) {
          break;
        }
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
      }
      return [
        new diff_match_patch3.Diff(DIFF_DELETE3, text1),
        new diff_match_patch3.Diff(DIFF_INSERT3, text2)
      ];
    };
    diff_match_patch3.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = this.diff_main(text1a, text2a, false, deadline);
      var diffsb = this.diff_main(text1b, text2b, false, deadline);
      return diffs.concat(diffsb);
    };
    diff_match_patch3.prototype.diff_linesToChars_ = function(text1, text2) {
      var lineArray = [];
      var lineHash = {};
      lineArray[0] = "";
      function diff_linesToCharsMunge_(text3) {
        var chars = "";
        var lineStart = 0;
        var lineEnd = -1;
        var lineArrayLength = lineArray.length;
        while (lineEnd < text3.length - 1) {
          lineEnd = text3.indexOf("\n", lineStart);
          if (lineEnd == -1) {
            lineEnd = text3.length - 1;
          }
          var line = text3.substring(lineStart, lineEnd + 1);
          if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
            chars += String.fromCharCode(lineHash[line]);
          } else {
            if (lineArrayLength == maxLines) {
              line = text3.substring(lineStart);
              lineEnd = text3.length;
            }
            chars += String.fromCharCode(lineArrayLength);
            lineHash[line] = lineArrayLength;
            lineArray[lineArrayLength++] = line;
          }
          lineStart = lineEnd + 1;
        }
        return chars;
      }
      var maxLines = 4e4;
      var chars1 = diff_linesToCharsMunge_(text1);
      maxLines = 65535;
      var chars2 = diff_linesToCharsMunge_(text2);
      return { chars1, chars2, lineArray };
    };
    diff_match_patch3.prototype.diff_charsToLines_ = function(diffs, lineArray) {
      for (var i2 = 0; i2 < diffs.length; i2++) {
        var chars = diffs[i2][1];
        var text2 = [];
        for (var j = 0; j < chars.length; j++) {
          text2[j] = lineArray[chars.charCodeAt(j)];
        }
        diffs[i2][1] = text2.join("");
      }
    };
    diff_match_patch3.prototype.diff_commonPrefix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch3.prototype.diff_commonSuffix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch3.prototype.diff_commonOverlap_ = function(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    };
    diff_match_patch3.prototype.diff_halfMatch_ = function(text1, text2) {
      if (this.Diff_Timeout <= 0) {
        return null;
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      var dmp = this;
      function diff_halfMatchI_(longtext2, shorttext2, i2) {
        var seed = longtext2.substring(i2, i2 + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = dmp.diff_commonPrefix(longtext2.substring(i2), shorttext2.substring(j));
          var suffixLength = dmp.diff_commonSuffix(longtext2.substring(0, i2), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i2 - suffixLength);
            best_longtext_b = longtext2.substring(i2 + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    };
    diff_match_patch3.prototype.diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL3) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT3) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch3.Diff(DIFF_DELETE3, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT3;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
      this.diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE3 && diffs[pointer][0] == DIFF_INSERT3) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_EQUAL3, insertion.substring(0, overlap_length1)));
              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_EQUAL3, deletion.substring(0, overlap_length2)));
              diffs[pointer - 1][0] = DIFF_INSERT3;
              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
              diffs[pointer + 1][0] = DIFF_DELETE3;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    diff_match_patch3.prototype.diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch3.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch3.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch3.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch3.whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(diff_match_patch3.linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(diff_match_patch3.linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(diff_match_patch3.blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(diff_match_patch3.blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL3 && diffs[pointer + 1][0] == DIFF_EQUAL3) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = this.diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    diff_match_patch3.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch3.whitespaceRegex_ = /\s/;
    diff_match_patch3.linebreakRegex_ = /[\r\n]/;
    diff_match_patch3.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch3.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch3.prototype.diff_cleanupEfficiency = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var pre_ins = false;
      var pre_del = false;
      var post_ins = false;
      var post_del = false;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL3) {
          if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
            equalities[equalitiesLength++] = pointer;
            pre_ins = post_ins;
            pre_del = post_del;
            lastEquality = diffs[pointer][1];
          } else {
            equalitiesLength = 0;
            lastEquality = null;
          }
          post_ins = post_del = false;
        } else {
          if (diffs[pointer][0] == DIFF_DELETE3) {
            post_del = true;
          } else {
            post_ins = true;
          }
          if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch3.Diff(DIFF_DELETE3, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT3;
            equalitiesLength--;
            lastEquality = null;
            if (pre_ins && pre_del) {
              post_ins = post_del = true;
              equalitiesLength = 0;
            } else {
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              post_ins = post_del = false;
            }
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch3.prototype.diff_cleanupMerge = function(diffs) {
      diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT3:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE3:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL3:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = this.diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL3) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, new diff_match_patch3.Diff(DIFF_EQUAL3, text_insert.substring(0, commonlength)));
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = this.diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_DELETE3, text_delete));
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(pointer, 0, new diff_match_patch3.Diff(DIFF_INSERT3, text_insert));
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL3) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL3 && diffs[pointer + 1][0] == DIFF_EQUAL3) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch3.prototype.diff_xIndex = function(diffs, loc) {
      var chars1 = 0;
      var chars2 = 0;
      var last_chars1 = 0;
      var last_chars2 = 0;
      var x;
      for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT3) {
          chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE3) {
          chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {
          break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
      }
      if (diffs.length != x && diffs[x][0] === DIFF_DELETE3) {
        return last_chars2;
      }
      return last_chars2 + (loc - last_chars1);
    };
    diff_match_patch3.prototype.diff_prettyHtml = function(diffs) {
      var html = [];
      var pattern_amp = /&/g;
      var pattern_lt = /</g;
      var pattern_gt = />/g;
      var pattern_para = /\n/g;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        var text2 = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
        switch (op) {
          case DIFF_INSERT3:
            html[x] = '<ins style="background:#e6ffe6;">' + text2 + "</ins>";
            break;
          case DIFF_DELETE3:
            html[x] = '<del style="background:#ffe6e6;">' + text2 + "</del>";
            break;
          case DIFF_EQUAL3:
            html[x] = "<span>" + text2 + "</span>";
            break;
        }
      }
      return html.join("");
    };
    diff_match_patch3.prototype.diff_text1 = function(diffs) {
      var text2 = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT3) {
          text2[x] = diffs[x][1];
        }
      }
      return text2.join("");
    };
    diff_match_patch3.prototype.diff_text2 = function(diffs) {
      var text2 = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE3) {
          text2[x] = diffs[x][1];
        }
      }
      return text2.join("");
    };
    diff_match_patch3.prototype.diff_levenshtein = function(diffs) {
      var levenshtein = 0;
      var insertions = 0;
      var deletions = 0;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
          case DIFF_INSERT3:
            insertions += data.length;
            break;
          case DIFF_DELETE3:
            deletions += data.length;
            break;
          case DIFF_EQUAL3:
            levenshtein += Math.max(insertions, deletions);
            insertions = 0;
            deletions = 0;
            break;
        }
      }
      levenshtein += Math.max(insertions, deletions);
      return levenshtein;
    };
    diff_match_patch3.prototype.diff_toDelta = function(diffs) {
      var text2 = [];
      for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
          case DIFF_INSERT3:
            text2[x] = "+" + encodeURI(diffs[x][1]);
            break;
          case DIFF_DELETE3:
            text2[x] = "-" + diffs[x][1].length;
            break;
          case DIFF_EQUAL3:
            text2[x] = "=" + diffs[x][1].length;
            break;
        }
      }
      return text2.join("	").replace(/%20/g, " ");
    };
    diff_match_patch3.prototype.diff_fromDelta = function(text1, delta) {
      var diffs = [];
      var diffsLength = 0;
      var pointer = 0;
      var tokens = delta.split(/\t/g);
      for (var x = 0; x < tokens.length; x++) {
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
          case "+":
            try {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_INSERT3, decodeURI(param));
            } catch (ex) {
              throw new Error("Illegal escape in diff_fromDelta: " + param);
            }
            break;
          case "-":
          case "=":
            var n3 = parseInt(param, 10);
            if (isNaN(n3) || n3 < 0) {
              throw new Error("Invalid number in diff_fromDelta: " + param);
            }
            var text2 = text1.substring(pointer, pointer += n3);
            if (tokens[x].charAt(0) == "=") {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_EQUAL3, text2);
            } else {
              diffs[diffsLength++] = new diff_match_patch3.Diff(DIFF_DELETE3, text2);
            }
            break;
          default:
            if (tokens[x]) {
              throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
            }
        }
      }
      if (pointer != text1.length) {
        throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
      }
      return diffs;
    };
    diff_match_patch3.prototype.match_main = function(text2, pattern, loc) {
      if (text2 == null || pattern == null || loc == null) {
        throw new Error("Null input. (match_main)");
      }
      loc = Math.max(0, Math.min(loc, text2.length));
      if (text2 == pattern) {
        return 0;
      } else if (!text2.length) {
        return -1;
      } else if (text2.substring(loc, loc + pattern.length) == pattern) {
        return loc;
      } else {
        return this.match_bitap_(text2, pattern, loc);
      }
    };
    diff_match_patch3.prototype.match_bitap_ = function(text2, pattern, loc) {
      if (pattern.length > this.Match_MaxBits) {
        throw new Error("Pattern too long for this browser.");
      }
      var s = this.match_alphabet_(pattern);
      var dmp = this;
      function match_bitapScore_(e3, x) {
        var accuracy = e3 / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
          return proximity ? 1 : accuracy;
        }
        return accuracy + proximity / dmp.Match_Distance;
      }
      var score_threshold = this.Match_Threshold;
      var best_loc = text2.indexOf(pattern, loc);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        best_loc = text2.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
      }
      var matchmask = 1 << pattern.length - 1;
      best_loc = -1;
      var bin_min, bin_mid;
      var bin_max = pattern.length + text2.length;
      var last_rd;
      for (var d = 0; d < pattern.length; d++) {
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
          if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
            bin_min = bin_mid;
          } else {
            bin_max = bin_mid;
          }
          bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text2.length) + pattern.length;
        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
          var charMatch = s[text2.charAt(j - 1)];
          if (d === 0) {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
          } else {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
          }
          if (rd[j] & matchmask) {
            var score = match_bitapScore_(d, j - 1);
            if (score <= score_threshold) {
              score_threshold = score;
              best_loc = j - 1;
              if (best_loc > loc) {
                start = Math.max(1, 2 * loc - best_loc);
              } else {
                break;
              }
            }
          }
        }
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
          break;
        }
        last_rd = rd;
      }
      return best_loc;
    };
    diff_match_patch3.prototype.match_alphabet_ = function(pattern) {
      var s = {};
      for (var i2 = 0; i2 < pattern.length; i2++) {
        s[pattern.charAt(i2)] = 0;
      }
      for (var i2 = 0; i2 < pattern.length; i2++) {
        s[pattern.charAt(i2)] |= 1 << pattern.length - i2 - 1;
      }
      return s;
    };
    diff_match_patch3.prototype.patch_addContext_ = function(patch, text2) {
      if (text2.length == 0) {
        return;
      }
      if (patch.start2 === null) {
        throw Error("patch not initialized");
      }
      var pattern = text2.substring(patch.start2, patch.start2 + patch.length1);
      var padding = 0;
      while (text2.indexOf(pattern) != text2.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text2.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
      }
      padding += this.Patch_Margin;
      var prefix = text2.substring(patch.start2 - padding, patch.start2);
      if (prefix) {
        patch.diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL3, prefix));
      }
      var suffix = text2.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
      if (suffix) {
        patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, suffix));
      }
      patch.start1 -= prefix.length;
      patch.start2 -= prefix.length;
      patch.length1 += prefix.length + suffix.length;
      patch.length2 += prefix.length + suffix.length;
    };
    diff_match_patch3.prototype.patch_make = function(a, opt_b, opt_c) {
      var text1, diffs;
      if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = this.diff_main(text1, opt_b, true);
        if (diffs.length > 2) {
          this.diff_cleanupSemantic(diffs);
          this.diff_cleanupEfficiency(diffs);
        }
      } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
        diffs = a;
        text1 = this.diff_text1(diffs);
      } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = opt_b;
      } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
        text1 = a;
        diffs = opt_c;
      } else {
        throw new Error("Unknown call format to patch_make.");
      }
      if (diffs.length === 0) {
        return [];
      }
      var patches = [];
      var patch = new diff_match_patch3.patch_obj();
      var patchDiffLength = 0;
      var char_count1 = 0;
      var char_count2 = 0;
      var prepatch_text = text1;
      var postpatch_text = text1;
      for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];
        if (!patchDiffLength && diff_type !== DIFF_EQUAL3) {
          patch.start1 = char_count1;
          patch.start2 = char_count2;
        }
        switch (diff_type) {
          case DIFF_INSERT3:
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length2 += diff_text.length;
            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
            break;
          case DIFF_DELETE3:
            patch.length1 += diff_text.length;
            patch.diffs[patchDiffLength++] = diffs[x];
            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
            break;
          case DIFF_EQUAL3:
            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
              patch.diffs[patchDiffLength++] = diffs[x];
              patch.length1 += diff_text.length;
              patch.length2 += diff_text.length;
            } else if (diff_text.length >= 2 * this.Patch_Margin) {
              if (patchDiffLength) {
                this.patch_addContext_(patch, prepatch_text);
                patches.push(patch);
                patch = new diff_match_patch3.patch_obj();
                patchDiffLength = 0;
                prepatch_text = postpatch_text;
                char_count1 = char_count2;
              }
            }
            break;
        }
        if (diff_type !== DIFF_INSERT3) {
          char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE3) {
          char_count2 += diff_text.length;
        }
      }
      if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
      }
      return patches;
    };
    diff_match_patch3.prototype.patch_deepCopy = function(patches) {
      var patchesCopy = [];
      for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch3.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
          patchCopy.diffs[y] = new diff_match_patch3.Diff(patch.diffs[y][0], patch.diffs[y][1]);
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
      }
      return patchesCopy;
    };
    diff_match_patch3.prototype.patch_apply = function(patches, text2) {
      if (patches.length == 0) {
        return [text2, []];
      }
      patches = this.patch_deepCopy(patches);
      var nullPadding = this.patch_addPadding(patches);
      text2 = nullPadding + text2 + nullPadding;
      this.patch_splitMax(patches);
      var delta = 0;
      var results = [];
      for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
          start_loc = this.match_main(text2, text1.substring(0, this.Match_MaxBits), expected_loc);
          if (start_loc != -1) {
            end_loc = this.match_main(text2, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
            if (end_loc == -1 || start_loc >= end_loc) {
              start_loc = -1;
            }
          }
        } else {
          start_loc = this.match_main(text2, text1, expected_loc);
        }
        if (start_loc == -1) {
          results[x] = false;
          delta -= patches[x].length2 - patches[x].length1;
        } else {
          results[x] = true;
          delta = start_loc - expected_loc;
          var text22;
          if (end_loc == -1) {
            text22 = text2.substring(start_loc, start_loc + text1.length);
          } else {
            text22 = text2.substring(start_loc, end_loc + this.Match_MaxBits);
          }
          if (text1 == text22) {
            text2 = text2.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text2.substring(start_loc + text1.length);
          } else {
            var diffs = this.diff_main(text1, text22, false);
            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
              results[x] = false;
            } else {
              this.diff_cleanupSemanticLossless(diffs);
              var index1 = 0;
              var index2;
              for (var y = 0; y < patches[x].diffs.length; y++) {
                var mod = patches[x].diffs[y];
                if (mod[0] !== DIFF_EQUAL3) {
                  index2 = this.diff_xIndex(diffs, index1);
                }
                if (mod[0] === DIFF_INSERT3) {
                  text2 = text2.substring(0, start_loc + index2) + mod[1] + text2.substring(start_loc + index2);
                } else if (mod[0] === DIFF_DELETE3) {
                  text2 = text2.substring(0, start_loc + index2) + text2.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));
                }
                if (mod[0] !== DIFF_DELETE3) {
                  index1 += mod[1].length;
                }
              }
            }
          }
        }
      }
      text2 = text2.substring(nullPadding.length, text2.length - nullPadding.length);
      return [text2, results];
    };
    diff_match_patch3.prototype.patch_addPadding = function(patches) {
      var paddingLength = this.Patch_Margin;
      var nullPadding = "";
      for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
      }
      for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
      }
      var patch = patches[0];
      var diffs = patch.diffs;
      if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL3) {
        diffs.unshift(new diff_match_patch3.Diff(DIFF_EQUAL3, nullPadding));
        patch.start1 -= paddingLength;
        patch.start2 -= paddingLength;
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[0][1].length) {
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      patch = patches[patches.length - 1];
      diffs = patch.diffs;
      if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL3) {
        diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, nullPadding));
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      return nullPadding;
    };
    diff_match_patch3.prototype.patch_splitMax = function(patches) {
      var patch_size = this.Match_MaxBits;
      for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
          continue;
        }
        var bigpatch = patches[x];
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = "";
        while (bigpatch.diffs.length !== 0) {
          var patch = new diff_match_patch3.patch_obj();
          var empty2 = true;
          patch.start1 = start1 - precontext.length;
          patch.start2 = start2 - precontext.length;
          if (precontext !== "") {
            patch.length1 = patch.length2 = precontext.length;
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, precontext));
          }
          while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
            var diff_type = bigpatch.diffs[0][0];
            var diff_text = bigpatch.diffs[0][1];
            if (diff_type === DIFF_INSERT3) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
              patch.diffs.push(bigpatch.diffs.shift());
              empty2 = false;
            } else if (diff_type === DIFF_DELETE3 && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL3 && diff_text.length > 2 * patch_size) {
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              empty2 = false;
              patch.diffs.push(new diff_match_patch3.Diff(diff_type, diff_text));
              bigpatch.diffs.shift();
            } else {
              diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              if (diff_type === DIFF_EQUAL3) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
              } else {
                empty2 = false;
              }
              patch.diffs.push(new diff_match_patch3.Diff(diff_type, diff_text));
              if (diff_text == bigpatch.diffs[0][1]) {
                bigpatch.diffs.shift();
              } else {
                bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
              }
            }
          }
          precontext = this.diff_text2(patch.diffs);
          precontext = precontext.substring(precontext.length - this.Patch_Margin);
          var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
          if (postcontext !== "") {
            patch.length1 += postcontext.length;
            patch.length2 += postcontext.length;
            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL3) {
              patch.diffs[patch.diffs.length - 1][1] += postcontext;
            } else {
              patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, postcontext));
            }
          }
          if (!empty2) {
            patches.splice(++x, 0, patch);
          }
        }
      }
    };
    diff_match_patch3.prototype.patch_toText = function(patches) {
      var text2 = [];
      for (var x = 0; x < patches.length; x++) {
        text2[x] = patches[x];
      }
      return text2.join("");
    };
    diff_match_patch3.prototype.patch_fromText = function(textline) {
      var patches = [];
      if (!textline) {
        return patches;
      }
      var text2 = textline.split("\n");
      var textPointer = 0;
      var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
      while (textPointer < text2.length) {
        var m = text2[textPointer].match(patchHeader);
        if (!m) {
          throw new Error("Invalid patch string: " + text2[textPointer]);
        }
        var patch = new diff_match_patch3.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === "") {
          patch.start1--;
          patch.length1 = 1;
        } else if (m[2] == "0") {
          patch.length1 = 0;
        } else {
          patch.start1--;
          patch.length1 = parseInt(m[2], 10);
        }
        patch.start2 = parseInt(m[3], 10);
        if (m[4] === "") {
          patch.start2--;
          patch.length2 = 1;
        } else if (m[4] == "0") {
          patch.length2 = 0;
        } else {
          patch.start2--;
          patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;
        while (textPointer < text2.length) {
          var sign = text2[textPointer].charAt(0);
          try {
            var line = decodeURI(text2[textPointer].substring(1));
          } catch (ex) {
            throw new Error("Illegal escape in patch_fromText: " + line);
          }
          if (sign == "-") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_DELETE3, line));
          } else if (sign == "+") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_INSERT3, line));
          } else if (sign == " ") {
            patch.diffs.push(new diff_match_patch3.Diff(DIFF_EQUAL3, line));
          } else if (sign == "@") {
            break;
          } else if (sign === "") {
          } else {
            throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
          }
          textPointer++;
        }
      }
      return patches;
    };
    diff_match_patch3.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch3.patch_obj.prototype.toString = function() {
      var coords1, coords2;
      if (this.length1 === 0) {
        coords1 = this.start1 + ",0";
      } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
      } else {
        coords1 = this.start1 + 1 + "," + this.length1;
      }
      if (this.length2 === 0) {
        coords2 = this.start2 + ",0";
      } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
      } else {
        coords2 = this.start2 + 1 + "," + this.length2;
      }
      var text2 = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
      var op;
      for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
          case DIFF_INSERT3:
            op = "+";
            break;
          case DIFF_DELETE3:
            op = "-";
            break;
          case DIFF_EQUAL3:
            op = " ";
            break;
        }
        text2[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
      }
      return text2.join("").replace(/%20/g, " ");
    };
    module2.exports = diff_match_patch3;
    module2.exports["diff_match_patch"] = diff_match_patch3;
    module2.exports["DIFF_DELETE"] = DIFF_DELETE3;
    module2.exports["DIFF_INSERT"] = DIFF_INSERT3;
    module2.exports["DIFF_EQUAL"] = DIFF_EQUAL3;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
          s = arguments[i2];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t3[p] = s[p];
        }
        return t3;
      };
      __rest2 = function(s, e3) {
        var t3 = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e3.indexOf(p) < 0)
            t3[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
            if (e3.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
              t3[p[i2]] = s[p[i2]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d = decorators[i2])
              r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
        return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e3) {
              reject(e3);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e3) {
              reject(e3);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f, y, t3, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n3) {
          return function(v) {
            return step([n3, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t3 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t3 = y["return"]) && t3.call(y), 0) : y.next) && !(t3 = t3.call(y, op[1])).done)
                return t3;
              if (y = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t3 = _.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t3[1]) {
                    _.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _.label < t3[2]) {
                    _.label = t3[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e3) {
              op = [6, e3];
              y = 0;
            } finally {
              f = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n3) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i2 = m.call(o), r2, ar = [], e3;
        try {
          while ((n3 === void 0 || n3-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error) {
          e3 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m = i2["return"]))
              m.call(i2);
          } finally {
            if (e3)
              throw e3.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read2(arguments[i2]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s += arguments[i2].length;
        for (var r2 = Array(s), k = 0, i2 = 0; i2 < il; i2++)
          for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n3) {
          if (g[n3])
            i2[n3] = function(v) {
              return new Promise(function(a, b) {
                q.push([n3, v, a, b]) > 1 || resume(n3, v);
              });
            };
        }
        function resume(n3, v) {
          try {
            step(g[n3](v));
          } catch (e3) {
            settle(q[0][3], e3);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e3) {
          throw e3;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n3, f) {
          i2[n3] = o[n3] ? function(v) {
            return (p = !p) ? { value: __await2(o[n3](v)), done: n3 === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i2;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n3) {
          i2[n3] = o[n3] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n3](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => ObsidianLiveSyncPlugin
});
var import_obsidian7 = __toModule(require("obsidian"));
var import_diff_match_patch3 = __toModule(require_diff_match_patch());

// src/lib/src/types.ts
var MAX_DOC_SIZE = 1e3;
var MAX_DOC_SIZE_BIN = 102400;
var VER = 10;
var LEAF_WAIT_TIMEOUT = 9e4;
var LOG_LEVEL = {
  DEBUG: -1,
  VERBOSE: 1,
  INFO: 10,
  NOTICE: 100,
  URGENT: 1e3
};
var VERSIONINFO_DOCID = "obsydian_livesync_version";
var MILSTONE_DOCID = "_local/obsydian_livesync_milestone";
var NODEINFO_DOCID = "_local/obsydian_livesync_nodeinfo";
var DEFAULT_SETTINGS = {
  couchDB_URI: "",
  couchDB_USER: "",
  couchDB_PASSWORD: "",
  couchDB_DBNAME: "",
  liveSync: false,
  syncOnSave: false,
  syncOnStart: false,
  savingDelay: 200,
  lessInformationInLog: false,
  gcDelay: 300,
  versionUpFlash: "",
  minimumChunkSize: 20,
  longLineThreshold: 250,
  showVerboseLog: false,
  suspendFileWatching: false,
  trashInsteadDelete: true,
  periodicReplication: false,
  periodicReplicationInterval: 60,
  syncOnFileOpen: false,
  encrypt: false,
  passphrase: "",
  workingEncrypt: false,
  workingPassphrase: "",
  doNotDeleteFolder: false,
  resolveConflictsByNewerFile: false,
  batchSave: false,
  deviceAndVaultName: "",
  usePluginSettings: false,
  showOwnPlugins: false,
  showStatusOnEditor: false,
  usePluginSync: false,
  autoSweepPlugins: false,
  autoSweepPluginsPeriodic: false,
  notifyPluginOrSettingUpdated: false,
  checkIntegrityOnSave: false,
  batch_size: 250,
  batches_limit: 40,
  useHistory: false,
  disableRequestURI: false,
  skipOlderFilesOnSync: true,
  checkConflictOnlyOnOpen: true
};
var FLAGMD_REDFLAG = "redflag.md";
var SYNCINFO_ID = "syncinfo";

// src/types.ts
var PERIODIC_PLUGIN_SWEEP = 60;

// src/lib/src/logger.ts
var Logger = (message, _) => __async(void 0, null, function* () {
  const timestamp = new Date().toLocaleString();
  const messagecontent = typeof message == "string" ? message : message instanceof Error ? `${message.name}:${message.message}` : JSON.stringify(message, null, 2);
  const newmessage = timestamp + "->" + messagecontent;
  console.log(newmessage);
});
function setLogger(loggerFun) {
  Logger = loggerFun;
}

// src/lib/src/e2ee.ts
var import_crypto = __toModule(require("crypto"));
var webcrypto;
if (typeof window !== "undefined" && window.crypto) {
  webcrypto = window.crypto;
} else {
  const crypto2 = import_crypto.webcrypto;
  webcrypto = crypto2;
}
var KeyBuffs = [];
var decKeyBuffs = [];
var KEY_RECYCLE_COUNT = 100;
var recycleCount = KEY_RECYCLE_COUNT;
var semiStaticFieldBuffer;
var nonceBuffer = new Uint32Array(1);
function getKeyForEncrypt(passphrase) {
  return __async(this, null, function* () {
    const f = KeyBuffs.find((e3) => e3.index == passphrase);
    if (f) {
      recycleCount--;
      if (recycleCount > 0) {
        return [f.key, f.salt];
      }
      KeyBuffs = KeyBuffs.filter((e3) => e3 != f);
      recycleCount = KEY_RECYCLE_COUNT;
    }
    const xpassphrase = new TextEncoder().encode(passphrase);
    const digest = yield webcrypto.subtle.digest({ name: "SHA-256" }, xpassphrase);
    const keyMaterial = yield webcrypto.subtle.importKey("raw", digest, { name: "PBKDF2" }, false, ["deriveKey"]);
    const salt = webcrypto.getRandomValues(new Uint8Array(16));
    const key = yield webcrypto.subtle.deriveKey({
      name: "PBKDF2",
      salt,
      iterations: 1e5,
      hash: "SHA-256"
    }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt"]);
    KeyBuffs.push({
      index: passphrase,
      key,
      salt
    });
    while (KeyBuffs.length > 50) {
      KeyBuffs.shift();
    }
    return [key, salt];
  });
}
function getKeyForDecryption(passphrase, salt) {
  return __async(this, null, function* () {
    const bufKey = passphrase + uint8ArrayToHexString(salt);
    const f = decKeyBuffs.find((e3) => e3.index == bufKey);
    if (f) {
      return [f.key, f.salt];
    }
    const xpassphrase = new TextEncoder().encode(passphrase);
    const digest = yield webcrypto.subtle.digest({ name: "SHA-256" }, xpassphrase);
    const keyMaterial = yield webcrypto.subtle.importKey("raw", digest, { name: "PBKDF2" }, false, ["deriveKey"]);
    const key = yield webcrypto.subtle.deriveKey({
      name: "PBKDF2",
      salt,
      iterations: 1e5,
      hash: "SHA-256"
    }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["decrypt"]);
    decKeyBuffs.push({
      index: bufKey,
      key,
      salt
    });
    decKeyBuffs = decKeyBuffs.filter((e3) => e3 != f);
    while (decKeyBuffs.length > 50) {
      decKeyBuffs.shift();
    }
    return [key, salt];
  });
}
function getSemiStaticField(reset) {
  if (semiStaticFieldBuffer != null && !reset) {
    return semiStaticFieldBuffer;
  }
  semiStaticFieldBuffer = webcrypto.getRandomValues(new Uint8Array(12));
  return semiStaticFieldBuffer;
}
function getNonce() {
  nonceBuffer[0]++;
  if (nonceBuffer[0] > 1e4) {
    getSemiStaticField(true);
  }
  return nonceBuffer;
}
function uint8ArrayToHexString(src) {
  return Array.from(src).map((e3) => `00${e3.toString(16)}`.slice(-2)).join("");
}
function hexStringToUint8Array(src) {
  const srcArr = [...src];
  const arr = srcArr.reduce((acc, _, i2) => i2 % 2 ? acc : [...acc, srcArr.slice(i2, i2 + 2).join("")], []).map((e3) => parseInt(e3, 16));
  return Uint8Array.from(arr);
}
function btoa_node(src) {
  return Buffer.from(src, "binary").toString("base64");
}
function atob_node(src) {
  return Buffer.from(src, "base64").toString("binary");
}
var btoa2 = typeof window !== "undefined" ? window.btoa : btoa_node;
var atob2 = typeof window !== "undefined" ? window.atob : atob_node;
function encrypt(input, passphrase) {
  return __async(this, null, function* () {
    const [key, salt] = yield getKeyForEncrypt(passphrase);
    const fixedPart = getSemiStaticField();
    const invocationPart = getNonce();
    const iv = Uint8Array.from([...fixedPart, ...new Uint8Array(invocationPart.buffer)]);
    const plainStringified = JSON.stringify(input);
    const plainStringBuffer = new TextEncoder().encode(plainStringified);
    const encryptedDataArrayBuffer = yield webcrypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plainStringBuffer);
    const encryptedData = btoa2(Array.from(new Uint8Array(encryptedDataArrayBuffer), (char) => String.fromCharCode(char)).join(""));
    const response = [encryptedData, uint8ArrayToHexString(iv), uint8ArrayToHexString(salt)];
    const ret = JSON.stringify(response);
    return ret;
  });
}
function decrypt(encryptedResult, passphrase) {
  return __async(this, null, function* () {
    try {
      const [encryptedData, ivString, salt] = JSON.parse(encryptedResult);
      const [key] = yield getKeyForDecryption(passphrase, hexStringToUint8Array(salt));
      const iv = hexStringToUint8Array(ivString);
      const encryptedDataBin = atob2(encryptedData);
      const encryptedDataArrayBuffer = Uint8Array.from(encryptedDataBin.split(""), (char) => char.charCodeAt(0));
      const plainStringBuffer = yield webcrypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encryptedDataArrayBuffer);
      const plainStringified = new TextDecoder().decode(plainStringBuffer);
      const plain = JSON.parse(plainStringified);
      return plain;
    } catch (ex) {
      Logger("Couldn't decode! You should wrong the passphrases", LOG_LEVEL.VERBOSE);
      Logger(ex, LOG_LEVEL.VERBOSE);
      throw ex;
    }
  });
}
function testCrypt() {
  return __async(this, null, function* () {
    const src = "supercalifragilisticexpialidocious";
    const encoded = yield encrypt(src, "passwordTest");
    const decrypted = yield decrypt(encoded, "passwordTest");
    if (src != decrypted) {
      Logger("WARNING! Your device would not support encryption.", LOG_LEVEL.VERBOSE);
      return false;
    } else {
      Logger("CRYPT LOGIC OK", LOG_LEVEL.VERBOSE);
      return true;
    }
  });
}

// src/lib/src/utils.ts
function arrayBufferToBase64(buffer) {
  return new Promise((res) => {
    const blob = new Blob([buffer], { type: "application/octet-binary" });
    const reader = new FileReader();
    reader.onload = function(evt) {
      const dataurl = evt.target.result.toString();
      res(dataurl.substr(dataurl.indexOf(",") + 1));
    };
    reader.readAsDataURL(blob);
  });
}
function base64ToString(base64) {
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      bytes[i2] = binary_string.charCodeAt(i2);
    }
    return new TextDecoder().decode(bytes);
  } catch (ex) {
    return base64;
  }
}
function base64ToArrayBuffer(base64) {
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      bytes[i2] = binary_string.charCodeAt(i2);
    }
    return bytes.buffer;
  } catch (ex) {
    try {
      return new Uint16Array([].map.call(base64, function(c) {
        return c.charCodeAt(0);
      })).buffer;
    } catch (ex2) {
      return null;
    }
  }
}
var escapeStringToHTML = (str) => {
  if (!str)
    return "";
  return str.replace(/[<>&"'`]/g, (match) => {
    const escape = {
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#x60;"
    };
    return escape[match];
  });
};
function resolveWithIgnoreKnownError(p, def) {
  return new Promise((res, rej) => {
    p.then(res).catch((ex) => ex.status && ex.status == 404 ? res(def) : rej(ex));
  });
}
function isValidPath(filename) {
  const regex = /[\u0000-\u001f]|[\\":?<>|*#]/g;
  let x = filename.replace(regex, "_");
  const win = /(\\|\/)(COM\d|LPT\d|CON|PRN|AUX|NUL|CLOCK$)($|\.)/gi;
  const sx = x = x.replace(win, "/_");
  return sx == filename;
}
function shouldBeIgnored(filename) {
  if (filename == FLAGMD_REDFLAG) {
    return true;
  }
  return false;
}
function versionNumberString2Number(version) {
  return version.split(".").reverse().map((e3, i2) => e3 / 1 * __pow(1e3, i2)).reduce((prev, current) => prev + current, 0);
}
var delay = (ms) => {
  return new Promise((res) => {
    setTimeout(() => {
      res();
    }, ms);
  });
};
function path2id_base(filename) {
  let x = filename;
  if (x.startsWith("_"))
    x = "/" + x;
  return x;
}
function id2path_base(filename) {
  return filename;
}
var externalNotifier = () => {
};
var notifyTimer = null;
function setLockNotifier(fn) {
  externalNotifier = fn;
}
function notifyLock() {
  if (notifyTimer != null) {
    clearTimeout(notifyTimer);
  }
  notifyTimer = setTimeout(() => {
    externalNotifier();
  }, 100);
}
function splitPieces2(data, pieceSize, plainSplit, minimumChunkSize, longLineThreshold) {
  return function* pieces() {
    if (plainSplit) {
      const leftData = data.split("\n");
      let buffer = "";
      let leftLen = 0;
      do {
        buffer += leftData.shift();
        leftLen = leftData.length;
        if (leftLen > 0)
          buffer += "\n";
        if (buffer.length >= minimumChunkSize || leftData.length == 0 || leftData[0] == "#" || buffer[0] == "#") {
          do {
            yield buffer.substring(0, pieceSize);
            buffer = buffer.substring(pieceSize);
          } while (buffer != "");
        }
      } while (leftLen > 0);
    } else {
      let leftData = data;
      do {
        const piece = leftData.substring(0, pieceSize);
        leftData = leftData.substring(pieceSize);
        yield piece;
      } while (leftData != "");
    }
  };
}
var LOCK_WAITING = 0;
var LOCK_RUNNING = 1;
var LOCK_DONE = 2;
var locks = [];
function getLocks() {
  return {
    pending: locks.filter((e3) => e3.status == LOCK_WAITING).map((e3) => e3.key),
    running: locks.filter((e3) => e3.status == LOCK_RUNNING).map((e3) => e3.key)
  };
}
function getProcessingCounts() {
  return locks.length;
}
function lockRunner(key) {
  return __async(this, null, function* () {
    let procs = locks.filter((e3) => e3.key == key && e3.status == LOCK_WAITING);
    while (procs.length != 0) {
      const w = procs.shift();
      if (!w)
        break;
      w.status = LOCK_RUNNING;
      notifyLock();
      try {
        yield w.proc();
      } catch (ex) {
        Logger(`Lock:${key}:rejected `, LOG_LEVEL.VERBOSE);
        Logger(ex, LOG_LEVEL.VERBOSE);
      } finally {
        w.status = LOCK_DONE;
        notifyLock();
      }
      procs = locks.filter((e3) => e3.key == key && e3.status == LOCK_WAITING);
    }
    locks = locks.filter((e3) => e3.status != LOCK_DONE);
  });
}
var nextProc = (key) => {
  if (!locks.some((e3) => e3.key == key && (e3.status == LOCK_RUNNING || e3.status == LOCK_DONE))) {
    lockRunner(key);
  }
};
function runWithLock(key, ignoreWhenRunning, proc) {
  if (ignoreWhenRunning && locks.some((e3) => e3.key == key && e3.status == LOCK_RUNNING)) {
    return null;
  }
  return new Promise((pres, prej) => {
    const wrappedTask = () => proc().then(pres).catch(prej).finally(() => {
      procObj.status = LOCK_DONE;
      nextProc(key);
    });
    const procObj = { key, proc: wrappedTask, status: LOCK_WAITING };
    locks.push(procObj);
    notifyLock();
    nextProc(key);
  });
}
var WrappedNotice = class {
  constructor(message, timeout) {
    let strMessage = "";
    if (message instanceof DocumentFragment) {
      strMessage = message.textContent;
    } else {
      strMessage = message;
    }
    Logger(strMessage, LOG_LEVEL.NOTICE);
  }
  setMessage(message) {
    let strMessage = "";
    if (message instanceof DocumentFragment) {
      strMessage = message.textContent;
    } else {
      strMessage = message;
    }
    Logger(strMessage, LOG_LEVEL.NOTICE);
    return this;
  }
  hide() {
  }
};
var _notice = WrappedNotice;
function setNoticeClass(notice) {
  _notice = notice;
}
function NewNotice(message, timeout) {
  return new _notice(message, timeout);
}
function isPlainText(filename) {
  if (filename.endsWith(".md"))
    return true;
  if (filename.endsWith(".txt"))
    return true;
  if (filename.endsWith(".svg"))
    return true;
  if (filename.endsWith(".html"))
    return true;
  if (filename.endsWith(".csv"))
    return true;
  if (filename.endsWith(".css"))
    return true;
  if (filename.endsWith(".js"))
    return true;
  if (filename.endsWith(".xml"))
    return true;
  return false;
}
function shouldSplitAsPlainText(filename) {
  if (filename.endsWith(".md"))
    return true;
  if (filename.endsWith(".txt"))
    return true;
}
var Parallels = (ps = new Set()) => ({
  add: (p) => ps.add(!!p.then(() => ps.delete(p)).catch(() => ps.delete(p)) && p),
  wait: (limit) => ps.size >= limit && Promise.race(ps),
  all: () => Promise.all(ps)
});
function allSettledWithConcurrencyLimit(procs, limit) {
  return __async(this, null, function* () {
    const ps = Parallels();
    for (const proc of procs) {
      ps.add(proc);
      yield ps.wait(limit);
    }
    (yield ps.all()).forEach(() => {
    });
  });
}
var enableEncryption = (db, passphrase, migrationDecrypt) => {
  const decrypted = new Map();
  db.transform({
    incoming: (doc) => __async(void 0, null, function* () {
      const saveDoc = __spreadValues({}, doc);
      if (saveDoc._id.startsWith("h:+") || saveDoc._id == SYNCINFO_ID) {
        try {
          saveDoc.data = yield encrypt(saveDoc.data, passphrase);
        } catch (ex) {
          Logger("Encryption failed.", LOG_LEVEL.NOTICE);
          Logger(ex);
          throw ex;
        }
      }
      return saveDoc;
    }),
    outgoing: (doc) => __async(void 0, null, function* () {
      const loadDoc = __spreadValues({}, doc);
      if (loadDoc._id.startsWith("h:+") || loadDoc._id == SYNCINFO_ID) {
        if (migrationDecrypt && decrypted.has(loadDoc._id)) {
          return loadDoc;
        }
        try {
          loadDoc.data = yield decrypt(loadDoc.data, passphrase);
          if (migrationDecrypt) {
            decrypted.set(loadDoc._id, true);
          }
        } catch (ex) {
          if (migrationDecrypt && ex.name == "SyntaxError") {
            return loadDoc;
          }
          Logger("Decryption failed.", LOG_LEVEL.NOTICE);
          Logger(ex);
          throw ex;
        }
      }
      return loadDoc;
    })
  });
};

// pouchdb-browser-webpack/dist/pouchdb-browser.js
var e = { 105: (e3) => {
  e3.exports = function(e4) {
    return function() {
      var t3 = arguments.length;
      if (t3) {
        for (var n3 = [], r2 = -1; ++r2 < t3; )
          n3[r2] = arguments[r2];
        return e4.call(this, n3);
      }
      return e4.call(this, []);
    };
  };
}, 187: (e3) => {
  var t3, n3 = typeof Reflect == "object" ? Reflect : null, r2 = n3 && typeof n3.apply == "function" ? n3.apply : function(e4, t4, n4) {
    return Function.prototype.apply.call(e4, t4, n4);
  };
  t3 = n3 && typeof n3.ownKeys == "function" ? n3.ownKeys : Object.getOwnPropertySymbols ? function(e4) {
    return Object.getOwnPropertyNames(e4).concat(Object.getOwnPropertySymbols(e4));
  } : function(e4) {
    return Object.getOwnPropertyNames(e4);
  };
  var i2 = Number.isNaN || function(e4) {
    return e4 != e4;
  };
  function o() {
    o.init.call(this);
  }
  e3.exports = o, e3.exports.once = function(e4, t4) {
    return new Promise(function(n4, r3) {
      function i3(n5) {
        e4.removeListener(t4, o2), r3(n5);
      }
      function o2() {
        typeof e4.removeListener == "function" && e4.removeListener("error", i3), n4([].slice.call(arguments));
      }
      v(e4, t4, o2, { once: true }), t4 !== "error" && function(e5, t5, n5) {
        typeof e5.on == "function" && v(e5, "error", t5, { once: true });
      }(e4, i3);
    });
  }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
  var s = 10;
  function a(e4) {
    if (typeof e4 != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e4);
  }
  function u(e4) {
    return e4._maxListeners === void 0 ? o.defaultMaxListeners : e4._maxListeners;
  }
  function c(e4, t4, n4, r3) {
    var i3, o2, s2, c2;
    if (a(n4), (o2 = e4._events) === void 0 ? (o2 = e4._events = Object.create(null), e4._eventsCount = 0) : (o2.newListener !== void 0 && (e4.emit("newListener", t4, n4.listener ? n4.listener : n4), o2 = e4._events), s2 = o2[t4]), s2 === void 0)
      s2 = o2[t4] = n4, ++e4._eventsCount;
    else if (typeof s2 == "function" ? s2 = o2[t4] = r3 ? [n4, s2] : [s2, n4] : r3 ? s2.unshift(n4) : s2.push(n4), (i3 = u(e4)) > 0 && s2.length > i3 && !s2.warned) {
      s2.warned = true;
      var f2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t4) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      f2.name = "MaxListenersExceededWarning", f2.emitter = e4, f2.type = t4, f2.count = s2.length, c2 = f2, console && console.warn && console.warn(c2);
    }
    return e4;
  }
  function f() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e4, t4, n4) {
    var r3 = { fired: false, wrapFn: void 0, target: e4, type: t4, listener: n4 }, i3 = f.bind(r3);
    return i3.listener = n4, r3.wrapFn = i3, i3;
  }
  function d(e4, t4, n4) {
    var r3 = e4._events;
    if (r3 === void 0)
      return [];
    var i3 = r3[t4];
    return i3 === void 0 ? [] : typeof i3 == "function" ? n4 ? [i3.listener || i3] : [i3] : n4 ? function(e5) {
      for (var t5 = new Array(e5.length), n5 = 0; n5 < t5.length; ++n5)
        t5[n5] = e5[n5].listener || e5[n5];
      return t5;
    }(i3) : p(i3, i3.length);
  }
  function h(e4) {
    var t4 = this._events;
    if (t4 !== void 0) {
      var n4 = t4[e4];
      if (typeof n4 == "function")
        return 1;
      if (n4 !== void 0)
        return n4.length;
    }
    return 0;
  }
  function p(e4, t4) {
    for (var n4 = new Array(t4), r3 = 0; r3 < t4; ++r3)
      n4[r3] = e4[r3];
    return n4;
  }
  function v(e4, t4, n4, r3) {
    if (typeof e4.on == "function")
      r3.once ? e4.once(t4, n4) : e4.on(t4, n4);
    else {
      if (typeof e4.addEventListener != "function")
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e4);
      e4.addEventListener(t4, function i3(o2) {
        r3.once && e4.removeEventListener(t4, i3), n4(o2);
      });
    }
  }
  Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
    return s;
  }, set: function(e4) {
    if (typeof e4 != "number" || e4 < 0 || i2(e4))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e4 + ".");
    s = e4;
  } }), o.init = function() {
    this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, o.prototype.setMaxListeners = function(e4) {
    if (typeof e4 != "number" || e4 < 0 || i2(e4))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e4 + ".");
    return this._maxListeners = e4, this;
  }, o.prototype.getMaxListeners = function() {
    return u(this);
  }, o.prototype.emit = function(e4) {
    for (var t4 = [], n4 = 1; n4 < arguments.length; n4++)
      t4.push(arguments[n4]);
    var i3 = e4 === "error", o2 = this._events;
    if (o2 !== void 0)
      i3 = i3 && o2.error === void 0;
    else if (!i3)
      return false;
    if (i3) {
      var s2;
      if (t4.length > 0 && (s2 = t4[0]), s2 instanceof Error)
        throw s2;
      var a2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
      throw a2.context = s2, a2;
    }
    var u2 = o2[e4];
    if (u2 === void 0)
      return false;
    if (typeof u2 == "function")
      r2(u2, this, t4);
    else {
      var c2 = u2.length, f2 = p(u2, c2);
      for (n4 = 0; n4 < c2; ++n4)
        r2(f2[n4], this, t4);
    }
    return true;
  }, o.prototype.addListener = function(e4, t4) {
    return c(this, e4, t4, false);
  }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e4, t4) {
    return c(this, e4, t4, true);
  }, o.prototype.once = function(e4, t4) {
    return a(t4), this.on(e4, l(this, e4, t4)), this;
  }, o.prototype.prependOnceListener = function(e4, t4) {
    return a(t4), this.prependListener(e4, l(this, e4, t4)), this;
  }, o.prototype.removeListener = function(e4, t4) {
    var n4, r3, i3, o2, s2;
    if (a(t4), (r3 = this._events) === void 0)
      return this;
    if ((n4 = r3[e4]) === void 0)
      return this;
    if (n4 === t4 || n4.listener === t4)
      --this._eventsCount == 0 ? this._events = Object.create(null) : (delete r3[e4], r3.removeListener && this.emit("removeListener", e4, n4.listener || t4));
    else if (typeof n4 != "function") {
      for (i3 = -1, o2 = n4.length - 1; o2 >= 0; o2--)
        if (n4[o2] === t4 || n4[o2].listener === t4) {
          s2 = n4[o2].listener, i3 = o2;
          break;
        }
      if (i3 < 0)
        return this;
      i3 === 0 ? n4.shift() : function(e5, t5) {
        for (; t5 + 1 < e5.length; t5++)
          e5[t5] = e5[t5 + 1];
        e5.pop();
      }(n4, i3), n4.length === 1 && (r3[e4] = n4[0]), r3.removeListener !== void 0 && this.emit("removeListener", e4, s2 || t4);
    }
    return this;
  }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e4) {
    var t4, n4, r3;
    if ((n4 = this._events) === void 0)
      return this;
    if (n4.removeListener === void 0)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n4[e4] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete n4[e4]), this;
    if (arguments.length === 0) {
      var i3, o2 = Object.keys(n4);
      for (r3 = 0; r3 < o2.length; ++r3)
        (i3 = o2[r3]) !== "removeListener" && this.removeAllListeners(i3);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (typeof (t4 = n4[e4]) == "function")
      this.removeListener(e4, t4);
    else if (t4 !== void 0)
      for (r3 = t4.length - 1; r3 >= 0; r3--)
        this.removeListener(e4, t4[r3]);
    return this;
  }, o.prototype.listeners = function(e4) {
    return d(this, e4, true);
  }, o.prototype.rawListeners = function(e4) {
    return d(this, e4, false);
  }, o.listenerCount = function(e4, t4) {
    return typeof e4.listenerCount == "function" ? e4.listenerCount(t4) : h.call(e4, t4);
  }, o.prototype.listenerCount = h, o.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t3(this._events) : [];
  };
}, 624: (e3, t3, n3) => {
  var r2, i2, o, s = [n3(525), n3(785), n3(291), n3(709), n3(506), n3(176)], a = -1, u = [], c = false;
  function f() {
    r2 && i2 && (r2 = false, i2.length ? u = i2.concat(u) : a = -1, u.length && l());
  }
  function l() {
    if (!r2) {
      c = false, r2 = true;
      for (var e4 = u.length, t4 = setTimeout(f); e4; ) {
        for (i2 = u, u = []; i2 && ++a < e4; )
          i2[a].run();
        a = -1, e4 = u.length;
      }
      i2 = null, a = -1, r2 = false, clearTimeout(t4);
    }
  }
  for (var d = -1, h = s.length; ++d < h; )
    if (s[d] && s[d].test && s[d].test()) {
      o = s[d].install(l);
      break;
    }
  function p(e4, t4) {
    this.fun = e4, this.array = t4;
  }
  p.prototype.run = function() {
    var e4 = this.fun, t4 = this.array;
    switch (t4.length) {
      case 0:
        return e4();
      case 1:
        return e4(t4[0]);
      case 2:
        return e4(t4[0], t4[1]);
      case 3:
        return e4(t4[0], t4[1], t4[2]);
      default:
        return e4.apply(null, t4);
    }
  }, e3.exports = function(e4) {
    var t4 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n4 = 1; n4 < arguments.length; n4++)
        t4[n4 - 1] = arguments[n4];
    u.push(new p(e4, t4)), c || r2 || (c = true, o());
  };
}, 709: (e3, t3, n3) => {
  t3.test = function() {
    return !n3.g.setImmediate && n3.g.MessageChannel !== void 0;
  }, t3.install = function(e4) {
    var t4 = new n3.g.MessageChannel();
    return t4.port1.onmessage = e4, function() {
      t4.port2.postMessage(0);
    };
  };
}, 291: (e3, t3, n3) => {
  var r2 = n3.g.MutationObserver || n3.g.WebKitMutationObserver;
  t3.test = function() {
    return r2;
  }, t3.install = function(e4) {
    var t4 = 0, i2 = new r2(e4), o = n3.g.document.createTextNode("");
    return i2.observe(o, { characterData: true }), function() {
      o.data = t4 = ++t4 % 2;
    };
  };
}, 785: (e3, t3, n3) => {
  t3.test = function() {
    return typeof n3.g.queueMicrotask == "function";
  }, t3.install = function(e4) {
    return function() {
      n3.g.queueMicrotask(e4);
    };
  };
}, 506: (e3, t3, n3) => {
  t3.test = function() {
    return "document" in n3.g && "onreadystatechange" in n3.g.document.createElement("script");
  }, t3.install = function(e4) {
    return function() {
      var t4 = n3.g.document.createElement("script");
      return t4.onreadystatechange = function() {
        e4(), t4.onreadystatechange = null, t4.parentNode.removeChild(t4), t4 = null;
      }, n3.g.document.documentElement.appendChild(t4), e4;
    };
  };
}, 176: (e3, t3) => {
  t3.test = function() {
    return true;
  }, t3.install = function(e4) {
    return function() {
      setTimeout(e4, 0);
    };
  };
}, 717: (e3) => {
  typeof Object.create == "function" ? e3.exports = function(e4, t3) {
    t3 && (e4.super_ = t3, e4.prototype = Object.create(t3.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } }));
  } : e3.exports = function(e4, t3) {
    if (t3) {
      e4.super_ = t3;
      var n3 = function() {
      };
      n3.prototype = t3.prototype, e4.prototype = new n3(), e4.prototype.constructor = e4;
    }
  };
}, 198: (e3, t3, n3) => {
  n3.d(t3, { Z: () => fr });
  var r2, i2, o = n3(624), s = n3.n(o), a = n3(586), u = n3(322), c = n3.n(u), f = n3(684), l = n3(105), d = n3.n(l), h = n3(717), p = n3.n(h), v = n3(187), y = n3.n(v);
  function g(e4) {
    return "$" + e4;
  }
  function _(e4) {
    return e4.substring(1);
  }
  function m() {
    this._store = {};
  }
  function b(e4) {
    if (this._store = new m(), e4 && Array.isArray(e4))
      for (var t4 = 0, n4 = e4.length; t4 < n4; t4++)
        this.add(e4[t4]);
  }
  m.prototype.get = function(e4) {
    var t4 = g(e4);
    return this._store[t4];
  }, m.prototype.set = function(e4, t4) {
    var n4 = g(e4);
    return this._store[n4] = t4, true;
  }, m.prototype.has = function(e4) {
    return g(e4) in this._store;
  }, m.prototype.keys = function() {
    return Object.keys(this._store).map((e4) => _(e4));
  }, m.prototype.delete = function(e4) {
    var t4 = g(e4), n4 = t4 in this._store;
    return delete this._store[t4], n4;
  }, m.prototype.forEach = function(e4) {
    for (var t4 = Object.keys(this._store), n4 = 0, r3 = t4.length; n4 < r3; n4++) {
      var i3 = t4[n4];
      e4(this._store[i3], i3 = _(i3));
    }
  }, Object.defineProperty(m.prototype, "size", { get: function() {
    return Object.keys(this._store).length;
  } }), b.prototype.add = function(e4) {
    return this._store.set(e4, true);
  }, b.prototype.has = function(e4) {
    return this._store.has(e4);
  }, b.prototype.forEach = function(e4) {
    this._store.forEach(function(t4, n4) {
      e4(n4);
    });
  }, Object.defineProperty(b.prototype, "size", { get: function() {
    return this._store.size;
  } }), function() {
    if (typeof Symbol == "undefined" || typeof Map == "undefined" || typeof Set == "undefined")
      return false;
    var e4 = Object.getOwnPropertyDescriptor(Map, Symbol.species);
    return e4 && "get" in e4 && Map[Symbol.species] === Map;
  }() ? (r2 = Set, i2 = Map) : (r2 = b, i2 = m);
  var w, k = Function.prototype.toString, j = k.call(Object);
  function O(e4) {
    var t4, n4, r3;
    if (!e4 || typeof e4 != "object")
      return e4;
    if (Array.isArray(e4)) {
      for (t4 = [], n4 = 0, r3 = e4.length; n4 < r3; n4++)
        t4[n4] = O(e4[n4]);
      return t4;
    }
    if (e4 instanceof Date && isFinite(e4))
      return e4.toISOString();
    if (function(e5) {
      return typeof ArrayBuffer != "undefined" && e5 instanceof ArrayBuffer || typeof Blob != "undefined" && e5 instanceof Blob;
    }(e4))
      return function(e5) {
        if (e5 instanceof ArrayBuffer)
          return function(e6) {
            if (typeof e6.slice == "function")
              return e6.slice(0);
            var t6 = new ArrayBuffer(e6.byteLength), n6 = new Uint8Array(t6), r4 = new Uint8Array(e6);
            return n6.set(r4), t6;
          }(e5);
        var t5 = e5.size, n5 = e5.type;
        return typeof e5.slice == "function" ? e5.slice(0, t5, n5) : e5.webkitSlice(0, t5, n5);
      }(e4);
    if (!function(e5) {
      var t5 = Object.getPrototypeOf(e5);
      if (t5 === null)
        return true;
      var n5 = t5.constructor;
      return typeof n5 == "function" && n5 instanceof n5 && k.call(n5) == j;
    }(e4))
      return e4;
    for (n4 in t4 = {}, e4)
      if (Object.prototype.hasOwnProperty.call(e4, n4)) {
        var i3 = O(e4[n4]);
        i3 !== void 0 && (t4[n4] = i3);
      }
    return t4;
  }
  function $(e4) {
    var t4 = false;
    return d()(function(n4) {
      if (t4)
        throw new Error("once called more than once");
      t4 = true, e4.apply(this, n4);
    });
  }
  function x(e4) {
    return d()(function(t4) {
      t4 = O(t4);
      var n4 = this, r3 = typeof t4[t4.length - 1] == "function" && t4.pop(), i3 = new Promise(function(r4, i4) {
        var o2;
        try {
          var s2 = $(function(e5, t5) {
            e5 ? i4(e5) : r4(t5);
          });
          t4.push(s2), (o2 = e4.apply(n4, t4)) && typeof o2.then == "function" && r4(o2);
        } catch (e5) {
          i4(e5);
        }
      });
      return r3 && i3.then(function(e5) {
        r3(null, e5);
      }, r3), i3;
    });
  }
  function q(e4, t4) {
    return x(d()(function(n4) {
      if (this._closed)
        return Promise.reject(new Error("database is closed"));
      if (this._destroyed)
        return Promise.reject(new Error("database is destroyed"));
      var r3 = this;
      return function(e5, t5, n5) {
        if (e5.constructor.listeners("debug").length) {
          for (var r4 = ["api", e5.name, t5], i3 = 0; i3 < n5.length - 1; i3++)
            r4.push(n5[i3]);
          e5.constructor.emit("debug", r4);
          var o2 = n5[n5.length - 1];
          n5[n5.length - 1] = function(n6, r5) {
            var i4 = ["api", e5.name, t5];
            i4 = i4.concat(n6 ? ["error", n6] : ["success", r5]), e5.constructor.emit("debug", i4), o2(n6, r5);
          };
        }
      }(r3, e4, n4), this.taskqueue.isReady ? t4.apply(this, n4) : new Promise(function(t5, i3) {
        r3.taskqueue.addTask(function(o2) {
          o2 ? i3(o2) : t5(r3[e4].apply(r3, n4));
        });
      });
    }));
  }
  function A(e4, t4) {
    for (var n4 = {}, r3 = 0, i3 = t4.length; r3 < i3; r3++) {
      var o2 = t4[r3];
      o2 in e4 && (n4[o2] = e4[o2]);
    }
    return n4;
  }
  function S(e4) {
    return e4;
  }
  function E(e4) {
    return [{ ok: e4 }];
  }
  function P(e4, t4, n4) {
    var r3 = t4.docs, o2 = new i2();
    r3.forEach(function(e5) {
      o2.has(e5.id) ? o2.get(e5.id).push(e5) : o2.set(e5.id, [e5]);
    });
    var s2 = o2.size, a2 = 0, u2 = new Array(s2);
    var c2 = [];
    o2.forEach(function(e5, t5) {
      c2.push(t5);
    });
    var f2 = 0;
    !function r4() {
      if (!(f2 >= c2.length)) {
        var i3 = Math.min(f2 + 6, c2.length), l2 = c2.slice(f2, i3);
        !function(i4, c3) {
          i4.forEach(function(i5, f3) {
            var l3 = c3 + f3, d2 = o2.get(i5), h2 = A(d2[0], ["atts_since", "attachments"]);
            h2.open_revs = d2.map(function(e5) {
              return e5.rev;
            }), h2.open_revs = h2.open_revs.filter(S);
            var p2 = S;
            h2.open_revs.length === 0 && (delete h2.open_revs, p2 = E), ["revs", "attachments", "binary", "ajax", "latest"].forEach(function(e5) {
              e5 in t4 && (h2[e5] = t4[e5]);
            }), e4.get(i5, h2, function(e5, t5) {
              var o3, c4, f4, d3;
              o3 = e5 ? [{ error: e5 }] : p2(t5), c4 = i5, f4 = o3, u2[l3] = { id: c4, docs: f4 }, ++a2 === s2 && (d3 = [], u2.forEach(function(e6) {
                e6.docs.forEach(function(t6) {
                  d3.push({ id: e6.id, docs: [t6] });
                });
              }), n4(null, { results: d3 })), r4();
            });
          });
        }(l2, f2), f2 += l2.length;
      }
    }();
  }
  try {
    localStorage.setItem("_pouch_check_localstorage", 1), w = !!localStorage.getItem("_pouch_check_localstorage");
  } catch (e4) {
    w = false;
  }
  function C() {
    return w;
  }
  function D() {
    y().call(this), this._listeners = {}, function(e4) {
      C() && addEventListener("storage", function(t4) {
        e4.emit(t4.key);
      });
    }(this);
  }
  function L(e4) {
    if (typeof console != "undefined" && typeof console[e4] == "function") {
      var t4 = Array.prototype.slice.call(arguments, 1);
      console[e4].apply(console, t4);
    }
  }
  function B(e4) {
    var t4 = 0;
    return e4 || (t4 = 2e3), function(e5, t5) {
      var n4 = 6e5;
      return e5 = parseInt(e5, 10) || 0, (t5 = parseInt(t5, 10)) != t5 || t5 <= e5 ? t5 = (e5 || 1) << 1 : t5 += 1, t5 > n4 && (e5 = 3e5, t5 = n4), ~~((t5 - e5) * Math.random() + e5);
    }(e4, t4);
  }
  function I(e4, t4) {
    L("info", "The above " + e4 + " is totally normal. " + t4);
  }
  p()(D, y()), D.prototype.addListener = function(e4, t4, n4, r3) {
    if (!this._listeners[t4]) {
      var i3 = this, o2 = false;
      this._listeners[t4] = a2, this.on(e4, a2);
    }
    function a2() {
      if (i3._listeners[t4])
        if (o2)
          o2 = "waiting";
        else {
          o2 = true;
          var e5 = A(r3, ["style", "include_docs", "attachments", "conflicts", "filter", "doc_ids", "view", "since", "query_params", "binary", "return_docs"]);
          n4.changes(e5).on("change", function(e6) {
            e6.seq > r3.since && !r3.cancelled && (r3.since = e6.seq, r3.onChange(e6));
          }).on("complete", function() {
            o2 === "waiting" && s()(a2), o2 = false;
          }).on("error", function() {
            o2 = false;
          });
        }
    }
  }, D.prototype.removeListener = function(e4, t4) {
    t4 in this._listeners && (y().prototype.removeListener.call(this, e4, this._listeners[t4]), delete this._listeners[t4]);
  }, D.prototype.notifyLocalWindows = function(e4) {
    C() && (localStorage[e4] = localStorage[e4] === "a" ? "b" : "a");
  }, D.prototype.notify = function(e4) {
    this.emit(e4), this.notifyLocalWindows(e4);
  };
  var T = typeof Object.assign == "function" ? Object.assign : function(e4) {
    for (var t4 = Object(e4), n4 = 1; n4 < arguments.length; n4++) {
      var r3 = arguments[n4];
      if (r3 != null)
        for (var i3 in r3)
          Object.prototype.hasOwnProperty.call(r3, i3) && (t4[i3] = r3[i3]);
    }
    return t4;
  };
  function M(e4, t4, n4) {
    Error.call(this, n4), this.status = e4, this.name = t4, this.message = n4, this.error = true;
  }
  p()(M, Error), M.prototype.toString = function() {
    return JSON.stringify({ status: this.status, name: this.name, message: this.message, reason: this.reason });
  }, new M(401, "unauthorized", "Name or password is incorrect.");
  var N = new M(400, "bad_request", "Missing JSON list of 'docs'"), R = new M(404, "not_found", "missing"), F = new M(409, "conflict", "Document update conflict"), U = new M(400, "bad_request", "_id field must contain a string"), z = new M(412, "missing_id", "_id is required for puts"), J = new M(400, "bad_request", "Only reserved document ids may start with underscore."), K = (new M(412, "precondition_failed", "Database not open"), new M(500, "unknown_error", "Database encountered an unknown error")), V = new M(500, "badarg", "Some query argument is invalid"), Q = (new M(400, "invalid_request", "Request was invalid"), new M(400, "query_parse_error", "Some query parameter is invalid")), G = new M(500, "doc_validation", "Bad special document member"), W = new M(400, "bad_request", "Something wrong with the request"), Z = new M(400, "bad_request", "Document must be a JSON object"), X = (new M(404, "not_found", "Database not found"), new M(500, "indexed_db_went_bad", "unknown")), Y = (new M(500, "web_sql_went_bad", "unknown"), new M(500, "levelDB_went_went_bad", "unknown"), new M(403, "forbidden", "Forbidden by design doc validate_doc_update function"), new M(400, "bad_request", "Invalid rev format")), H = (new M(412, "file_exists", "The database could not be created, the file already exists."), new M(412, "missing_stub", "A pre-existing attachment stub wasn't found"));
  function ee(e4, t4) {
    function n4(t5) {
      for (var n5 = Object.getOwnPropertyNames(e4), r3 = 0, i3 = n5.length; r3 < i3; r3++)
        typeof e4[n5[r3]] != "function" && (this[n5[r3]] = e4[n5[r3]]);
      this.stack === void 0 && (this.stack = new Error().stack), t5 !== void 0 && (this.reason = t5);
    }
    return n4.prototype = M.prototype, new n4(t4);
  }
  function te(e4) {
    if (typeof e4 != "object") {
      var t4 = e4;
      (e4 = K).data = t4;
    }
    return "error" in e4 && e4.error === "conflict" && (e4.name = "conflict", e4.status = 409), "name" in e4 || (e4.name = e4.error || "unknown"), "status" in e4 || (e4.status = 500), "message" in e4 || (e4.message = e4.message || e4.reason), "stack" in e4 || (e4.stack = new Error().stack), e4;
  }
  function ne(e4) {
    var t4 = {}, n4 = e4.filter && typeof e4.filter == "function";
    return t4.query = e4.query_params, function(r3) {
      r3.doc || (r3.doc = {});
      var i3 = n4 && function(e5, t5, n5) {
        try {
          return !e5(t5, n5);
        } catch (e6) {
          var r4 = "Filter function threw: " + e6.toString();
          return ee(W, r4);
        }
      }(e4.filter, r3.doc, t4);
      if (typeof i3 == "object")
        return i3;
      if (i3)
        return false;
      if (e4.include_docs) {
        if (!e4.attachments)
          for (var o2 in r3.doc._attachments)
            Object.prototype.hasOwnProperty.call(r3.doc._attachments, o2) && (r3.doc._attachments[o2].stub = true);
      } else
        delete r3.doc;
      return true;
    };
  }
  function re(e4) {
    for (var t4 = [], n4 = 0, r3 = e4.length; n4 < r3; n4++)
      t4 = t4.concat(e4[n4]);
    return t4;
  }
  function ie(e4) {
    var t4;
    if (e4 ? typeof e4 != "string" ? t4 = ee(U) : /^_/.test(e4) && !/^_(design|local)/.test(e4) && (t4 = ee(J)) : t4 = ee(z), t4)
      throw t4;
  }
  function oe(e4) {
    return typeof e4._remote == "boolean" ? e4._remote : typeof e4.type == "function" && (L("warn", "db.type() is deprecated and will be removed in a future version of PouchDB"), e4.type() === "http");
  }
  function se(e4) {
    if (!e4)
      return null;
    var t4 = e4.split("/");
    return t4.length === 2 ? t4 : t4.length === 1 ? [e4, e4] : null;
  }
  function ae(e4) {
    var t4 = se(e4);
    return t4 ? t4.join("/") : null;
  }
  new M(413, "invalid_url", "Provided URL is invalid");
  var ue = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], ce = "queryKey", fe = /(?:^|&)([^&=]*)=?([^&]*)/g, le = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  function de(e4) {
    for (var t4 = le.exec(e4), n4 = {}, r3 = 14; r3--; ) {
      var i3 = ue[r3], o2 = t4[r3] || "", s2 = ["user", "password"].indexOf(i3) !== -1;
      n4[i3] = s2 ? decodeURIComponent(o2) : o2;
    }
    return n4[ce] = {}, n4[ue[12]].replace(fe, function(e5, t5, r4) {
      t5 && (n4[ce][t5] = r4);
    }), n4;
  }
  function he(e4, t4) {
    var n4 = [], r3 = [];
    for (var i3 in t4)
      Object.prototype.hasOwnProperty.call(t4, i3) && (n4.push(i3), r3.push(t4[i3]));
    return n4.push(e4), Function.apply(null, n4).apply(null, r3);
  }
  function pe(e4, t4, n4) {
    return e4.get(t4).catch(function(e5) {
      if (e5.status !== 404)
        throw e5;
      return {};
    }).then(function(r3) {
      var i3 = r3._rev, o2 = n4(r3);
      return o2 ? (o2._id = t4, o2._rev = i3, function(e5, t5, n5) {
        return e5.put(t5).then(function(e6) {
          return { updated: true, rev: e6.rev };
        }, function(r4) {
          if (r4.status !== 409)
            throw r4;
          return pe(e5, t5._id, n5);
        });
      }(e4, o2, n4)) : { updated: false, rev: i3 };
    });
  }
  var ve = function(e4) {
    return atob(e4);
  }, ye = function(e4) {
    return btoa(e4);
  };
  function ge(e4, t4) {
    e4 = e4 || [], t4 = t4 || {};
    try {
      return new Blob(e4, t4);
    } catch (i3) {
      if (i3.name !== "TypeError")
        throw i3;
      for (var n4 = new (typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder)(), r3 = 0; r3 < e4.length; r3 += 1)
        n4.append(e4[r3]);
      return n4.getBlob(t4.type);
    }
  }
  function _e(e4) {
    for (var t4 = e4.length, n4 = new ArrayBuffer(t4), r3 = new Uint8Array(n4), i3 = 0; i3 < t4; i3++)
      r3[i3] = e4.charCodeAt(i3);
    return n4;
  }
  function me(e4, t4) {
    return ge([_e(e4)], { type: t4 });
  }
  function be(e4, t4) {
    return me(ve(e4), t4);
  }
  function we(e4, t4) {
    var n4 = new FileReader(), r3 = typeof n4.readAsBinaryString == "function";
    n4.onloadend = function(e5) {
      var n5 = e5.target.result || "";
      if (r3)
        return t4(n5);
      t4(function(e6) {
        for (var t5 = "", n6 = new Uint8Array(e6), r4 = n6.byteLength, i3 = 0; i3 < r4; i3++)
          t5 += String.fromCharCode(n6[i3]);
        return t5;
      }(n5));
    }, r3 ? n4.readAsBinaryString(e4) : n4.readAsArrayBuffer(e4);
  }
  function ke(e4, t4) {
    we(e4, function(e5) {
      t4(e5);
    });
  }
  function je(e4, t4) {
    ke(e4, function(e5) {
      t4(ye(e5));
    });
  }
  var Oe = self.setImmediate || self.setTimeout;
  function $e(e4, t4, n4, r3, i3) {
    (n4 > 0 || r3 < t4.size) && (t4 = function(e5, t5, n5) {
      return e5.webkitSlice ? e5.webkitSlice(t5, n5) : e5.slice(t5, n5);
    }(t4, n4, r3)), function(e5, t5) {
      var n5 = new FileReader();
      n5.onloadend = function(e6) {
        var n6 = e6.target.result || new ArrayBuffer(0);
        t5(n6);
      }, n5.readAsArrayBuffer(e5);
    }(t4, function(t5) {
      e4.append(t5), i3();
    });
  }
  function xe(e4, t4, n4, r3, i3) {
    (n4 > 0 || r3 < t4.length) && (t4 = t4.substring(n4, r3)), e4.appendBinary(t4), i3();
  }
  function qe(e4, t4) {
    var n4 = typeof e4 == "string", r3 = n4 ? e4.length : e4.size, i3 = Math.min(32768, r3), o2 = Math.ceil(r3 / i3), s2 = 0, a2 = n4 ? new (c())() : new (c()).ArrayBuffer(), u2 = n4 ? xe : $e;
    function f2() {
      Oe(d2);
    }
    function l2() {
      var e5, n5 = (e5 = a2.end(true), ye(e5));
      t4(n5), a2.destroy();
    }
    function d2() {
      var t5 = s2 * i3;
      s2++, u2(a2, e4, t5, t5 + i3, s2 < o2 ? f2 : l2);
    }
    d2();
  }
  function Ae(e4) {
    return c().hash(e4);
  }
  function Se(e4, t4) {
    if (!t4)
      return (0, a.Z)().replace(/-/g, "").toLowerCase();
    var n4 = T({}, e4);
    return delete n4._rev_tree, Ae(JSON.stringify(n4));
  }
  var Ee = a.Z;
  function Pe(e4) {
    for (var t4, n4, r3, i3, o2 = e4.rev_tree.slice(); i3 = o2.pop(); ) {
      var s2 = i3.ids, a2 = s2[2], u2 = i3.pos;
      if (a2.length)
        for (var c2 = 0, f2 = a2.length; c2 < f2; c2++)
          o2.push({ pos: u2 + 1, ids: a2[c2] });
      else {
        var l2 = !!s2[1].deleted, d2 = s2[0];
        t4 && !(r3 !== l2 ? r3 : n4 !== u2 ? n4 < u2 : t4 < d2) || (t4 = d2, n4 = u2, r3 = l2);
      }
    }
    return n4 + "-" + t4;
  }
  function Ce(e4, t4) {
    for (var n4, r3 = e4.slice(); n4 = r3.pop(); )
      for (var i3 = n4.pos, o2 = n4.ids, s2 = o2[2], a2 = t4(s2.length === 0, i3, o2[0], n4.ctx, o2[1]), u2 = 0, c2 = s2.length; u2 < c2; u2++)
        r3.push({ pos: i3 + 1, ids: s2[u2], ctx: a2 });
  }
  function De(e4, t4) {
    return e4.pos - t4.pos;
  }
  function Le(e4) {
    var t4 = [];
    Ce(e4, function(e5, n5, r4, i3, o2) {
      e5 && t4.push({ rev: n5 + "-" + r4, pos: n5, opts: o2 });
    }), t4.sort(De).reverse();
    for (var n4 = 0, r3 = t4.length; n4 < r3; n4++)
      delete t4[n4].pos;
    return t4;
  }
  function Be(e4) {
    for (var t4 = Pe(e4), n4 = Le(e4.rev_tree), r3 = [], i3 = 0, o2 = n4.length; i3 < o2; i3++) {
      var s2 = n4[i3];
      s2.rev === t4 || s2.opts.deleted || r3.push(s2.rev);
    }
    return r3;
  }
  function Ie(e4) {
    for (var t4, n4 = [], r3 = e4.slice(); t4 = r3.pop(); ) {
      var i3 = t4.pos, o2 = t4.ids, s2 = o2[0], a2 = o2[1], u2 = o2[2], c2 = u2.length === 0, f2 = t4.history ? t4.history.slice() : [];
      f2.push({ id: s2, opts: a2 }), c2 && n4.push({ pos: i3 + 1 - f2.length, ids: f2 });
      for (var l2 = 0, d2 = u2.length; l2 < d2; l2++)
        r3.push({ pos: i3 + 1, ids: u2[l2], history: f2 });
    }
    return n4.reverse();
  }
  function Te(e4, t4) {
    return e4.pos - t4.pos;
  }
  function Me(e4, t4, n4) {
    var r3 = function(e5, t5, n5) {
      for (var r4, i3 = 0, o2 = e5.length; i3 < o2; )
        n5(e5[r4 = i3 + o2 >>> 1], t5) < 0 ? i3 = r4 + 1 : o2 = r4;
      return i3;
    }(e4, t4, n4);
    e4.splice(r3, 0, t4);
  }
  function Ne(e4, t4) {
    for (var n4, r3, i3 = t4, o2 = e4.length; i3 < o2; i3++) {
      var s2 = e4[i3], a2 = [s2.id, s2.opts, []];
      r3 ? (r3[2].push(a2), r3 = a2) : n4 = r3 = a2;
    }
    return n4;
  }
  function Re(e4, t4) {
    return e4[0] < t4[0] ? -1 : 1;
  }
  function Fe(e4, t4) {
    for (var n4 = [{ tree1: e4, tree2: t4 }], r3 = false; n4.length > 0; ) {
      var i3 = n4.pop(), o2 = i3.tree1, s2 = i3.tree2;
      (o2[1].status || s2[1].status) && (o2[1].status = o2[1].status === "available" || s2[1].status === "available" ? "available" : "missing");
      for (var a2 = 0; a2 < s2[2].length; a2++)
        if (o2[2][0]) {
          for (var u2 = false, c2 = 0; c2 < o2[2].length; c2++)
            o2[2][c2][0] === s2[2][a2][0] && (n4.push({ tree1: o2[2][c2], tree2: s2[2][a2] }), u2 = true);
          u2 || (r3 = "new_branch", Me(o2[2], s2[2][a2], Re));
        } else
          r3 = "new_leaf", o2[2][0] = s2[2][a2];
    }
    return { conflicts: r3, tree: e4 };
  }
  function Ue(e4, t4, n4) {
    var r3, i3 = [], o2 = false, s2 = false;
    if (!e4.length)
      return { tree: [t4], conflicts: "new_leaf" };
    for (var a2 = 0, u2 = e4.length; a2 < u2; a2++) {
      var c2 = e4[a2];
      if (c2.pos === t4.pos && c2.ids[0] === t4.ids[0])
        r3 = Fe(c2.ids, t4.ids), i3.push({ pos: c2.pos, ids: r3.tree }), o2 = o2 || r3.conflicts, s2 = true;
      else if (n4 !== true) {
        var f2 = c2.pos < t4.pos ? c2 : t4, l2 = c2.pos < t4.pos ? t4 : c2, d2 = l2.pos - f2.pos, h2 = [], p2 = [];
        for (p2.push({ ids: f2.ids, diff: d2, parent: null, parentIdx: null }); p2.length > 0; ) {
          var v2 = p2.pop();
          if (v2.diff !== 0)
            for (var y2 = v2.ids[2], g2 = 0, _2 = y2.length; g2 < _2; g2++)
              p2.push({ ids: y2[g2], diff: v2.diff - 1, parent: v2.ids, parentIdx: g2 });
          else
            v2.ids[0] === l2.ids[0] && h2.push(v2);
        }
        var m2 = h2[0];
        m2 ? (r3 = Fe(m2.ids, l2.ids), m2.parent[2][m2.parentIdx] = r3.tree, i3.push({ pos: f2.pos, ids: f2.ids }), o2 = o2 || r3.conflicts, s2 = true) : i3.push(c2);
      } else
        i3.push(c2);
    }
    return s2 || i3.push(t4), i3.sort(Te), { tree: i3, conflicts: o2 || "internal_node" };
  }
  function ze(e4, t4, n4) {
    var r3 = Ue(e4, t4), i3 = function(e5, t5) {
      for (var n5, r4, i4 = Ie(e5), o2 = 0, s2 = i4.length; o2 < s2; o2++) {
        var a2, u2 = i4[o2], c2 = u2.ids;
        if (c2.length > t5) {
          n5 || (n5 = {});
          var f2 = c2.length - t5;
          a2 = { pos: u2.pos + f2, ids: Ne(c2, f2) };
          for (var l2 = 0; l2 < f2; l2++) {
            var d2 = u2.pos + l2 + "-" + c2[l2].id;
            n5[d2] = true;
          }
        } else
          a2 = { pos: u2.pos, ids: Ne(c2, 0) };
        r4 = r4 ? Ue(r4, a2, true).tree : [a2];
      }
      return n5 && Ce(r4, function(e6, t6, r5) {
        delete n5[t6 + "-" + r5];
      }), { tree: r4, revs: n5 ? Object.keys(n5) : [] };
    }(r3.tree, n4);
    return { tree: i3.tree, stemmedRevs: i3.revs, conflicts: r3.conflicts };
  }
  function Je(e4) {
    return e4.ids;
  }
  function Ke(e4, t4) {
    t4 || (t4 = Pe(e4));
    for (var n4, r3 = t4.substring(t4.indexOf("-") + 1), i3 = e4.rev_tree.map(Je); n4 = i3.pop(); ) {
      if (n4[0] === r3)
        return !!n4[1].deleted;
      i3 = i3.concat(n4[2]);
    }
  }
  function Ve(e4) {
    return /^_local/.test(e4);
  }
  function Qe(e4, t4, n4) {
    y().call(this);
    var r3 = this;
    this.db = e4;
    var i3 = (t4 = t4 ? O(t4) : {}).complete = $(function(t5, n5) {
      var i4, s3;
      t5 ? (s3 = "error", ("listenerCount" in (i4 = r3) ? i4.listenerCount(s3) : y().listenerCount(i4, s3)) > 0 && r3.emit("error", t5)) : r3.emit("complete", n5), r3.removeAllListeners(), e4.removeListener("destroyed", o2);
    });
    function o2() {
      r3.cancel();
    }
    n4 && (r3.on("complete", function(e5) {
      n4(null, e5);
    }), r3.on("error", n4)), e4.once("destroyed", o2), t4.onChange = function(e5, t5, n5) {
      r3.isCancelled || function(e6, t6, n6, r4) {
        try {
          e6.emit("change", t6, n6, r4);
        } catch (e7) {
          L("error", 'Error in .on("change", function):', e7);
        }
      }(r3, e5, t5, n5);
    };
    var s2 = new Promise(function(e5, n5) {
      t4.complete = function(t5, r4) {
        t5 ? n5(t5) : e5(r4);
      };
    });
    r3.once("cancel", function() {
      e4.removeListener("destroyed", o2), t4.complete(null, { status: "cancelled" });
    }), this.then = s2.then.bind(s2), this.catch = s2.catch.bind(s2), this.then(function(e5) {
      i3(null, e5);
    }, i3), e4.taskqueue.isReady ? r3.validateChanges(t4) : e4.taskqueue.addTask(function(e5) {
      e5 ? t4.complete(e5) : r3.isCancelled ? r3.emit("cancel") : r3.validateChanges(t4);
    });
  }
  function Ge(e4, t4, n4) {
    var r3 = [{ rev: e4._rev }];
    n4.style === "all_docs" && (r3 = Le(t4.rev_tree).map(function(e5) {
      return { rev: e5.rev };
    }));
    var i3 = { id: t4.id, changes: r3, doc: e4 };
    return Ke(t4, e4._rev) && (i3.deleted = true), n4.conflicts && (i3.doc._conflicts = Be(t4), i3.doc._conflicts.length || delete i3.doc._conflicts), i3;
  }
  function We(e4, t4) {
    return e4 < t4 ? -1 : e4 > t4 ? 1 : 0;
  }
  function Ze(e4, t4) {
    return function(n4, r3) {
      n4 || r3[0] && r3[0].error ? ((n4 = n4 || r3[0]).docId = t4, e4(n4)) : e4(null, r3.length ? r3[0] : r3);
    };
  }
  function Xe(e4, t4) {
    var n4 = We(e4._id, t4._id);
    return n4 !== 0 ? n4 : We(e4._revisions ? e4._revisions.start : 0, t4._revisions ? t4._revisions.start : 0);
  }
  function Ye(e4) {
    var t4 = e4._compactionQueue[0], n4 = t4.opts, r3 = t4.callback;
    e4.get("_local/compaction").catch(function() {
      return false;
    }).then(function(t5) {
      t5 && t5.last_seq && (n4.last_seq = t5.last_seq), e4._compact(n4, function(t6, n5) {
        t6 ? r3(t6) : r3(null, n5), s()(function() {
          e4._compactionQueue.shift(), e4._compactionQueue.length && Ye(e4);
        });
      });
    });
  }
  function He() {
    for (var e4 in y().call(this), He.prototype)
      typeof this[e4] == "function" && (this[e4] = this[e4].bind(this));
  }
  function et() {
    this.isReady = false, this.failed = false, this.queue = [];
  }
  function tt(e4, t4) {
    if (!(this instanceof tt))
      return new tt(e4, t4);
    var n4 = this;
    if (t4 = t4 || {}, e4 && typeof e4 == "object" && (e4 = (t4 = e4).name, delete t4.name), t4.deterministic_revs === void 0 && (t4.deterministic_revs = true), this.__opts = t4 = O(t4), n4.auto_compaction = t4.auto_compaction, n4.prefix = tt.prefix, typeof e4 != "string")
      throw new Error("Missing/invalid DB name");
    var r3 = function(e5, t5) {
      var n5 = e5.match(/([a-z-]*):\/\/(.*)/);
      if (n5)
        return { name: /https?/.test(n5[1]) ? n5[1] + "://" + n5[2] : n5[2], adapter: n5[1] };
      var r4 = tt.adapters, i3 = tt.preferredAdapters, o2 = tt.prefix, s2 = t5.adapter;
      if (!s2)
        for (var a2 = 0; a2 < i3.length && (s2 = i3[a2]) === "idb" && "websql" in r4 && C() && localStorage["_pouch__websqldb_" + o2 + e5]; ++a2)
          L("log", 'PouchDB is downgrading "' + e5 + '" to WebSQL to avoid data loss, because it was already opened with WebSQL.');
      var u2 = r4[s2];
      return { name: u2 && "use_prefix" in u2 && !u2.use_prefix ? e5 : o2 + e5, adapter: s2 };
    }((t4.prefix || "") + e4, t4);
    if (t4.name = r3.name, t4.adapter = t4.adapter || r3.adapter, n4.name = e4, n4._adapter = t4.adapter, tt.emit("debug", ["adapter", "Picked adapter: ", t4.adapter]), !tt.adapters[t4.adapter] || !tt.adapters[t4.adapter].valid())
      throw new Error("Invalid Adapter: " + t4.adapter);
    if (t4.view_adapter && (!tt.adapters[t4.view_adapter] || !tt.adapters[t4.view_adapter].valid()))
      throw new Error("Invalid View Adapter: " + t4.view_adapter);
    He.call(n4), n4.taskqueue = new et(), n4.adapter = t4.adapter, tt.adapters[t4.adapter].call(n4, t4, function(e5) {
      if (e5)
        return n4.taskqueue.fail(e5);
      !function(e6) {
        function t5(t6) {
          e6.removeListener("closed", n5), t6 || e6.constructor.emit("destroyed", e6.name);
        }
        function n5() {
          e6.removeListener("destroyed", t5), e6.constructor.emit("unref", e6);
        }
        e6.once("destroyed", t5), e6.once("closed", n5), e6.constructor.emit("ref", e6);
      }(n4), n4.emit("created", n4), tt.emit("created", n4.name), n4.taskqueue.ready(n4);
    });
  }
  p()(Qe, y()), Qe.prototype.cancel = function() {
    this.isCancelled = true, this.db.taskqueue.isReady && this.emit("cancel");
  }, Qe.prototype.validateChanges = function(e4) {
    var t4 = e4.complete, n4 = this;
    tt._changesFilterPlugin ? tt._changesFilterPlugin.validate(e4, function(r3) {
      if (r3)
        return t4(r3);
      n4.doChanges(e4);
    }) : n4.doChanges(e4);
  }, Qe.prototype.doChanges = function(e4) {
    var t4 = this, n4 = e4.complete;
    if ("live" in (e4 = O(e4)) && !("continuous" in e4) && (e4.continuous = e4.live), e4.processChange = Ge, e4.since === "latest" && (e4.since = "now"), e4.since || (e4.since = 0), e4.since !== "now") {
      if (tt._changesFilterPlugin) {
        if (tt._changesFilterPlugin.normalize(e4), tt._changesFilterPlugin.shouldFilter(this, e4))
          return tt._changesFilterPlugin.filter(this, e4);
      } else
        ["doc_ids", "filter", "selector", "view"].forEach(function(t5) {
          t5 in e4 && L("warn", 'The "' + t5 + '" option was passed in to changes/replicate, but pouchdb-changes-filter plugin is not installed, so it was ignored. Please install the plugin to enable filtering.');
        });
      "descending" in e4 || (e4.descending = false), e4.limit = e4.limit === 0 ? 1 : e4.limit, e4.complete = n4;
      var r3 = this.db._changes(e4);
      if (r3 && typeof r3.cancel == "function") {
        var i3 = t4.cancel;
        t4.cancel = d()(function(e5) {
          r3.cancel(), i3.apply(this, e5);
        });
      }
    } else
      this.db.info().then(function(r4) {
        t4.isCancelled ? n4(null, { status: "cancelled" }) : (e4.since = r4.update_seq, t4.doChanges(e4));
      }, n4);
  }, p()(He, y()), He.prototype.post = q("post", function(e4, t4, n4) {
    if (typeof t4 == "function" && (n4 = t4, t4 = {}), typeof e4 != "object" || Array.isArray(e4))
      return n4(ee(Z));
    this.bulkDocs({ docs: [e4] }, t4, Ze(n4, e4._id));
  }), He.prototype.put = q("put", function(e4, t4, n4) {
    if (typeof t4 == "function" && (n4 = t4, t4 = {}), typeof e4 != "object" || Array.isArray(e4))
      return n4(ee(Z));
    if (ie(e4._id), Ve(e4._id) && typeof this._putLocal == "function")
      return e4._deleted ? this._removeLocal(e4, n4) : this._putLocal(e4, n4);
    var r3, i3, o2, s2, a2 = this;
    function u2(n5) {
      typeof a2._put == "function" && t4.new_edits !== false ? a2._put(e4, t4, n5) : a2.bulkDocs({ docs: [e4] }, t4, Ze(n5, e4._id));
    }
    t4.force && e4._rev ? (i3 = (r3 = e4._rev.split("-"))[1], o2 = parseInt(r3[0], 10) + 1, s2 = Se(), e4._revisions = { start: o2, ids: [s2, i3] }, e4._rev = o2 + "-" + s2, t4.new_edits = false, u2(function(t5) {
      var r4 = t5 ? null : { ok: true, id: e4._id, rev: e4._rev };
      n4(t5, r4);
    })) : u2(n4);
  }), He.prototype.putAttachment = q("putAttachment", function(e4, t4, n4, r3, i3) {
    var o2 = this;
    function s2(e5) {
      var n5 = "_rev" in e5 ? parseInt(e5._rev, 10) : 0;
      return e5._attachments = e5._attachments || {}, e5._attachments[t4] = { content_type: i3, data: r3, revpos: ++n5 }, o2.put(e5);
    }
    return typeof i3 == "function" && (i3 = r3, r3 = n4, n4 = null), i3 === void 0 && (i3 = r3, r3 = n4, n4 = null), i3 || L("warn", "Attachment", t4, "on document", e4, "is missing content_type"), o2.get(e4).then(function(e5) {
      if (e5._rev !== n4)
        throw ee(F);
      return s2(e5);
    }, function(t5) {
      if (t5.reason === R.message)
        return s2({ _id: e4 });
      throw t5;
    });
  }), He.prototype.removeAttachment = q("removeAttachment", function(e4, t4, n4, r3) {
    var i3 = this;
    i3.get(e4, function(e5, o2) {
      if (e5)
        r3(e5);
      else if (o2._rev === n4) {
        if (!o2._attachments)
          return r3();
        delete o2._attachments[t4], Object.keys(o2._attachments).length === 0 && delete o2._attachments, i3.put(o2, r3);
      } else
        r3(ee(F));
    });
  }), He.prototype.remove = q("remove", function(e4, t4, n4, r3) {
    var i3;
    typeof t4 == "string" ? (i3 = { _id: e4, _rev: t4 }, typeof n4 == "function" && (r3 = n4, n4 = {})) : (i3 = e4, typeof t4 == "function" ? (r3 = t4, n4 = {}) : (r3 = n4, n4 = t4)), (n4 = n4 || {}).was_delete = true;
    var o2 = { _id: i3._id, _rev: i3._rev || n4.rev, _deleted: true };
    if (Ve(o2._id) && typeof this._removeLocal == "function")
      return this._removeLocal(i3, r3);
    this.bulkDocs({ docs: [o2] }, n4, Ze(r3, o2._id));
  }), He.prototype.revsDiff = q("revsDiff", function(e4, t4, n4) {
    typeof t4 == "function" && (n4 = t4, t4 = {});
    var r3 = Object.keys(e4);
    if (!r3.length)
      return n4(null, {});
    var o2 = 0, s2 = new i2();
    function a2(e5, t5) {
      s2.has(e5) || s2.set(e5, { missing: [] }), s2.get(e5).missing.push(t5);
    }
    r3.map(function(t5) {
      this._getRevisionTree(t5, function(i3, u2) {
        if (i3 && i3.status === 404 && i3.message === "missing")
          s2.set(t5, { missing: e4[t5] });
        else {
          if (i3)
            return n4(i3);
          !function(t6, n5) {
            var r4 = e4[t6].slice(0);
            Ce(n5, function(e5, n6, i4, o3, s3) {
              var u3 = n6 + "-" + i4, c3 = r4.indexOf(u3);
              c3 !== -1 && (r4.splice(c3, 1), s3.status !== "available" && a2(t6, u3));
            }), r4.forEach(function(e5) {
              a2(t6, e5);
            });
          }(t5, u2);
        }
        if (++o2 === r3.length) {
          var c2 = {};
          return s2.forEach(function(e5, t6) {
            c2[t6] = e5;
          }), n4(null, c2);
        }
      });
    }, this);
  }), He.prototype.bulkGet = q("bulkGet", function(e4, t4) {
    P(this, e4, t4);
  }), He.prototype.compactDocument = q("compactDocument", function(e4, t4, n4) {
    var r3 = this;
    this._getRevisionTree(e4, function(i3, o2) {
      if (i3)
        return n4(i3);
      var s2 = function(e5) {
        var t5 = {}, n5 = [];
        return Ce(e5, function(e6, r4, i4, o3) {
          var s3 = r4 + "-" + i4;
          return e6 && (t5[s3] = 0), o3 !== void 0 && n5.push({ from: o3, to: s3 }), s3;
        }), n5.reverse(), n5.forEach(function(e6) {
          t5[e6.from] === void 0 ? t5[e6.from] = 1 + t5[e6.to] : t5[e6.from] = Math.min(t5[e6.from], 1 + t5[e6.to]);
        }), t5;
      }(o2), a2 = [], u2 = [];
      Object.keys(s2).forEach(function(e5) {
        s2[e5] > t4 && a2.push(e5);
      }), Ce(o2, function(e5, t5, n5, r4, i4) {
        var o3 = t5 + "-" + n5;
        i4.status === "available" && a2.indexOf(o3) !== -1 && u2.push(o3);
      }), r3._doCompaction(e4, u2, n4);
    });
  }), He.prototype.compact = q("compact", function(e4, t4) {
    typeof e4 == "function" && (t4 = e4, e4 = {});
    var n4 = this;
    e4 = e4 || {}, n4._compactionQueue = n4._compactionQueue || [], n4._compactionQueue.push({ opts: e4, callback: t4 }), n4._compactionQueue.length === 1 && Ye(n4);
  }), He.prototype._compact = function(e4, t4) {
    var n4 = this, r3 = { return_docs: false, last_seq: e4.last_seq || 0 }, i3 = [];
    n4.changes(r3).on("change", function(e5) {
      i3.push(n4.compactDocument(e5.id, 0));
    }).on("complete", function(e5) {
      var r4 = e5.last_seq;
      Promise.all(i3).then(function() {
        return pe(n4, "_local/compaction", function(e6) {
          return (!e6.last_seq || e6.last_seq < r4) && (e6.last_seq = r4, e6);
        });
      }).then(function() {
        t4(null, { ok: true });
      }).catch(t4);
    }).on("error", t4);
  }, He.prototype.get = q("get", function(e4, t4, n4) {
    if (typeof t4 == "function" && (n4 = t4, t4 = {}), typeof e4 != "string")
      return n4(ee(U));
    if (Ve(e4) && typeof this._getLocal == "function")
      return this._getLocal(e4, n4);
    var r3 = [], i3 = this;
    function o2() {
      var o3 = [], s3 = r3.length;
      if (!s3)
        return n4(null, o3);
      r3.forEach(function(r4) {
        i3.get(e4, { rev: r4, revs: t4.revs, latest: t4.latest, attachments: t4.attachments, binary: t4.binary }, function(e5, t5) {
          if (e5)
            o3.push({ missing: r4 });
          else {
            for (var i4, a3 = 0, u2 = o3.length; a3 < u2; a3++)
              if (o3[a3].ok && o3[a3].ok._rev === t5._rev) {
                i4 = true;
                break;
              }
            i4 || o3.push({ ok: t5 });
          }
          --s3 || n4(null, o3);
        });
      });
    }
    if (!t4.open_revs)
      return this._get(e4, t4, function(r4, o3) {
        if (r4)
          return r4.docId = e4, n4(r4);
        var s3 = o3.doc, a3 = o3.metadata, u2 = o3.ctx;
        if (t4.conflicts) {
          var c2 = Be(a3);
          c2.length && (s3._conflicts = c2);
        }
        if (Ke(a3, s3._rev) && (s3._deleted = true), t4.revs || t4.revs_info) {
          for (var f2 = s3._rev.split("-"), l2 = parseInt(f2[0], 10), d2 = f2[1], h2 = Ie(a3.rev_tree), p2 = null, v2 = 0; v2 < h2.length; v2++) {
            var y2 = h2[v2], g2 = y2.ids.map(function(e5) {
              return e5.id;
            }).indexOf(d2);
            (g2 === l2 - 1 || !p2 && g2 !== -1) && (p2 = y2);
          }
          if (!p2)
            return (r4 = new Error("invalid rev tree")).docId = e4, n4(r4);
          var _2 = p2.ids.map(function(e5) {
            return e5.id;
          }).indexOf(s3._rev.split("-")[1]) + 1, m2 = p2.ids.length - _2;
          if (p2.ids.splice(_2, m2), p2.ids.reverse(), t4.revs && (s3._revisions = { start: p2.pos + p2.ids.length - 1, ids: p2.ids.map(function(e5) {
            return e5.id;
          }) }), t4.revs_info) {
            var b2 = p2.pos + p2.ids.length;
            s3._revs_info = p2.ids.map(function(e5) {
              return { rev: --b2 + "-" + e5.id, status: e5.opts.status };
            });
          }
        }
        if (t4.attachments && s3._attachments) {
          var w2 = s3._attachments, k2 = Object.keys(w2).length;
          if (k2 === 0)
            return n4(null, s3);
          Object.keys(w2).forEach(function(e5) {
            this._getAttachment(s3._id, e5, w2[e5], { rev: s3._rev, binary: t4.binary, ctx: u2 }, function(t5, r5) {
              var i4 = s3._attachments[e5];
              i4.data = r5, delete i4.stub, delete i4.length, --k2 || n4(null, s3);
            });
          }, i3);
        } else {
          if (s3._attachments)
            for (var j2 in s3._attachments)
              Object.prototype.hasOwnProperty.call(s3._attachments, j2) && (s3._attachments[j2].stub = true);
          n4(null, s3);
        }
      });
    if (t4.open_revs === "all")
      this._getRevisionTree(e4, function(e5, t5) {
        if (e5)
          return n4(e5);
        r3 = Le(t5).map(function(e6) {
          return e6.rev;
        }), o2();
      });
    else {
      if (!Array.isArray(t4.open_revs))
        return n4(ee(K, "function_clause"));
      r3 = t4.open_revs;
      for (var s2 = 0; s2 < r3.length; s2++) {
        var a2 = r3[s2];
        if (typeof a2 != "string" || !/^\d+-/.test(a2))
          return n4(ee(Y));
      }
      o2();
    }
  }), He.prototype.getAttachment = q("getAttachment", function(e4, t4, n4, r3) {
    var i3 = this;
    n4 instanceof Function && (r3 = n4, n4 = {}), this._get(e4, n4, function(o2, s2) {
      return o2 ? r3(o2) : s2.doc._attachments && s2.doc._attachments[t4] ? (n4.ctx = s2.ctx, n4.binary = true, void i3._getAttachment(e4, t4, s2.doc._attachments[t4], n4, r3)) : r3(ee(R));
    });
  }), He.prototype.allDocs = q("allDocs", function(e4, t4) {
    if (typeof e4 == "function" && (t4 = e4, e4 = {}), e4.skip = e4.skip !== void 0 ? e4.skip : 0, e4.start_key && (e4.startkey = e4.start_key), e4.end_key && (e4.endkey = e4.end_key), "keys" in e4) {
      if (!Array.isArray(e4.keys))
        return t4(new TypeError("options.keys must be an array"));
      var n4 = ["startkey", "endkey", "key"].filter(function(t5) {
        return t5 in e4;
      })[0];
      if (n4)
        return void t4(ee(Q, "Query parameter `" + n4 + "` is not compatible with multi-get"));
      if (!oe(this) && (function(e5) {
        var t5 = "limit" in e5 ? e5.keys.slice(e5.skip, e5.limit + e5.skip) : e5.skip > 0 ? e5.keys.slice(e5.skip) : e5.keys;
        e5.keys = t5, e5.skip = 0, delete e5.limit, e5.descending && (t5.reverse(), e5.descending = false);
      }(e4), e4.keys.length === 0))
        return this._allDocs({ limit: 0 }, t4);
    }
    return this._allDocs(e4, t4);
  }), He.prototype.changes = function(e4, t4) {
    return typeof e4 == "function" && (t4 = e4, e4 = {}), (e4 = e4 || {}).return_docs = "return_docs" in e4 ? e4.return_docs : !e4.live, new Qe(this, e4, t4);
  }, He.prototype.close = q("close", function(e4) {
    return this._closed = true, this.emit("closed"), this._close(e4);
  }), He.prototype.info = q("info", function(e4) {
    var t4 = this;
    this._info(function(n4, r3) {
      if (n4)
        return e4(n4);
      r3.db_name = r3.db_name || t4.name, r3.auto_compaction = !(!t4.auto_compaction || oe(t4)), r3.adapter = t4.adapter, e4(null, r3);
    });
  }), He.prototype.id = q("id", function(e4) {
    return this._id(e4);
  }), He.prototype.type = function() {
    return typeof this._type == "function" ? this._type() : this.adapter;
  }, He.prototype.bulkDocs = q("bulkDocs", function(e4, t4, n4) {
    if (typeof t4 == "function" && (n4 = t4, t4 = {}), t4 = t4 || {}, Array.isArray(e4) && (e4 = { docs: e4 }), !e4 || !e4.docs || !Array.isArray(e4.docs))
      return n4(ee(N));
    for (var r3 = 0; r3 < e4.docs.length; ++r3)
      if (typeof e4.docs[r3] != "object" || Array.isArray(e4.docs[r3]))
        return n4(ee(Z));
    var i3;
    if (e4.docs.forEach(function(e5) {
      e5._attachments && Object.keys(e5._attachments).forEach(function(t5) {
        i3 = i3 || function(e6) {
          return e6.charAt(0) === "_" && e6 + " is not a valid attachment name, attachment names cannot start with '_'";
        }(t5), e5._attachments[t5].content_type || L("warn", "Attachment", t5, "on document", e5._id, "is missing content_type");
      });
    }), i3)
      return n4(ee(W, i3));
    "new_edits" in t4 || (t4.new_edits = !("new_edits" in e4) || e4.new_edits);
    var o2 = this;
    t4.new_edits || oe(o2) || e4.docs.sort(Xe), function(e5) {
      for (var t5 = 0; t5 < e5.length; t5++) {
        var n5 = e5[t5];
        if (n5._deleted)
          delete n5._attachments;
        else if (n5._attachments)
          for (var r4 = Object.keys(n5._attachments), i4 = 0; i4 < r4.length; i4++) {
            var o3 = r4[i4];
            n5._attachments[o3] = A(n5._attachments[o3], ["data", "digest", "content_type", "length", "revpos", "stub"]);
          }
      }
    }(e4.docs);
    var s2 = e4.docs.map(function(e5) {
      return e5._id;
    });
    return this._bulkDocs(e4, t4, function(e5, r4) {
      if (e5)
        return n4(e5);
      if (t4.new_edits || (r4 = r4.filter(function(e6) {
        return e6.error;
      })), !oe(o2))
        for (var i4 = 0, a2 = r4.length; i4 < a2; i4++)
          r4[i4].id = r4[i4].id || s2[i4];
      n4(null, r4);
    });
  }), He.prototype.registerDependentDatabase = q("registerDependentDatabase", function(e4, t4) {
    var n4 = O(this.__opts);
    this.__opts.view_adapter && (n4.adapter = this.__opts.view_adapter);
    var r3 = new this.constructor(e4, n4);
    pe(this, "_local/_pouch_dependentDbs", function(t5) {
      return t5.dependentDbs = t5.dependentDbs || {}, !t5.dependentDbs[e4] && (t5.dependentDbs[e4] = true, t5);
    }).then(function() {
      t4(null, { db: r3 });
    }).catch(t4);
  }), He.prototype.destroy = q("destroy", function(e4, t4) {
    typeof e4 == "function" && (t4 = e4, e4 = {});
    var n4 = this, r3 = !("use_prefix" in n4) || n4.use_prefix;
    function i3() {
      n4._destroy(e4, function(e5, r4) {
        if (e5)
          return t4(e5);
        n4._destroyed = true, n4.emit("destroyed"), t4(null, r4 || { ok: true });
      });
    }
    if (oe(n4))
      return i3();
    n4.get("_local/_pouch_dependentDbs", function(e5, o2) {
      if (e5)
        return e5.status !== 404 ? t4(e5) : i3();
      var s2 = o2.dependentDbs, a2 = n4.constructor, u2 = Object.keys(s2).map(function(e6) {
        var t5 = r3 ? e6.replace(new RegExp("^" + a2.prefix), "") : e6;
        return new a2(t5, n4.__opts).destroy();
      });
      Promise.all(u2).then(i3, t4);
    });
  }), et.prototype.execute = function() {
    var e4;
    if (this.failed)
      for (; e4 = this.queue.shift(); )
        e4(this.failed);
    else
      for (; e4 = this.queue.shift(); )
        e4();
  }, et.prototype.fail = function(e4) {
    this.failed = e4, this.execute();
  }, et.prototype.ready = function(e4) {
    this.isReady = true, this.db = e4, this.execute();
  }, et.prototype.addTask = function(e4) {
    this.queue.push(e4), this.failed && this.execute();
  }, p()(tt, He);
  var nt = typeof AbortController != "undefined" ? AbortController : function() {
    return { abort: function() {
    } };
  }, rt = fetch, it = Headers;
  tt.adapters = {}, tt.preferredAdapters = [], tt.prefix = "_pouch_";
  var ot = new (y())();
  function st(e4, t4) {
    for (var n4 = e4, r3 = 0, i3 = t4.length; r3 < i3 && (n4 = n4[t4[r3]]); r3++)
      ;
    return n4;
  }
  function at(e4) {
    for (var t4 = [], n4 = "", r3 = 0, i3 = e4.length; r3 < i3; r3++) {
      var o2 = e4[r3];
      r3 > 0 && e4[r3 - 1] === "\\" && (o2 === "$" || o2 === ".") ? n4 = n4.substring(0, n4.length - 1) + o2 : o2 === "." ? (t4.push(n4), n4 = "") : n4 += o2;
    }
    return t4.push(n4), t4;
  }
  !function(e4) {
    Object.keys(y().prototype).forEach(function(t5) {
      typeof y().prototype[t5] == "function" && (e4[t5] = ot[t5].bind(ot));
    });
    var t4 = e4._destructionListeners = new i2();
    e4.on("ref", function(e5) {
      t4.has(e5.name) || t4.set(e5.name, []), t4.get(e5.name).push(e5);
    }), e4.on("unref", function(e5) {
      if (t4.has(e5.name)) {
        var n4 = t4.get(e5.name), r3 = n4.indexOf(e5);
        r3 < 0 || (n4.splice(r3, 1), n4.length > 1 ? t4.set(e5.name, n4) : t4.delete(e5.name));
      }
    }), e4.on("destroyed", function(e5) {
      if (t4.has(e5)) {
        var n4 = t4.get(e5);
        t4.delete(e5), n4.forEach(function(e6) {
          e6.emit("destroyed", true);
        });
      }
    });
  }(tt), tt.adapter = function(e4, t4, n4) {
    t4.valid() && (tt.adapters[e4] = t4, n4 && tt.preferredAdapters.push(e4));
  }, tt.plugin = function(e4) {
    if (typeof e4 == "function")
      e4(tt);
    else {
      if (typeof e4 != "object" || Object.keys(e4).length === 0)
        throw new Error('Invalid plugin: got "' + e4 + '", expected an object or a function');
      Object.keys(e4).forEach(function(t4) {
        tt.prototype[t4] = e4[t4];
      });
    }
    return this.__defaults && (tt.__defaults = T({}, this.__defaults)), tt;
  }, tt.defaults = function(e4) {
    function t4(e5, n4) {
      if (!(this instanceof t4))
        return new t4(e5, n4);
      n4 = n4 || {}, e5 && typeof e5 == "object" && (e5 = (n4 = e5).name, delete n4.name), n4 = T({}, t4.__defaults, n4), tt.call(this, e5, n4);
    }
    return p()(t4, tt), t4.preferredAdapters = tt.preferredAdapters.slice(), Object.keys(tt).forEach(function(e5) {
      e5 in t4 || (t4[e5] = tt[e5]);
    }), t4.__defaults = T({}, this.__defaults, e4), t4;
  }, tt.fetch = function(e4, t4) {
    return rt(e4, t4);
  };
  var ut = ["$or", "$nor", "$not"];
  function ct(e4) {
    return ut.indexOf(e4) > -1;
  }
  function ft(e4) {
    return Object.keys(e4)[0];
  }
  function lt(e4) {
    var t4 = {}, n4 = { $or: true, $nor: true };
    return e4.forEach(function(e5) {
      Object.keys(e5).forEach(function(r3) {
        var i3 = e5[r3];
        if (typeof i3 != "object" && (i3 = { $eq: i3 }), ct(r3))
          if (i3 instanceof Array) {
            if (n4[r3])
              return n4[r3] = false, void (t4[r3] = i3);
            var o2 = [];
            t4[r3].forEach(function(e6) {
              Object.keys(i3).forEach(function(t5) {
                var n5 = i3[t5], r4 = Math.max(Object.keys(e6).length, Object.keys(n5).length), s3 = lt([e6, n5]);
                Object.keys(s3).length <= r4 || o2.push(s3);
              });
            }), t4[r3] = o2;
          } else
            t4[r3] = lt([i3]);
        else {
          var s2 = t4[r3] = t4[r3] || {};
          Object.keys(i3).forEach(function(e6) {
            var t5 = i3[e6];
            return e6 === "$gt" || e6 === "$gte" ? function(e7, t6, n5) {
              n5.$eq === void 0 && (n5.$gte !== void 0 ? e7 === "$gte" ? t6 > n5.$gte && (n5.$gte = t6) : t6 >= n5.$gte && (delete n5.$gte, n5.$gt = t6) : n5.$gt !== void 0 ? e7 === "$gte" ? t6 > n5.$gt && (delete n5.$gt, n5.$gte = t6) : t6 > n5.$gt && (n5.$gt = t6) : n5[e7] = t6);
            }(e6, t5, s2) : e6 === "$lt" || e6 === "$lte" ? function(e7, t6, n5) {
              n5.$eq === void 0 && (n5.$lte !== void 0 ? e7 === "$lte" ? t6 < n5.$lte && (n5.$lte = t6) : t6 <= n5.$lte && (delete n5.$lte, n5.$lt = t6) : n5.$lt !== void 0 ? e7 === "$lte" ? t6 < n5.$lt && (delete n5.$lt, n5.$lte = t6) : t6 < n5.$lt && (n5.$lt = t6) : n5[e7] = t6);
            }(e6, t5, s2) : e6 === "$ne" ? function(e7, t6) {
              "$ne" in t6 ? t6.$ne.push(e7) : t6.$ne = [e7];
            }(t5, s2) : e6 === "$eq" ? function(e7, t6) {
              delete t6.$gt, delete t6.$gte, delete t6.$lt, delete t6.$lte, delete t6.$ne, t6.$eq = e7;
            }(t5, s2) : e6 === "$regex" ? function(e7, t6) {
              "$regex" in t6 ? t6.$regex.push(e7) : t6.$regex = [e7];
            }(t5, s2) : void (s2[e6] = t5);
          });
        }
      });
    }), t4;
  }
  function dt(e4) {
    for (var t4 in e4) {
      if (Array.isArray(e4))
        for (var n4 in e4)
          e4[n4].$and && (e4[n4] = lt(e4[n4].$and));
      var r3 = e4[t4];
      typeof r3 == "object" && dt(r3);
    }
    return e4;
  }
  function ht(e4, t4) {
    for (var n4 in e4) {
      n4 === "$and" && (t4 = true);
      var r3 = e4[n4];
      typeof r3 == "object" && (t4 = ht(r3, t4));
    }
    return t4;
  }
  function pt(e4) {
    var t4 = O(e4), n4 = false;
    ht(t4, false) && ("$and" in (t4 = dt(t4)) && (t4 = lt(t4.$and)), n4 = true), ["$or", "$nor"].forEach(function(e5) {
      e5 in t4 && t4[e5].forEach(function(e6) {
        for (var t5 = Object.keys(e6), n5 = 0; n5 < t5.length; n5++) {
          var r4 = t5[n5], i4 = e6[r4];
          typeof i4 == "object" && i4 !== null || (e6[r4] = { $eq: i4 });
        }
      });
    }), "$not" in t4 && (t4.$not = lt([t4.$not]));
    for (var r3 = Object.keys(t4), i3 = 0; i3 < r3.length; i3++) {
      var o2 = r3[i3], s2 = t4[o2];
      typeof s2 != "object" || s2 === null ? s2 = { $eq: s2 } : n4 || ("$ne" in s2 && (s2.$ne = [s2.$ne]), "$regex" in s2 && (s2.$regex = [s2.$regex])), t4[o2] = s2;
    }
    return t4;
  }
  function vt(e4, t4) {
    if (e4 === t4)
      return 0;
    e4 = yt(e4), t4 = yt(t4);
    var n4 = bt(e4), r3 = bt(t4);
    if (n4 - r3 != 0)
      return n4 - r3;
    switch (typeof e4) {
      case "number":
        return e4 - t4;
      case "boolean":
        return e4 < t4 ? -1 : 1;
      case "string":
        return function(e5, t5) {
          return e5 === t5 ? 0 : e5 > t5 ? 1 : -1;
        }(e4, t4);
    }
    return Array.isArray(e4) ? function(e5, t5) {
      for (var n5 = Math.min(e5.length, t5.length), r4 = 0; r4 < n5; r4++) {
        var i3 = vt(e5[r4], t5[r4]);
        if (i3 !== 0)
          return i3;
      }
      return e5.length === t5.length ? 0 : e5.length > t5.length ? 1 : -1;
    }(e4, t4) : function(e5, t5) {
      for (var n5 = Object.keys(e5), r4 = Object.keys(t5), i3 = Math.min(n5.length, r4.length), o2 = 0; o2 < i3; o2++) {
        var s2 = vt(n5[o2], r4[o2]);
        if (s2 !== 0)
          return s2;
        if ((s2 = vt(e5[n5[o2]], t5[r4[o2]])) !== 0)
          return s2;
      }
      return n5.length === r4.length ? 0 : n5.length > r4.length ? 1 : -1;
    }(e4, t4);
  }
  function yt(e4) {
    switch (typeof e4) {
      case "undefined":
        return null;
      case "number":
        return e4 === 1 / 0 || e4 === -1 / 0 || isNaN(e4) ? null : e4;
      case "object":
        var t4 = e4;
        if (Array.isArray(e4)) {
          var n4 = e4.length;
          e4 = new Array(n4);
          for (var r3 = 0; r3 < n4; r3++)
            e4[r3] = yt(t4[r3]);
        } else {
          if (e4 instanceof Date)
            return e4.toJSON();
          if (e4 !== null) {
            for (var i3 in e4 = {}, t4)
              if (Object.prototype.hasOwnProperty.call(t4, i3)) {
                var o2 = t4[i3];
                o2 !== void 0 && (e4[i3] = yt(o2));
              }
          }
        }
    }
    return e4;
  }
  function gt(e4) {
    return bt(e4 = yt(e4)) + "" + function(e5) {
      if (e5 !== null)
        switch (typeof e5) {
          case "boolean":
            return e5 ? 1 : 0;
          case "number":
            return function(e6) {
              if (e6 === 0)
                return "1";
              var t5, n5 = e6.toExponential().split(/e\+?/), r4 = parseInt(n5[1], 10), i4 = e6 < 0, o3 = i4 ? "0" : "2";
              o3 += "" + (function(e7, t6, n6) {
                for (var r5 = "", i5 = 3 - e7.length; r5.length < i5; )
                  r5 += "0";
                return r5;
              }(t5 = ((i4 ? -r4 : r4) - -324).toString()) + t5);
              var s3 = Math.abs(parseFloat(n5[0]));
              i4 && (s3 = 10 - s3);
              var a2 = s3.toFixed(20);
              return o3 + "" + a2.replace(/\.?0+$/, "");
            }(e5);
          case "string":
            return e5.replace(/\u0002/g, "").replace(/\u0001/g, "").replace(/\u0000/g, "");
          case "object":
            var t4 = Array.isArray(e5), n4 = t4 ? e5 : Object.keys(e5), r3 = -1, i3 = n4.length, o2 = "";
            if (t4)
              for (; ++r3 < i3; )
                o2 += gt(n4[r3]);
            else
              for (; ++r3 < i3; ) {
                var s2 = n4[r3];
                o2 += gt(s2) + gt(e5[s2]);
              }
            return o2;
        }
      return "";
    }(e4) + "\0";
  }
  function _t(e4, t4) {
    var n4, r3 = t4;
    if (e4[t4] === "1")
      n4 = 0, t4++;
    else {
      var i3 = e4[t4] === "0";
      t4++;
      var o2 = "", s2 = e4.substring(t4, t4 + 3), a2 = parseInt(s2, 10) + -324;
      for (i3 && (a2 = -a2), t4 += 3; ; ) {
        var u2 = e4[t4];
        if (u2 === "\0")
          break;
        o2 += u2, t4++;
      }
      n4 = (o2 = o2.split(".")).length === 1 ? parseInt(o2, 10) : parseFloat(o2[0] + "." + o2[1]), i3 && (n4 -= 10), a2 !== 0 && (n4 = parseFloat(n4 + "e" + a2));
    }
    return { num: n4, length: t4 - r3 };
  }
  function mt(e4, t4) {
    var n4 = e4.pop();
    if (t4.length) {
      var r3 = t4[t4.length - 1];
      n4 === r3.element && (t4.pop(), r3 = t4[t4.length - 1]);
      var i3 = r3.element, o2 = r3.index;
      Array.isArray(i3) ? i3.push(n4) : o2 === e4.length - 2 ? i3[e4.pop()] = n4 : e4.push(n4);
    }
  }
  function bt(e4) {
    var t4 = ["boolean", "number", "string", "object"].indexOf(typeof e4);
    return ~t4 ? e4 === null ? 1 : Array.isArray(e4) ? 5 : t4 < 3 ? t4 + 2 : t4 + 3 : Array.isArray(e4) ? 5 : void 0;
  }
  function wt(e4, t4, n4) {
    return n4.every(function(n5) {
      var r3 = t4[n5], i3 = at(n5), o2 = st(e4, i3);
      return ct(n5) ? function(e5, t5, n6) {
        return e5 === "$or" ? t5.some(function(e6) {
          return wt(n6, e6, Object.keys(e6));
        }) : e5 === "$not" ? !wt(n6, t5, Object.keys(t5)) : !t5.find(function(e6) {
          return wt(n6, e6, Object.keys(e6));
        });
      }(n5, r3, e4) : kt(r3, e4, i3, o2);
    });
  }
  function kt(e4, t4, n4, r3) {
    return !e4 || (typeof e4 == "object" ? Object.keys(e4).every(function(i3) {
      var o2 = e4[i3];
      if (i3.indexOf("$") === 0)
        return jt(i3, t4, o2, n4, r3);
      var s2 = at(i3);
      if (r3 === void 0 && typeof o2 != "object" && s2.length > 0)
        return false;
      var a2 = st(r3, s2);
      return typeof o2 == "object" ? kt(o2, t4, n4, a2) : jt("$eq", t4, o2, s2, a2);
    }) : e4 === r3);
  }
  function jt(e4, t4, n4, r3, i3) {
    if (!qt[e4])
      throw new Error('unknown operator "' + e4 + '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, $nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
    return qt[e4](t4, n4, r3, i3);
  }
  function Ot(e4) {
    return e4 != null;
  }
  function $t(e4) {
    return e4 !== void 0;
  }
  function xt(e4, t4) {
    return t4.some(function(t5) {
      return e4 instanceof Array ? e4.some(function(e5) {
        return vt(t5, e5) === 0;
      }) : vt(t5, e4) === 0;
    });
  }
  var qt = { $elemMatch: function(e4, t4, n4, r3) {
    return !!Array.isArray(r3) && r3.length !== 0 && (typeof r3[0] == "object" ? r3.some(function(e5) {
      return wt(e5, t4, Object.keys(t4));
    }) : r3.some(function(r4) {
      return kt(t4, e4, n4, r4);
    }));
  }, $allMatch: function(e4, t4, n4, r3) {
    return !!Array.isArray(r3) && r3.length !== 0 && (typeof r3[0] == "object" ? r3.every(function(e5) {
      return wt(e5, t4, Object.keys(t4));
    }) : r3.every(function(r4) {
      return kt(t4, e4, n4, r4);
    }));
  }, $eq: function(e4, t4, n4, r3) {
    return $t(r3) && vt(r3, t4) === 0;
  }, $gte: function(e4, t4, n4, r3) {
    return $t(r3) && vt(r3, t4) >= 0;
  }, $gt: function(e4, t4, n4, r3) {
    return $t(r3) && vt(r3, t4) > 0;
  }, $lte: function(e4, t4, n4, r3) {
    return $t(r3) && vt(r3, t4) <= 0;
  }, $lt: function(e4, t4, n4, r3) {
    return $t(r3) && vt(r3, t4) < 0;
  }, $exists: function(e4, t4, n4, r3) {
    return t4 ? $t(r3) : !$t(r3);
  }, $mod: function(e4, t4, n4, r3) {
    return Ot(r3) && function(e5, t5) {
      return typeof e5 == "number" && parseInt(e5, 10) === e5 && e5 % t5[0] === t5[1];
    }(r3, t4);
  }, $ne: function(e4, t4, n4, r3) {
    return t4.every(function(e5) {
      return vt(r3, e5) !== 0;
    });
  }, $in: function(e4, t4, n4, r3) {
    return Ot(r3) && xt(r3, t4);
  }, $nin: function(e4, t4, n4, r3) {
    return Ot(r3) && !xt(r3, t4);
  }, $size: function(e4, t4, n4, r3) {
    return Ot(r3) && Array.isArray(r3) && function(e5, t5) {
      return e5.length === t5;
    }(r3, t4);
  }, $all: function(e4, t4, n4, r3) {
    return Array.isArray(r3) && function(e5, t5) {
      return t5.every(function(t6) {
        return e5.some(function(e6) {
          return vt(t6, e6) === 0;
        });
      });
    }(r3, t4);
  }, $regex: function(e4, t4, n4, r3) {
    return Ot(r3) && typeof r3 == "string" && t4.every(function(e5) {
      return function(e6, t5) {
        return new RegExp(t5).test(e6);
      }(r3, e5);
    });
  }, $type: function(e4, t4, n4, r3) {
    return function(e5, t5) {
      switch (t5) {
        case "null":
          return e5 === null;
        case "boolean":
          return typeof e5 == "boolean";
        case "number":
          return typeof e5 == "number";
        case "string":
          return typeof e5 == "string";
        case "array":
          return e5 instanceof Array;
        case "object":
          return {}.toString.call(e5) === "[object Object]";
      }
    }(r3, t4);
  } };
  function At(e4, t4) {
    if (e4.selector && e4.filter && e4.filter !== "_selector") {
      var n4 = typeof e4.filter == "string" ? e4.filter : "function";
      return t4(new Error('selector invalid for filter "' + n4 + '"'));
    }
    t4();
  }
  function St(e4) {
    e4.view && !e4.filter && (e4.filter = "_view"), e4.selector && !e4.filter && (e4.filter = "_selector"), e4.filter && typeof e4.filter == "string" && (e4.filter === "_view" ? e4.view = ae(e4.view) : e4.filter = ae(e4.filter));
  }
  function Et(e4, t4) {
    return t4.filter && typeof t4.filter == "string" && !t4.doc_ids && !oe(e4.db);
  }
  function Pt(e4, t4) {
    var n4 = t4.complete;
    if (t4.filter === "_view") {
      if (!t4.view || typeof t4.view != "string") {
        var r3 = ee(W, "`view` filter parameter not found or invalid.");
        return n4(r3);
      }
      var i3 = se(t4.view);
      e4.db.get("_design/" + i3[0], function(r4, o3) {
        if (e4.isCancelled)
          return n4(null, { status: "cancelled" });
        if (r4)
          return n4(te(r4));
        var s2 = o3 && o3.views && o3.views[i3[1]] && o3.views[i3[1]].map;
        if (!s2)
          return n4(ee(R, o3.views ? "missing json key: " + i3[1] : "missing json key: views"));
        t4.filter = he(["return function(doc) {", '  "use strict";', "  var emitted = false;", "  var emit = function (a, b) {", "    emitted = true;", "  };", "  var view = " + s2 + ";", "  view(doc);", "  if (emitted) {", "    return true;", "  }", "};"].join("\n"), {}), e4.doChanges(t4);
      });
    } else if (t4.selector)
      t4.filter = function(e5) {
        return function(e6, t5) {
          if (typeof t5 != "object")
            throw new Error("Selector error: expected a JSON object");
          var n5 = function(e7, t6, n6) {
            if (e7 = e7.filter(function(e8) {
              return wt(e8.doc, t6.selector, n6);
            }), t6.sort) {
              var r4 = function(e8) {
                function t7(t8) {
                  return e8.map(function(e9) {
                    var n7 = at(ft(e9));
                    return st(t8, n7);
                  });
                }
                return function(e9, n7) {
                  var r5, i5, o4 = vt(t7(e9.doc), t7(n7.doc));
                  return o4 !== 0 ? o4 : (r5 = e9.doc._id) < (i5 = n7.doc._id) ? -1 : r5 > i5 ? 1 : 0;
                };
              }(t6.sort);
              e7 = e7.sort(r4), typeof t6.sort[0] != "string" && (i4 = t6.sort[0])[ft(i4)] === "desc" && (e7 = e7.reverse());
            }
            var i4;
            if ("limit" in t6 || "skip" in t6) {
              var o3 = t6.skip || 0, s2 = ("limit" in t6 ? t6.limit : e7.length) + o3;
              e7 = e7.slice(o3, s2);
            }
            return e7;
          }([{ doc: e6 }], { selector: t5 = pt(t5) }, Object.keys(t5));
          return n5 && n5.length === 1;
        }(e5, t4.selector);
      }, e4.doChanges(t4);
    else {
      var o2 = se(t4.filter);
      e4.db.get("_design/" + o2[0], function(r4, i4) {
        if (e4.isCancelled)
          return n4(null, { status: "cancelled" });
        if (r4)
          return n4(te(r4));
        var s2 = i4 && i4.filters && i4.filters[o2[1]];
        if (!s2)
          return n4(ee(R, i4 && i4.filters ? "missing json key: " + o2[1] : "missing json key: filters"));
        t4.filter = he('"use strict";\nreturn ' + s2 + ";", {}), e4.doChanges(t4);
      });
    }
  }
  function Ct(e4) {
    return e4.reduce(function(e5, t4) {
      return e5[t4] = true, e5;
    }, {});
  }
  tt.plugin(function(e4) {
    e4._changesFilterPlugin = { validate: At, normalize: St, shouldFilter: Et, filter: Pt };
  }), tt.version = "7.3.0";
  var Dt = Ct(["_id", "_rev", "_access", "_attachments", "_deleted", "_revisions", "_revs_info", "_conflicts", "_deleted_conflicts", "_local_seq", "_rev_tree", "_replication_id", "_replication_state", "_replication_state_time", "_replication_state_reason", "_replication_stats", "_removed"]), Lt = Ct(["_access", "_attachments", "_replication_id", "_replication_state", "_replication_state_time", "_replication_state_reason", "_replication_stats"]);
  function Bt(e4) {
    if (!/^\d+-/.test(e4))
      return ee(Y);
    var t4 = e4.indexOf("-"), n4 = e4.substring(0, t4), r3 = e4.substring(t4 + 1);
    return { prefix: parseInt(n4, 10), id: r3 };
  }
  function It(e4, t4, n4) {
    var r3, i3, o2;
    n4 || (n4 = { deterministic_revs: true });
    var s2 = { status: "available" };
    if (e4._deleted && (s2.deleted = true), t4)
      if (e4._id || (e4._id = Ee()), i3 = Se(e4, n4.deterministic_revs), e4._rev) {
        if ((o2 = Bt(e4._rev)).error)
          return o2;
        e4._rev_tree = [{ pos: o2.prefix, ids: [o2.id, { status: "missing" }, [[i3, s2, []]]] }], r3 = o2.prefix + 1;
      } else
        e4._rev_tree = [{ pos: 1, ids: [i3, s2, []] }], r3 = 1;
    else if (e4._revisions && (e4._rev_tree = function(e5, t5) {
      for (var n5 = e5.start - e5.ids.length + 1, r4 = e5.ids, i4 = [r4[0], t5, []], o3 = 1, s3 = r4.length; o3 < s3; o3++)
        i4 = [r4[o3], { status: "missing" }, [i4]];
      return [{ pos: n5, ids: i4 }];
    }(e4._revisions, s2), r3 = e4._revisions.start, i3 = e4._revisions.ids[0]), !e4._rev_tree) {
      if ((o2 = Bt(e4._rev)).error)
        return o2;
      r3 = o2.prefix, i3 = o2.id, e4._rev_tree = [{ pos: r3, ids: [i3, s2, []] }];
    }
    ie(e4._id), e4._rev = r3 + "-" + i3;
    var a2 = { metadata: {}, data: {} };
    for (var u2 in e4)
      if (Object.prototype.hasOwnProperty.call(e4, u2)) {
        var c2 = u2[0] === "_";
        if (c2 && !Dt[u2]) {
          var f2 = ee(G, u2);
          throw f2.message = G.message + ": " + u2, f2;
        }
        c2 && !Lt[u2] ? a2.metadata[u2.slice(1)] = e4[u2] : a2.data[u2] = e4[u2];
      }
    return a2;
  }
  function Tt(e4, t4, n4) {
    if (e4.stub)
      return n4();
    typeof e4.data == "string" ? function(e5, t5, n5) {
      var r3 = function(e6) {
        try {
          return ve(e6);
        } catch (e7) {
          return { error: ee(V, "Attachment is not a valid base64 string") };
        }
      }(e5.data);
      if (r3.error)
        return n5(r3.error);
      e5.length = r3.length, e5.data = t5 === "blob" ? me(r3, e5.content_type) : t5 === "base64" ? ye(r3) : r3, qe(r3, function(t6) {
        e5.digest = "md5-" + t6, n5();
      });
    }(e4, t4, n4) : function(e5, t5, n5) {
      qe(e5.data, function(r3) {
        e5.digest = "md5-" + r3, e5.length = e5.data.size || e5.data.length || 0, t5 === "binary" ? ke(e5.data, function(t6) {
          e5.data = t6, n5();
        }) : t5 === "base64" ? je(e5.data, function(t6) {
          e5.data = t6, n5();
        }) : n5();
      });
    }(e4, t4, n4);
  }
  function Mt(e4, t4, n4, r3, o2, s2, a2, u2, c2) {
    e4 = e4 || 1e3;
    var f2 = u2.new_edits, l2 = new i2(), d2 = 0, h2 = t4.length;
    function p2() {
      ++d2 === h2 && c2 && c2();
    }
    t4.forEach(function(e5, t5) {
      if (e5._id && Ve(e5._id)) {
        var r4 = e5._deleted ? "_removeLocal" : "_putLocal";
        n4[r4](e5, { ctx: o2 }, function(e6, n5) {
          s2[t5] = e6 || n5, p2();
        });
      } else {
        var i3 = e5.metadata.id;
        l2.has(i3) ? (h2--, l2.get(i3).push([e5, t5])) : l2.set(i3, [[e5, t5]]);
      }
    }), l2.forEach(function(t5, n5) {
      var i3 = 0;
      function o3() {
        ++i3 < t5.length ? c3() : p2();
      }
      function c3() {
        var c4 = t5[i3], l3 = c4[0], d3 = c4[1];
        if (r3.has(n5))
          !function(e5, t6, n6, r4, i4, o4, s3, a3) {
            if (function(e6, t7) {
              for (var n7, r5 = e6.slice(), i5 = t7.split("-"), o5 = parseInt(i5[0], 10), s4 = i5[1]; n7 = r5.pop(); ) {
                if (n7.pos === o5 && n7.ids[0] === s4)
                  return true;
                for (var a4 = n7.ids[2], u4 = 0, c6 = a4.length; u4 < c6; u4++)
                  r5.push({ pos: n7.pos + 1, ids: a4[u4] });
              }
              return false;
            }(t6.rev_tree, n6.metadata.rev) && !a3)
              return r4[i4] = n6, o4();
            var u3 = t6.winningRev || Pe(t6), c5 = "deleted" in t6 ? t6.deleted : Ke(t6, u3), f3 = "deleted" in n6.metadata ? n6.metadata.deleted : Ke(n6.metadata), l4 = /^1-/.test(n6.metadata.rev);
            if (c5 && !f3 && a3 && l4) {
              var d4 = n6.data;
              d4._rev = u3, d4._id = n6.metadata.id, n6 = It(d4, a3);
            }
            var h4 = ze(t6.rev_tree, n6.metadata.rev_tree[0], e5);
            if (a3 && (c5 && f3 && h4.conflicts !== "new_leaf" || !c5 && h4.conflicts !== "new_leaf" || c5 && !f3 && h4.conflicts === "new_branch")) {
              var p3 = ee(F);
              return r4[i4] = p3, o4();
            }
            var v2 = n6.metadata.rev;
            n6.metadata.rev_tree = h4.tree, n6.stemmedRevs = h4.stemmedRevs || [], t6.rev_map && (n6.metadata.rev_map = t6.rev_map);
            var y2 = Pe(n6.metadata), g2 = Ke(n6.metadata, y2), _2 = c5 === g2 ? 0 : c5 < g2 ? -1 : 1;
            s3(n6, y2, g2, v2 === y2 ? g2 : Ke(n6.metadata, v2), true, _2, i4, o4);
          }(e4, r3.get(n5), l3, s2, d3, o3, a2, f2);
        else {
          var h3 = ze([], l3.metadata.rev_tree[0], e4);
          l3.metadata.rev_tree = h3.tree, l3.stemmedRevs = h3.stemmedRevs || [], function(e5, t6, n6) {
            var r4 = Pe(e5.metadata), i4 = Ke(e5.metadata, r4);
            if ("was_delete" in u2 && i4)
              return s2[t6] = ee(R, "deleted"), n6();
            var o4 = f2 && function(e6) {
              return e6.metadata.rev_tree[0].ids[1].status === "missing";
            }(e5);
            if (o4) {
              var c5 = ee(F);
              return s2[t6] = c5, n6();
            }
            a2(e5, r4, i4, i4, false, i4 ? 0 : 1, t6, n6);
          }(l3, d3, o3);
        }
      }
      c3();
    });
  }
  var Nt = "document-store", Rt = "by-sequence", Ft = "attach-store", Ut = "attach-seq-store", zt = "meta-store", Jt = "local-store", Kt = "detect-blob-support";
  function Vt(e4) {
    try {
      return JSON.stringify(e4);
    } catch (t4) {
      return f.stringify(e4);
    }
  }
  function Qt(e4) {
    return function(t4) {
      var n4 = "unknown_error";
      t4.target && t4.target.error && (n4 = t4.target.error.name || t4.target.error.message), e4(ee(X, n4, t4.type));
    };
  }
  function Gt(e4, t4, n4) {
    return { data: Vt(e4), winningRev: t4, deletedOrLocal: n4 ? "1" : "0", seq: e4.seq, id: e4.id };
  }
  function Wt(e4) {
    if (!e4)
      return null;
    var t4 = function(e5) {
      try {
        return JSON.parse(e5);
      } catch (t5) {
        return f.parse(e5);
      }
    }(e4.data);
    return t4.winningRev = e4.winningRev, t4.deleted = e4.deletedOrLocal === "1", t4.seq = e4.seq, t4;
  }
  function Zt(e4) {
    if (!e4)
      return e4;
    var t4 = e4._doc_id_rev.lastIndexOf(":");
    return e4._id = e4._doc_id_rev.substring(0, t4 - 1), e4._rev = e4._doc_id_rev.substring(t4 + 1), delete e4._doc_id_rev, e4;
  }
  function Xt(e4, t4, n4, r3) {
    n4 ? r3(e4 ? typeof e4 != "string" ? e4 : be(e4, t4) : ge([""], { type: t4 })) : e4 ? typeof e4 != "string" ? we(e4, function(e5) {
      r3(ye(e5));
    }) : r3(e4) : r3("");
  }
  function Yt(e4, t4, n4, r3) {
    var i3 = Object.keys(e4._attachments || {});
    if (!i3.length)
      return r3 && r3();
    var o2 = 0;
    function s2() {
      ++o2 === i3.length && r3 && r3();
    }
    i3.forEach(function(r4) {
      t4.attachments && t4.include_docs ? function(e5, t5) {
        var r5 = e5._attachments[t5], i4 = r5.digest;
        n4.objectStore(Ft).get(i4).onsuccess = function(e6) {
          r5.body = e6.target.result.body, s2();
        };
      }(e4, r4) : (e4._attachments[r4].stub = true, s2());
    });
  }
  function Ht(e4, t4) {
    return Promise.all(e4.map(function(e5) {
      if (e5.doc && e5.doc._attachments) {
        var n4 = Object.keys(e5.doc._attachments);
        return Promise.all(n4.map(function(n5) {
          var r3 = e5.doc._attachments[n5];
          if ("body" in r3) {
            var i3 = r3.body, o2 = r3.content_type;
            return new Promise(function(s2) {
              Xt(i3, o2, t4, function(t5) {
                e5.doc._attachments[n5] = T(A(r3, ["digest", "content_type"]), { data: t5 }), s2();
              });
            });
          }
        }));
      }
    }));
  }
  function en(e4, t4, n4) {
    var r3 = [], i3 = n4.objectStore(Rt), o2 = n4.objectStore(Ft), s2 = n4.objectStore(Ut), a2 = e4.length;
    function u2() {
      --a2 || r3.length && r3.forEach(function(e5) {
        s2.index("digestSeq").count(IDBKeyRange.bound(e5 + "::", e5 + "::\uFFFF", false, false)).onsuccess = function(t5) {
          t5.target.result || o2.delete(e5);
        };
      });
    }
    e4.forEach(function(e5) {
      var n5 = i3.index("_doc_id_rev"), o3 = t4 + "::" + e5;
      n5.getKey(o3).onsuccess = function(e6) {
        var t5 = e6.target.result;
        if (typeof t5 != "number")
          return u2();
        i3.delete(t5), s2.index("seq").openCursor(IDBKeyRange.only(t5)).onsuccess = function(e7) {
          var t6 = e7.target.result;
          if (t6) {
            var n6 = t6.value.digestSeq.split("::")[0];
            r3.push(n6), s2.delete(t6.primaryKey), t6.continue();
          } else
            u2();
        };
      };
    });
  }
  function tn(e4, t4, n4) {
    try {
      return { txn: e4.transaction(t4, n4) };
    } catch (e5) {
      return { error: e5 };
    }
  }
  var nn = new D();
  function rn(e4, t4, n4, r3, o2, s2) {
    for (var a2, u2, c2, f2, l2, d2, h2, p2, v2 = t4.docs, y2 = 0, g2 = v2.length; y2 < g2; y2++) {
      var _2 = v2[y2];
      _2._id && Ve(_2._id) || (_2 = v2[y2] = It(_2, n4.new_edits, e4)).error && !h2 && (h2 = _2);
    }
    if (h2)
      return s2(h2);
    var m2 = false, b2 = 0, w2 = new Array(v2.length), k2 = new i2(), j2 = false, O2 = r3._meta.blobSupport ? "blob" : "base64";
    function $2() {
      m2 = true, x2();
    }
    function x2() {
      p2 && m2 && (p2.docCount += b2, d2.put(p2));
    }
    function q2() {
      j2 || (nn.notify(r3._meta.name), s2(null, w2));
    }
    function A2(e5, t5, n5, r4, i3, o3, s3, a3) {
      e5.metadata.winningRev = t5, e5.metadata.deleted = n5;
      var u3 = e5.data;
      if (u3._id = e5.metadata.id, u3._rev = e5.metadata.rev, r4 && (u3._deleted = true), u3._attachments && Object.keys(u3._attachments).length)
        return function(e6, t6, n6, r5, i4, o4) {
          var s4 = e6.data, a4 = 0, u4 = Object.keys(s4._attachments);
          function c3() {
            a4 === u4.length && S2(e6, t6, n6, r5, i4, o4);
          }
          function l3() {
            a4++, c3();
          }
          u4.forEach(function(n7) {
            var r6 = e6.data._attachments[n7];
            if (r6.stub)
              a4++, c3();
            else {
              var i5 = r6.data;
              delete r6.data, r6.revpos = parseInt(t6, 10), function(e7, t7, n8) {
                f2.count(e7).onsuccess = function(r7) {
                  if (r7.target.result)
                    return n8();
                  var i6 = { digest: e7, body: t7 };
                  f2.put(i6).onsuccess = n8;
                };
              }(r6.digest, i5, l3);
            }
          });
        }(e5, t5, n5, i3, s3, a3);
      b2 += o3, x2(), S2(e5, t5, n5, i3, s3, a3);
    }
    function S2(e5, t5, n5, i3, o3, s3) {
      var f3 = e5.data, d3 = e5.metadata;
      function h3(o4) {
        var s4 = e5.stemmedRevs || [];
        i3 && r3.auto_compaction && (s4 = s4.concat(function(e6) {
          var t6 = [];
          return Ce(e6.rev_tree, function(e7, n6, r4, i4, o5) {
            o5.status !== "available" || e7 || (t6.push(n6 + "-" + r4), o5.status = "missing");
          }), t6;
        }(e5.metadata))), s4 && s4.length && en(s4, e5.metadata.id, a2), d3.seq = o4.target.result;
        var c3 = Gt(d3, t5, n5);
        u2.put(c3).onsuccess = p3;
      }
      function p3() {
        w2[o3] = { ok: true, id: d3.id, rev: d3.rev }, k2.set(e5.metadata.id, e5.metadata), function(e6, t6, n6) {
          var r4 = 0, i4 = Object.keys(e6.data._attachments || {});
          if (!i4.length)
            return n6();
          function o4() {
            ++r4 === i4.length && n6();
          }
          function s4(n7) {
            var r5 = e6.data._attachments[n7].digest, i5 = l2.put({ seq: t6, digestSeq: r5 + "::" + t6 });
            i5.onsuccess = o4, i5.onerror = function(e7) {
              e7.preventDefault(), e7.stopPropagation(), o4();
            };
          }
          for (var a3 = 0; a3 < i4.length; a3++)
            s4(i4[a3]);
        }(e5, d3.seq, s3);
      }
      f3._doc_id_rev = d3.id + "::" + d3.rev, delete f3._id, delete f3._rev;
      var v3 = c2.put(f3);
      v3.onsuccess = h3, v3.onerror = function(e6) {
        e6.preventDefault(), e6.stopPropagation(), c2.index("_doc_id_rev").getKey(f3._doc_id_rev).onsuccess = function(e7) {
          c2.put(f3, e7.target.result).onsuccess = h3;
        };
      };
    }
    !function(e5, t5, n5) {
      if (!e5.length)
        return n5();
      var r4, i3 = 0;
      function o3() {
        i3++, e5.length === i3 && (r4 ? n5(r4) : n5());
      }
      e5.forEach(function(e6) {
        var n6 = e6.data && e6.data._attachments ? Object.keys(e6.data._attachments) : [], i4 = 0;
        if (!n6.length)
          return o3();
        function s3(e7) {
          r4 = e7, ++i4 === n6.length && o3();
        }
        for (var a3 in e6.data._attachments)
          Object.prototype.hasOwnProperty.call(e6.data._attachments, a3) && Tt(e6.data._attachments[a3], t5, s3);
      });
    }(v2, O2, function(t5) {
      if (t5)
        return s2(t5);
      !function() {
        var t6 = tn(o2, [Nt, Rt, Ft, Jt, Ut, zt], "readwrite");
        if (t6.error)
          return s2(t6.error);
        (a2 = t6.txn).onabort = Qt(s2), a2.ontimeout = Qt(s2), a2.oncomplete = q2, u2 = a2.objectStore(Nt), c2 = a2.objectStore(Rt), f2 = a2.objectStore(Ft), l2 = a2.objectStore(Ut), (d2 = a2.objectStore(zt)).get(zt).onsuccess = function(e5) {
          p2 = e5.target.result, x2();
        }, function(e5) {
          var t7 = [];
          if (v2.forEach(function(e6) {
            e6.data && e6.data._attachments && Object.keys(e6.data._attachments).forEach(function(n6) {
              var r5 = e6.data._attachments[n6];
              r5.stub && t7.push(r5.digest);
            });
          }), !t7.length)
            return e5();
          var n5, r4 = 0;
          t7.forEach(function(i3) {
            !function(e6, t8) {
              f2.get(e6).onsuccess = function(n6) {
                if (n6.target.result)
                  t8();
                else {
                  var r5 = ee(H, "unknown stub attachment with digest " + e6);
                  r5.status = 412, t8(r5);
                }
              };
            }(i3, function(i4) {
              i4 && !n5 && (n5 = i4), ++r4 === t7.length && e5(n5);
            });
          });
        }(function(t7) {
          if (t7)
            return j2 = true, s2(t7);
          !function() {
            if (v2.length)
              for (var t8 = 0, i3 = 0, o3 = v2.length; i3 < o3; i3++) {
                var s3 = v2[i3];
                s3._id && Ve(s3._id) ? c3() : u2.get(s3.metadata.id).onsuccess = f3;
              }
            function c3() {
              ++t8 === v2.length && Mt(e4.revs_limit, v2, r3, k2, a2, w2, A2, n4, $2);
            }
            function f3(e5) {
              var t9 = Wt(e5.target.result);
              t9 && k2.set(t9.id, t9), c3();
            }
          }();
        });
      }();
    });
  }
  function on(e4, t4, n4, r3, i3) {
    var o2, s2, a2;
    function u2(e5) {
      s2 = e5.target.result, o2 && i3(o2, s2, a2);
    }
    function c2(e5) {
      o2 = e5.target.result, s2 && i3(o2, s2, a2);
    }
    function f2(e5) {
      var t5 = e5.target.result;
      if (!t5)
        return i3();
      i3([t5.key], [t5.value], t5);
    }
    r3 === -1 && (r3 = 1e3), typeof e4.getAll == "function" && typeof e4.getAllKeys == "function" && r3 > 1 && !n4 ? (a2 = { continue: function() {
      if (!o2.length)
        return i3();
      var n5, a3 = o2[o2.length - 1];
      if (t4 && t4.upper)
        try {
          n5 = IDBKeyRange.bound(a3, t4.upper, true, t4.upperOpen);
        } catch (e5) {
          if (e5.name === "DataError" && e5.code === 0)
            return i3();
        }
      else
        n5 = IDBKeyRange.lowerBound(a3, true);
      t4 = n5, o2 = null, s2 = null, e4.getAll(t4, r3).onsuccess = u2, e4.getAllKeys(t4, r3).onsuccess = c2;
    } }, e4.getAll(t4, r3).onsuccess = u2, e4.getAllKeys(t4, r3).onsuccess = c2) : n4 ? e4.openCursor(t4, "prev").onsuccess = f2 : e4.openCursor(t4).onsuccess = f2;
  }
  function sn(e4, t4, n4) {
    var r3, i3, o2 = "startkey" in e4 && e4.startkey, s2 = "endkey" in e4 && e4.endkey, a2 = "key" in e4 && e4.key, u2 = "keys" in e4 && e4.keys, c2 = e4.skip || 0, f2 = typeof e4.limit == "number" ? e4.limit : -1, l2 = e4.inclusive_end !== false;
    if (!u2 && (r3 = function(e5, t5, n5, r4, i4) {
      try {
        if (e5 && t5)
          return i4 ? IDBKeyRange.bound(t5, e5, !n5, false) : IDBKeyRange.bound(e5, t5, false, !n5);
        if (e5)
          return i4 ? IDBKeyRange.upperBound(e5) : IDBKeyRange.lowerBound(e5);
        if (t5)
          return i4 ? IDBKeyRange.lowerBound(t5, !n5) : IDBKeyRange.upperBound(t5, !n5);
        if (r4)
          return IDBKeyRange.only(r4);
      } catch (e6) {
        return { error: e6 };
      }
      return null;
    }(o2, s2, l2, a2, e4.descending), (i3 = r3 && r3.error) && (i3.name !== "DataError" || i3.code !== 0)))
      return n4(ee(X, i3.name, i3.message));
    var d2 = [Nt, Rt, zt];
    e4.attachments && d2.push(Ft);
    var h2 = tn(t4, d2, "readonly");
    if (h2.error)
      return n4(h2.error);
    var p2 = h2.txn;
    p2.oncomplete = function() {
      e4.attachments ? Ht(w2, e4.binary).then($2) : $2();
    }, p2.onabort = Qt(n4);
    var v2, y2, g2 = p2.objectStore(Nt), _2 = p2.objectStore(Rt), m2 = p2.objectStore(zt), b2 = _2.index("_doc_id_rev"), w2 = [];
    function k2(t5, n5) {
      var r4 = { id: n5.id, key: n5.id, value: { rev: t5 } };
      n5.deleted ? u2 && (w2.push(r4), r4.value.deleted = true, r4.doc = null) : c2-- <= 0 && (w2.push(r4), e4.include_docs && function(t6, n6, r5) {
        var i4 = t6.id + "::" + r5;
        b2.get(i4).onsuccess = function(r6) {
          if (n6.doc = Zt(r6.target.result) || {}, e4.conflicts) {
            var i5 = Be(t6);
            i5.length && (n6.doc._conflicts = i5);
          }
          Yt(n6.doc, e4, p2);
        };
      }(n5, r4, t5));
    }
    function j2(e5) {
      for (var t5 = 0, n5 = e5.length; t5 < n5 && w2.length !== f2; t5++) {
        var r4 = e5[t5];
        if (r4.error && u2)
          w2.push(r4);
        else {
          var i4 = Wt(r4);
          k2(i4.winningRev, i4);
        }
      }
    }
    function O2(e5, t5, n5) {
      n5 && (j2(t5), w2.length < f2 && n5.continue());
    }
    function $2() {
      var t5 = { total_rows: v2, offset: e4.skip, rows: w2 };
      e4.update_seq && y2 !== void 0 && (t5.update_seq = y2), n4(null, t5);
    }
    return m2.get(zt).onsuccess = function(e5) {
      v2 = e5.target.result.docCount;
    }, e4.update_seq && (_2.openCursor(null, "prev").onsuccess = function(e5) {
      var t5 = e5.target.result, n5 = void 0;
      return t5 && t5.key && (n5 = t5.key), function(e6) {
        e6.target.result && e6.target.result.length > 0 && (y2 = e6.target.result[0]);
      }({ target: { result: [n5] } });
    }), i3 || f2 === 0 ? void 0 : u2 ? function(e5, t5, n5) {
      var r4 = new Array(e5.length), i4 = 0;
      e5.forEach(function(o3, s3) {
        t5.get(o3).onsuccess = function(t6) {
          t6.target.result ? r4[s3] = t6.target.result : r4[s3] = { key: o3, error: "not_found" }, ++i4 === e5.length && n5(e5, r4, {});
        };
      });
    }(e4.keys, g2, O2) : f2 === -1 ? function(e5, t5, n5) {
      if (typeof e5.getAll != "function") {
        var r4 = [];
        e5.openCursor(t5).onsuccess = function(e6) {
          var t6 = e6.target.result;
          t6 ? (r4.push(t6.value), t6.continue()) : n5({ target: { result: r4 } });
        };
      } else
        e5.getAll(t5).onsuccess = n5;
    }(g2, r3, function(t5) {
      var n5 = t5.target.result;
      e4.descending && (n5 = n5.reverse()), j2(n5);
    }) : void on(g2, r3, e4.descending, f2 + c2, O2);
  }
  var an = false, un = [];
  function cn() {
    !an && un.length && (an = true, un.shift()());
  }
  var fn, ln = new i2(), dn = new i2();
  function hn(e4, t4) {
    var n4 = this;
    !function(t5, o2, a2) {
      un.push(function() {
        var t6;
        t6 = function(e5, t7) {
          !function(e6, t8, n5, r3) {
            try {
              e6(t8, n5);
            } catch (t9) {
              r3.emit("error", t9);
            }
          }(o2, e5, t7, a2), an = false, s()(function() {
            cn();
          });
        }, function(e5, t7, n5) {
          var o3 = t7.name, a3 = null, u2 = null;
          function c2(e6) {
            return function(t8, n6) {
              t8 && t8 instanceof Error && !t8.reason && u2 && (t8.reason = u2), e6(t8, n6);
            };
          }
          function f2(e6) {
            var t8 = e6.createObjectStore(Nt, { keyPath: "id" });
            e6.createObjectStore(Rt, { autoIncrement: true }).createIndex("_doc_id_rev", "_doc_id_rev", { unique: true }), e6.createObjectStore(Ft, { keyPath: "digest" }), e6.createObjectStore(zt, { keyPath: "id", autoIncrement: false }), e6.createObjectStore(Kt), t8.createIndex("deletedOrLocal", "deletedOrLocal", { unique: false }), e6.createObjectStore(Jt, { keyPath: "_id" });
            var n6 = e6.createObjectStore(Ut, { autoIncrement: true });
            n6.createIndex("seq", "seq"), n6.createIndex("digestSeq", "digestSeq", { unique: true });
          }
          function l2(e6, t8) {
            var n6 = e6.objectStore(Nt);
            n6.createIndex("deletedOrLocal", "deletedOrLocal", { unique: false }), n6.openCursor().onsuccess = function(e7) {
              var r3 = e7.target.result;
              if (r3) {
                var i3 = r3.value, o4 = Ke(i3);
                i3.deletedOrLocal = o4 ? "1" : "0", n6.put(i3), r3.continue();
              } else
                t8();
            };
          }
          function d2(e6) {
            e6.createObjectStore(Jt, { keyPath: "_id" }).createIndex("_doc_id_rev", "_doc_id_rev", { unique: true });
          }
          function h2(e6, t8) {
            var n6 = e6.objectStore(Jt), r3 = e6.objectStore(Nt), i3 = e6.objectStore(Rt);
            r3.openCursor().onsuccess = function(e7) {
              var o4 = e7.target.result;
              if (o4) {
                var s2 = o4.value, a4 = s2.id, u3 = Ve(a4), c3 = Pe(s2);
                if (u3) {
                  var f3 = a4 + "::" + c3, l3 = a4 + "::", d3 = a4 + "::~", h3 = i3.index("_doc_id_rev"), p3 = IDBKeyRange.bound(l3, d3, false, false), v3 = h3.openCursor(p3);
                  v3.onsuccess = function(e8) {
                    if (v3 = e8.target.result) {
                      var t9 = v3.value;
                      t9._doc_id_rev === f3 && n6.put(t9), i3.delete(v3.primaryKey), v3.continue();
                    } else
                      r3.delete(o4.primaryKey), o4.continue();
                  };
                } else
                  o4.continue();
              } else
                t8 && t8();
            };
          }
          function p2(e6) {
            var t8 = e6.createObjectStore(Ut, { autoIncrement: true });
            t8.createIndex("seq", "seq"), t8.createIndex("digestSeq", "digestSeq", { unique: true });
          }
          function v2(e6, t8) {
            var n6 = e6.objectStore(Rt), r3 = e6.objectStore(Ft), i3 = e6.objectStore(Ut);
            r3.count().onsuccess = function(e7) {
              if (!e7.target.result)
                return t8();
              n6.openCursor().onsuccess = function(e8) {
                var n7 = e8.target.result;
                if (!n7)
                  return t8();
                for (var r4 = n7.value, o4 = n7.primaryKey, s2 = Object.keys(r4._attachments || {}), a4 = {}, u3 = 0; u3 < s2.length; u3++)
                  a4[r4._attachments[s2[u3]].digest] = true;
                var c3 = Object.keys(a4);
                for (u3 = 0; u3 < c3.length; u3++) {
                  var f3 = c3[u3];
                  i3.put({ seq: o4, digestSeq: f3 + "::" + o4 });
                }
                n7.continue();
              };
            };
          }
          function y2(e6) {
            function t8(e7) {
              return e7.data ? Wt(e7) : (e7.deleted = e7.deletedOrLocal === "1", e7);
            }
            var n6 = e6.objectStore(Rt), r3 = e6.objectStore(Nt);
            r3.openCursor().onsuccess = function(e7) {
              var i3 = e7.target.result;
              if (i3) {
                var o4 = t8(i3.value);
                if (o4.winningRev = o4.winningRev || Pe(o4), o4.seq)
                  return a4();
                s2();
              }
              function s2() {
                var e8 = o4.id + "::", t9 = o4.id + "::\uFFFF", r4 = n6.index("_doc_id_rev").openCursor(IDBKeyRange.bound(e8, t9)), i4 = 0;
                r4.onsuccess = function(e9) {
                  var t10 = e9.target.result;
                  if (!t10)
                    return o4.seq = i4, a4();
                  var n7 = t10.primaryKey;
                  n7 > i4 && (i4 = n7), t10.continue();
                };
              }
              function a4() {
                var e8 = Gt(o4, o4.winningRev, o4.deleted);
                r3.put(e8).onsuccess = function() {
                  i3.continue();
                };
              }
            };
          }
          e5._meta = null, e5._remote = false, e5.type = function() {
            return "idb";
          }, e5._id = x(function(t8) {
            t8(null, e5._meta.instanceId);
          }), e5._bulkDocs = function(n6, r3, i3) {
            rn(t7, n6, r3, e5, a3, c2(i3));
          }, e5._get = function(e6, t8, n6) {
            var r3, i3, o4, s2 = t8.ctx;
            if (!s2) {
              var u3 = tn(a3, [Nt, Rt, Ft], "readonly");
              if (u3.error)
                return n6(u3.error);
              s2 = u3.txn;
            }
            function c3() {
              n6(o4, { doc: r3, metadata: i3, ctx: s2 });
            }
            s2.objectStore(Nt).get(e6).onsuccess = function(e7) {
              if (!(i3 = Wt(e7.target.result)))
                return o4 = ee(R, "missing"), c3();
              var n7;
              if (t8.rev)
                n7 = t8.latest ? function(e8, t9) {
                  for (var n8, r4 = t9.rev_tree.slice(); n8 = r4.pop(); ) {
                    var i4 = n8.pos, o5 = n8.ids, s3 = o5[0], a5 = o5[1], u5 = o5[2], c4 = u5.length === 0, f3 = n8.history ? n8.history.slice() : [];
                    if (f3.push({ id: s3, pos: i4, opts: a5 }), c4)
                      for (var l3 = 0, d3 = f3.length; l3 < d3; l3++) {
                        var h3 = f3[l3];
                        if (h3.pos + "-" + h3.id === e8)
                          return i4 + "-" + s3;
                      }
                    for (var p3 = 0, v3 = u5.length; p3 < v3; p3++)
                      r4.push({ pos: i4 + 1, ids: u5[p3], history: f3 });
                  }
                  throw new Error("Unable to resolve latest revision for id " + t9.id + ", rev " + e8);
                }(t8.rev, i3) : t8.rev;
              else if (n7 = i3.winningRev, Ke(i3))
                return o4 = ee(R, "deleted"), c3();
              var a4 = s2.objectStore(Rt), u4 = i3.id + "::" + n7;
              a4.index("_doc_id_rev").get(u4).onsuccess = function(e8) {
                if ((r3 = e8.target.result) && (r3 = Zt(r3)), !r3)
                  return o4 = ee(R, "missing"), c3();
                c3();
              };
            };
          }, e5._getAttachment = function(e6, t8, n6, r3, i3) {
            var o4;
            if (r3.ctx)
              o4 = r3.ctx;
            else {
              var s2 = tn(a3, [Nt, Rt, Ft], "readonly");
              if (s2.error)
                return i3(s2.error);
              o4 = s2.txn;
            }
            var u3 = n6.digest, c3 = n6.content_type;
            o4.objectStore(Ft).get(u3).onsuccess = function(e7) {
              Xt(e7.target.result.body, c3, r3.binary, function(e8) {
                i3(null, e8);
              });
            };
          }, e5._info = function(t8) {
            var n6, r3, i3 = tn(a3, [zt, Rt], "readonly");
            if (i3.error)
              return t8(i3.error);
            var o4 = i3.txn;
            o4.objectStore(zt).get(zt).onsuccess = function(e6) {
              r3 = e6.target.result.docCount;
            }, o4.objectStore(Rt).openCursor(null, "prev").onsuccess = function(e6) {
              var t9 = e6.target.result;
              n6 = t9 ? t9.key : 0;
            }, o4.oncomplete = function() {
              t8(null, { doc_count: r3, update_seq: n6, idb_attachment_format: e5._meta.blobSupport ? "binary" : "base64" });
            };
          }, e5._allDocs = function(e6, t8) {
            sn(e6, a3, c2(t8));
          }, e5._changes = function(t8) {
            return function(e6, t9, n6, o4) {
              if ((e6 = O(e6)).continuous) {
                var s2 = n6 + ":" + Ee();
                return nn.addListener(n6, s2, t9, e6), nn.notify(n6), { cancel: function() {
                  nn.removeListener(n6, s2);
                } };
              }
              var a4 = e6.doc_ids && new r2(e6.doc_ids);
              e6.since = e6.since || 0;
              var u3 = e6.since, c3 = "limit" in e6 ? e6.limit : -1;
              c3 === 0 && (c3 = 1);
              var f3, l3, d3, h3, p3 = [], v3 = 0, y3 = ne(e6), g3 = new i2();
              function _3(e7, t10, n7, r3) {
                if (n7.seq !== t10)
                  return r3();
                if (n7.winningRev === e7._rev)
                  return r3(n7, e7);
                var i3 = e7._id + "::" + n7.winningRev;
                h3.get(i3).onsuccess = function(e8) {
                  r3(n7, Zt(e8.target.result));
                };
              }
              function m2() {
                e6.complete(null, { results: p3, last_seq: u3 });
              }
              var b2 = [Nt, Rt];
              e6.attachments && b2.push(Ft);
              var w2 = tn(o4, b2, "readonly");
              if (w2.error)
                return e6.complete(w2.error);
              (f3 = w2.txn).onabort = Qt(e6.complete), f3.oncomplete = function() {
                !e6.continuous && e6.attachments ? Ht(p3).then(m2) : m2();
              }, l3 = f3.objectStore(Rt), d3 = f3.objectStore(Nt), h3 = l3.index("_doc_id_rev"), on(l3, e6.since && !e6.descending ? IDBKeyRange.lowerBound(e6.since, true) : null, e6.descending, c3, function(t10, n7, r3) {
                if (r3 && t10.length) {
                  var i3 = new Array(t10.length), o5 = new Array(t10.length), s3 = 0;
                  n7.forEach(function(n8, u4) {
                    !function(e7, t11, n9) {
                      if (a4 && !a4.has(e7._id))
                        return n9();
                      var r4 = g3.get(e7._id);
                      if (r4)
                        return _3(e7, t11, r4, n9);
                      d3.get(e7._id).onsuccess = function(i4) {
                        r4 = Wt(i4.target.result), g3.set(e7._id, r4), _3(e7, t11, r4, n9);
                      };
                    }(Zt(n8), t10[u4], function(n9, a5) {
                      o5[u4] = n9, i3[u4] = a5, ++s3 === t10.length && function() {
                        for (var t11 = [], n10 = 0, s4 = i3.length; n10 < s4 && v3 !== c3; n10++) {
                          var a6 = i3[n10];
                          if (a6) {
                            var u5 = o5[n10];
                            t11.push(l4(u5, a6));
                          }
                        }
                        Promise.all(t11).then(function(t12) {
                          for (var n11 = 0, r4 = t12.length; n11 < r4; n11++)
                            t12[n11] && e6.onChange(t12[n11]);
                        }).catch(e6.complete), v3 !== c3 && r3.continue();
                      }();
                    });
                  });
                }
                function l4(t11, n8) {
                  var r4 = e6.processChange(n8, t11, e6);
                  u3 = r4.seq = t11.seq;
                  var i4 = y3(r4);
                  return typeof i4 == "object" ? Promise.reject(i4) : i4 ? (v3++, e6.return_docs && p3.push(r4), e6.attachments && e6.include_docs ? new Promise(function(t12) {
                    Yt(n8, e6, f3, function() {
                      Ht([r4], e6.binary).then(function() {
                        t12(r4);
                      });
                    });
                  }) : Promise.resolve(r4)) : Promise.resolve();
                }
              });
            }(t8, e5, o3, a3);
          }, e5._close = function(e6) {
            a3.close(), ln.delete(o3), e6();
          }, e5._getRevisionTree = function(e6, t8) {
            var n6 = tn(a3, [Nt], "readonly");
            if (n6.error)
              return t8(n6.error);
            n6.txn.objectStore(Nt).get(e6).onsuccess = function(e7) {
              var n7 = Wt(e7.target.result);
              n7 ? t8(null, n7.rev_tree) : t8(ee(R));
            };
          }, e5._doCompaction = function(e6, t8, n6) {
            var r3 = tn(a3, [Nt, Rt, Ft, Ut], "readwrite");
            if (r3.error)
              return n6(r3.error);
            var i3 = r3.txn;
            i3.objectStore(Nt).get(e6).onsuccess = function(n7) {
              var r4 = Wt(n7.target.result);
              Ce(r4.rev_tree, function(e7, n8, r5, i4, o5) {
                var s3 = n8 + "-" + r5;
                t8.indexOf(s3) !== -1 && (o5.status = "missing");
              }), en(t8, e6, i3);
              var o4 = r4.winningRev, s2 = r4.deleted;
              i3.objectStore(Nt).put(Gt(r4, o4, s2));
            }, i3.onabort = Qt(n6), i3.oncomplete = function() {
              n6();
            };
          }, e5._getLocal = function(e6, t8) {
            var n6 = tn(a3, [Jt], "readonly");
            if (n6.error)
              return t8(n6.error);
            var r3 = n6.txn.objectStore(Jt).get(e6);
            r3.onerror = Qt(t8), r3.onsuccess = function(e7) {
              var n7 = e7.target.result;
              n7 ? (delete n7._doc_id_rev, t8(null, n7)) : t8(ee(R));
            };
          }, e5._putLocal = function(e6, t8, n6) {
            typeof t8 == "function" && (n6 = t8, t8 = {}), delete e6._revisions;
            var r3 = e6._rev, i3 = e6._id;
            e6._rev = r3 ? "0-" + (parseInt(r3.split("-")[1], 10) + 1) : "0-1";
            var o4, s2 = t8.ctx;
            if (!s2) {
              var u3 = tn(a3, [Jt], "readwrite");
              if (u3.error)
                return n6(u3.error);
              (s2 = u3.txn).onerror = Qt(n6), s2.oncomplete = function() {
                o4 && n6(null, o4);
              };
            }
            var c3, f3 = s2.objectStore(Jt);
            r3 ? (c3 = f3.get(i3)).onsuccess = function(i4) {
              var s3 = i4.target.result;
              s3 && s3._rev === r3 ? f3.put(e6).onsuccess = function() {
                o4 = { ok: true, id: e6._id, rev: e6._rev }, t8.ctx && n6(null, o4);
              } : n6(ee(F));
            } : ((c3 = f3.add(e6)).onerror = function(e7) {
              n6(ee(F)), e7.preventDefault(), e7.stopPropagation();
            }, c3.onsuccess = function() {
              o4 = { ok: true, id: e6._id, rev: e6._rev }, t8.ctx && n6(null, o4);
            });
          }, e5._removeLocal = function(e6, t8, n6) {
            typeof t8 == "function" && (n6 = t8, t8 = {});
            var r3, i3 = t8.ctx;
            if (!i3) {
              var o4 = tn(a3, [Jt], "readwrite");
              if (o4.error)
                return n6(o4.error);
              (i3 = o4.txn).oncomplete = function() {
                r3 && n6(null, r3);
              };
            }
            var s2 = e6._id, u3 = i3.objectStore(Jt), c3 = u3.get(s2);
            c3.onerror = Qt(n6), c3.onsuccess = function(i4) {
              var o5 = i4.target.result;
              o5 && o5._rev === e6._rev ? (u3.delete(s2), r3 = { ok: true, id: s2, rev: "0-0" }, t8.ctx && n6(null, r3)) : n6(ee(R));
            };
          }, e5._destroy = function(e6, t8) {
            nn.removeAllListeners(o3);
            var n6 = dn.get(o3);
            n6 && n6.result && (n6.result.close(), ln.delete(o3));
            var r3 = indexedDB.deleteDatabase(o3);
            r3.onsuccess = function() {
              dn.delete(o3), C() && o3 in localStorage && delete localStorage[o3], t8(null, { ok: true });
            }, r3.onerror = Qt(t8);
          };
          var g2 = ln.get(o3);
          if (g2)
            return a3 = g2.idb, e5._meta = g2.global, s()(function() {
              n5(null, e5);
            });
          var _2 = indexedDB.open(o3, 5);
          dn.set(o3, _2), _2.onupgradeneeded = function(e6) {
            var t8 = e6.target.result;
            if (e6.oldVersion < 1)
              return f2(t8);
            var n6 = e6.currentTarget.transaction;
            e6.oldVersion < 3 && d2(t8), e6.oldVersion < 4 && p2(t8);
            var r3 = [l2, h2, v2, y2], i3 = e6.oldVersion;
            function o4() {
              var e7 = r3[i3 - 1];
              i3++, e7 && e7(n6, o4);
            }
            o4();
          }, _2.onsuccess = function(t8) {
            (a3 = t8.target.result).onversionchange = function() {
              a3.close(), ln.delete(o3);
            }, a3.onabort = function(e6) {
              L("error", "Database has a global failure", e6.target.error), u2 = e6.target.error, a3.close(), ln.delete(o3);
            };
            var r3, i3, s2, c3, f3 = a3.transaction([zt, Kt, Nt], "readwrite"), l3 = false;
            function d3() {
              s2 !== void 0 && l3 && (e5._meta = { name: o3, instanceId: c3, blobSupport: s2 }, ln.set(o3, { idb: a3, global: e5._meta }), n5(null, e5));
            }
            function h3() {
              if (i3 !== void 0 && r3 !== void 0) {
                var e6 = o3 + "_id";
                e6 in r3 ? c3 = r3[e6] : r3[e6] = c3 = Ee(), r3.docCount = i3, f3.objectStore(zt).put(r3);
              }
            }
            f3.objectStore(zt).get(zt).onsuccess = function(e6) {
              r3 = e6.target.result || { id: zt }, h3();
            }, function(e6, t9) {
              e6.objectStore(Nt).index("deletedOrLocal").count(IDBKeyRange.only("0")).onsuccess = function(e7) {
                t9(e7.target.result);
              };
            }(f3, function(e6) {
              i3 = e6, h3();
            }), fn || (fn = function(e6) {
              return new Promise(function(t9) {
                var n6 = ge([""]), r4 = e6.objectStore(Kt).put(n6, "key");
                r4.onsuccess = function() {
                  var e7 = navigator.userAgent.match(/Chrome\/(\d+)/), n7 = navigator.userAgent.match(/Edge\//);
                  t9(n7 || !e7 || parseInt(e7[1], 10) >= 43);
                }, r4.onerror = e6.onabort = function(e7) {
                  e7.preventDefault(), e7.stopPropagation(), t9(false);
                };
              }).catch(function() {
                return false;
              });
            }(f3)), fn.then(function(e6) {
              s2 = e6, d3();
            }), f3.oncomplete = function() {
              l3 = true, d3();
            }, f3.onabort = Qt(n5);
          }, _2.onerror = function(e6) {
            var t8 = e6.target.error && e6.target.error.message;
            t8 ? t8.indexOf("stored database is a higher version") !== -1 && (t8 = new Error('This DB was created with the newer "indexeddb" adapter, but you are trying to open it with the older "idb" adapter')) : t8 = "Failed to open indexedDB, are you in private browsing mode?", L("error", t8), n5(ee(X, t8));
          };
        }(n4, e4, t6);
      }), cn();
    }(0, t4, n4.constructor);
  }
  hn.valid = function() {
    try {
      return typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
    } catch (e4) {
      return false;
    }
  };
  var pn = 5e3, vn = {};
  function yn(e4) {
    var t4 = e4.doc || e4.ok, n4 = t4 && t4._attachments;
    n4 && Object.keys(n4).forEach(function(e5) {
      var t5 = n4[e5];
      t5.data = be(t5.data, t5.content_type);
    });
  }
  function gn(e4) {
    return /^_design/.test(e4) ? "_design/" + encodeURIComponent(e4.slice(8)) : /^_local/.test(e4) ? "_local/" + encodeURIComponent(e4.slice(7)) : encodeURIComponent(e4);
  }
  function _n(e4) {
    return e4._attachments && Object.keys(e4._attachments) ? Promise.all(Object.keys(e4._attachments).map(function(t4) {
      var n4 = e4._attachments[t4];
      if (n4.data && typeof n4.data != "string")
        return new Promise(function(e5) {
          je(n4.data, e5);
        }).then(function(e5) {
          n4.data = e5;
        });
    })) : Promise.resolve();
  }
  function mn(e4, t4) {
    return bn(e4, e4.db + "/" + t4);
  }
  function bn(e4, t4) {
    var n4 = e4.path ? "/" : "";
    return e4.protocol + "://" + e4.host + (e4.port ? ":" + e4.port : "") + "/" + e4.path + n4 + t4;
  }
  function wn(e4) {
    return "?" + Object.keys(e4).map(function(t4) {
      return t4 + "=" + encodeURIComponent(e4[t4]);
    }).join("&");
  }
  function kn(e4, t4) {
    var n4 = this, r3 = function(e5, t5) {
      if (function(e6) {
        if (!e6.prefix)
          return false;
        var t6 = de(e6.prefix).protocol;
        return t6 === "http" || t6 === "https";
      }(t5)) {
        var n5 = t5.name.substr(t5.prefix.length);
        e5 = t5.prefix.replace(/\/?$/, "/") + encodeURIComponent(n5);
      }
      var r4 = de(e5);
      (r4.user || r4.password) && (r4.auth = { username: r4.user, password: r4.password });
      var i4 = r4.path.replace(/(^\/|\/$)/g, "").split("/");
      return r4.db = i4.pop(), r4.db.indexOf("%") === -1 && (r4.db = encodeURIComponent(r4.db)), r4.path = i4.join("/"), r4;
    }(e4.name, e4), i3 = mn(r3, "");
    e4 = O(e4);
    var o2, a2 = function(t5, n5) {
      if ((n5 = n5 || {}).headers = n5.headers || new it(), n5.credentials = "include", e4.auth || r3.auth) {
        var i4 = e4.auth || r3.auth, o3 = i4.username + ":" + i4.password, s2 = ye(unescape(encodeURIComponent(o3)));
        n5.headers.set("Authorization", "Basic " + s2);
      }
      var a3 = e4.headers || {};
      return Object.keys(a3).forEach(function(e5) {
        n5.headers.append(e5, a3[e5]);
      }), function(e5) {
        var t6 = typeof navigator != "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", n6 = t6.indexOf("msie") !== -1, r4 = t6.indexOf("trident") !== -1, i5 = t6.indexOf("edge") !== -1, o4 = !("method" in e5) || e5.method === "GET";
        return (n6 || r4 || i5) && o4;
      }(n5) && (t5 += (t5.indexOf("?") === -1 ? "?" : "&") + "_nonce=" + Date.now()), (e4.fetch || rt)(t5, n5);
    };
    function u2(e5, t5) {
      return q(e5, d()(function(e6) {
        f2().then(function() {
          return t5.apply(this, e6);
        }).catch(function(t6) {
          e6.pop()(t6);
        });
      })).bind(n4);
    }
    function c2(e5, t5, n5) {
      var r4 = {};
      return (t5 = t5 || {}).headers = t5.headers || new it(), t5.headers.get("Content-Type") || t5.headers.set("Content-Type", "application/json"), t5.headers.get("Accept") || t5.headers.set("Accept", "application/json"), a2(e5, t5).then(function(e6) {
        return r4.ok = e6.ok, r4.status = e6.status, e6.json();
      }).then(function(e6) {
        if (r4.data = e6, !r4.ok) {
          r4.data.status = r4.status;
          var t6 = te(r4.data);
          if (n5)
            return n5(t6);
          throw t6;
        }
        if (Array.isArray(r4.data) && (r4.data = r4.data.map(function(e7) {
          return e7.error || e7.missing ? te(e7) : e7;
        })), !n5)
          return r4;
        n5(null, r4.data);
      });
    }
    function f2() {
      return e4.skip_setup ? Promise.resolve() : o2 || ((o2 = c2(i3).catch(function(e5) {
        return e5 && e5.status && e5.status === 404 ? (I(404, "PouchDB is just detecting if the remote exists."), c2(i3, { method: "PUT" })) : Promise.reject(e5);
      }).catch(function(e5) {
        return !(!e5 || !e5.status || e5.status !== 412) || Promise.reject(e5);
      })).catch(function() {
        o2 = null;
      }), o2);
    }
    function l2(e5) {
      return e5.split("/").map(encodeURIComponent).join("/");
    }
    s()(function() {
      t4(null, n4);
    }), n4._remote = true, n4.type = function() {
      return "http";
    }, n4.id = u2("id", function(e5) {
      a2(bn(r3, "")).then(function(e6) {
        return e6.json();
      }).catch(function() {
        return {};
      }).then(function(t5) {
        var n5 = t5 && t5.uuid ? t5.uuid + r3.db : mn(r3, "");
        e5(null, n5);
      });
    }), n4.compact = u2("compact", function(e5, t5) {
      typeof e5 == "function" && (t5 = e5, e5 = {}), e5 = O(e5), c2(mn(r3, "_compact"), { method: "POST" }).then(function() {
        !function r4() {
          n4.info(function(n5, i4) {
            i4 && !i4.compact_running ? t5(null, { ok: true }) : setTimeout(r4, e5.interval || 200);
          });
        }();
      });
    }), n4.bulkGet = q("bulkGet", function(e5, t5) {
      var n5 = this;
      function i4(t6) {
        var n6 = {};
        e5.revs && (n6.revs = true), e5.attachments && (n6.attachments = true), e5.latest && (n6.latest = true), c2(mn(r3, "_bulk_get" + wn(n6)), { method: "POST", body: JSON.stringify({ docs: e5.docs }) }).then(function(n7) {
          e5.attachments && e5.binary && n7.data.results.forEach(function(e6) {
            e6.docs.forEach(yn);
          }), t6(null, n7.data);
        }).catch(t6);
      }
      function o3() {
        var r4 = Math.ceil(e5.docs.length / 50), i5 = 0, o4 = new Array(r4);
        function s3(e6) {
          return function(n6, s4) {
            o4[e6] = s4.results, ++i5 === r4 && t5(null, { results: re(o4) });
          };
        }
        for (var a4 = 0; a4 < r4; a4++) {
          var u3 = A(e5, ["revs", "attachments", "binary", "latest"]);
          u3.docs = e5.docs.slice(50 * a4, Math.min(e5.docs.length, 50 * (a4 + 1))), P(n5, u3, s3(a4));
        }
      }
      var s2 = bn(r3, ""), a3 = vn[s2];
      typeof a3 != "boolean" ? i4(function(e6, n6) {
        e6 ? (vn[s2] = false, I(e6.status, "PouchDB is just detecting if the remote supports the _bulk_get API."), o3()) : (vn[s2] = true, t5(null, n6));
      }) : a3 ? i4(t5) : o3();
    }), n4._info = function(e5) {
      f2().then(function() {
        return a2(mn(r3, ""));
      }).then(function(e6) {
        return e6.json();
      }).then(function(t5) {
        t5.host = mn(r3, ""), e5(null, t5);
      }).catch(e5);
    }, n4.fetch = function(e5, t5) {
      return f2().then(function() {
        var n5 = e5.substring(0, 1) === "/" ? bn(r3, e5.substring(1)) : mn(r3, e5);
        return a2(n5, t5);
      });
    }, n4.get = u2("get", function(e5, t5, n5) {
      typeof t5 == "function" && (n5 = t5, t5 = {});
      var i4 = {};
      function o3(e6) {
        var n6, i5 = e6._attachments, o4 = i5 && Object.keys(i5);
        if (i5 && o4.length)
          return n6 = o4.map(function(n7) {
            return function() {
              return function(n8) {
                var o5 = i5[n8], s2 = gn(e6._id) + "/" + l2(n8) + "?rev=" + e6._rev;
                return a2(mn(r3, s2)).then(function(e7) {
                  return "buffer" in e7 ? e7.buffer() : e7.blob();
                }).then(function(e7) {
                  if (t5.binary) {
                    var n9 = Object.getOwnPropertyDescriptor(e7.__proto__, "type");
                    return n9 && !n9.set || (e7.type = o5.content_type), e7;
                  }
                  return new Promise(function(t6) {
                    je(e7, t6);
                  });
                }).then(function(e7) {
                  delete o5.stub, delete o5.length, o5.data = e7;
                });
              }(n7);
            };
          }), new Promise(function(e7, t6) {
            var r4, i6 = 0, o5 = 0, s2 = 0, a3 = n6.length;
            function u3() {
              ++s2 === a3 ? r4 ? t6(r4) : e7() : l3();
            }
            function c3() {
              i6--, u3();
            }
            function f3(e8) {
              i6--, r4 = r4 || e8, u3();
            }
            function l3() {
              for (; i6 < 5 && o5 < a3; )
                i6++, n6[o5++]().then(c3, f3);
            }
            l3();
          });
      }
      (t5 = O(t5)).revs && (i4.revs = true), t5.revs_info && (i4.revs_info = true), t5.latest && (i4.latest = true), t5.open_revs && (t5.open_revs !== "all" && (t5.open_revs = JSON.stringify(t5.open_revs)), i4.open_revs = t5.open_revs), t5.rev && (i4.rev = t5.rev), t5.conflicts && (i4.conflicts = t5.conflicts), t5.update_seq && (i4.update_seq = t5.update_seq), e5 = gn(e5), c2(mn(r3, e5 + wn(i4))).then(function(e6) {
        return Promise.resolve().then(function() {
          if (t5.attachments)
            return n6 = e6.data, Array.isArray(n6) ? Promise.all(n6.map(function(e7) {
              if (e7.ok)
                return o3(e7.ok);
            })) : o3(n6);
          var n6;
        }).then(function() {
          n5(null, e6.data);
        });
      }).catch(function(t6) {
        t6.docId = e5, n5(t6);
      });
    }), n4.remove = u2("remove", function(e5, t5, n5, i4) {
      var o3;
      typeof t5 == "string" ? (o3 = { _id: e5, _rev: t5 }, typeof n5 == "function" && (i4 = n5, n5 = {})) : (o3 = e5, typeof t5 == "function" ? (i4 = t5, n5 = {}) : (i4 = n5, n5 = t5));
      var s2 = o3._rev || n5.rev;
      c2(mn(r3, gn(o3._id)) + "?rev=" + s2, { method: "DELETE" }, i4).catch(i4);
    }), n4.getAttachment = u2("getAttachment", function(e5, t5, n5, i4) {
      typeof n5 == "function" && (i4 = n5, n5 = {});
      var o3, s2 = n5.rev ? "?rev=" + n5.rev : "", u3 = mn(r3, gn(e5)) + "/" + l2(t5) + s2;
      a2(u3, { method: "GET" }).then(function(e6) {
        if (o3 = e6.headers.get("content-type"), e6.ok)
          return typeof process == "undefined" || process.browser || typeof e6.buffer != "function" ? e6.blob() : e6.buffer();
        throw e6;
      }).then(function(e6) {
        typeof process == "undefined" || process.browser || (e6.type = o3), i4(null, e6);
      }).catch(function(e6) {
        i4(e6);
      });
    }), n4.removeAttachment = u2("removeAttachment", function(e5, t5, n5, i4) {
      c2(mn(r3, gn(e5) + "/" + l2(t5)) + "?rev=" + n5, { method: "DELETE" }, i4).catch(i4);
    }), n4.putAttachment = u2("putAttachment", function(e5, t5, n5, i4, o3, s2) {
      typeof o3 == "function" && (s2 = o3, o3 = i4, i4 = n5, n5 = null);
      var a3 = gn(e5) + "/" + l2(t5), u3 = mn(r3, a3);
      if (n5 && (u3 += "?rev=" + n5), typeof i4 == "string") {
        var f3;
        try {
          f3 = ve(i4);
        } catch (e6) {
          return s2(ee(V, "Attachment is not a valid base64 string"));
        }
        i4 = f3 ? me(f3, o3) : "";
      }
      c2(u3, { headers: new it({ "Content-Type": o3 }), method: "PUT", body: i4 }, s2).catch(s2);
    }), n4._bulkDocs = function(e5, t5, n5) {
      e5.new_edits = t5.new_edits, f2().then(function() {
        return Promise.all(e5.docs.map(_n));
      }).then(function() {
        return c2(mn(r3, "_bulk_docs"), { method: "POST", body: JSON.stringify(e5) }, n5);
      }).catch(n5);
    }, n4._put = function(e5, t5, n5) {
      f2().then(function() {
        return _n(e5);
      }).then(function() {
        return c2(mn(r3, gn(e5._id)), { method: "PUT", body: JSON.stringify(e5) });
      }).then(function(e6) {
        n5(null, e6.data);
      }).catch(function(t6) {
        t6.docId = e5 && e5._id, n5(t6);
      });
    }, n4.allDocs = u2("allDocs", function(e5, t5) {
      typeof e5 == "function" && (t5 = e5, e5 = {});
      var n5, i4 = {}, o3 = "GET";
      (e5 = O(e5)).conflicts && (i4.conflicts = true), e5.update_seq && (i4.update_seq = true), e5.descending && (i4.descending = true), e5.include_docs && (i4.include_docs = true), e5.attachments && (i4.attachments = true), e5.key && (i4.key = JSON.stringify(e5.key)), e5.start_key && (e5.startkey = e5.start_key), e5.startkey && (i4.startkey = JSON.stringify(e5.startkey)), e5.end_key && (e5.endkey = e5.end_key), e5.endkey && (i4.endkey = JSON.stringify(e5.endkey)), e5.inclusive_end !== void 0 && (i4.inclusive_end = !!e5.inclusive_end), e5.limit !== void 0 && (i4.limit = e5.limit), e5.skip !== void 0 && (i4.skip = e5.skip);
      var s2 = wn(i4);
      e5.keys !== void 0 && (o3 = "POST", n5 = { keys: e5.keys }), c2(mn(r3, "_all_docs" + s2), { method: o3, body: JSON.stringify(n5) }).then(function(n6) {
        e5.include_docs && e5.attachments && e5.binary && n6.data.rows.forEach(yn), t5(null, n6.data);
      }).catch(t5);
    }), n4._changes = function(e5) {
      var t5 = "batch_size" in e5 ? e5.batch_size : 25;
      (e5 = O(e5)).continuous && !("heartbeat" in e5) && (e5.heartbeat = 1e4);
      var n5 = "timeout" in e5 ? e5.timeout : 3e4;
      "timeout" in e5 && e5.timeout && n5 - e5.timeout < pn && (n5 = e5.timeout + pn), "heartbeat" in e5 && e5.heartbeat && n5 - e5.heartbeat < pn && (n5 = e5.heartbeat + pn);
      var i4 = {};
      "timeout" in e5 && e5.timeout && (i4.timeout = e5.timeout);
      var o3 = e5.limit !== void 0 && e5.limit, a3 = o3;
      if (e5.style && (i4.style = e5.style), (e5.include_docs || e5.filter && typeof e5.filter == "function") && (i4.include_docs = true), e5.attachments && (i4.attachments = true), e5.continuous && (i4.feed = "longpoll"), e5.seq_interval && (i4.seq_interval = e5.seq_interval), e5.conflicts && (i4.conflicts = true), e5.descending && (i4.descending = true), e5.update_seq && (i4.update_seq = true), "heartbeat" in e5 && e5.heartbeat && (i4.heartbeat = e5.heartbeat), e5.filter && typeof e5.filter == "string" && (i4.filter = e5.filter), e5.view && typeof e5.view == "string" && (i4.filter = "_view", i4.view = e5.view), e5.query_params && typeof e5.query_params == "object")
        for (var u3 in e5.query_params)
          Object.prototype.hasOwnProperty.call(e5.query_params, u3) && (i4[u3] = e5.query_params[u3]);
      var l3, d2 = "GET";
      e5.doc_ids ? (i4.filter = "_doc_ids", d2 = "POST", l3 = { doc_ids: e5.doc_ids }) : e5.selector && (i4.filter = "_selector", d2 = "POST", l3 = { selector: e5.selector });
      var h2, p2 = new nt(), v2 = function(n6, s2) {
        if (!e5.aborted) {
          i4.since = n6, typeof i4.since == "object" && (i4.since = JSON.stringify(i4.since)), e5.descending ? o3 && (i4.limit = a3) : i4.limit = !o3 || a3 > t5 ? t5 : a3;
          var u4 = mn(r3, "_changes" + wn(i4)), v3 = { signal: p2.signal, method: d2, body: JSON.stringify(l3) };
          h2 = n6, e5.aborted || f2().then(function() {
            return c2(u4, v3, s2);
          }).catch(s2);
        }
      }, y2 = { results: [] }, g2 = function(n6, r4) {
        if (!e5.aborted) {
          var i5 = 0;
          if (r4 && r4.results) {
            i5 = r4.results.length, y2.last_seq = r4.last_seq;
            var u4 = null, c3 = null;
            typeof r4.pending == "number" && (u4 = r4.pending), typeof y2.last_seq != "string" && typeof y2.last_seq != "number" || (c3 = y2.last_seq), e5.query_params, r4.results = r4.results.filter(function(t6) {
              a3--;
              var n7 = ne(e5)(t6);
              return n7 && (e5.include_docs && e5.attachments && e5.binary && yn(t6), e5.return_docs && y2.results.push(t6), e5.onChange(t6, u4, c3)), n7;
            });
          } else if (n6)
            return e5.aborted = true, void e5.complete(n6);
          r4 && r4.last_seq && (h2 = r4.last_seq);
          var f3 = o3 && a3 <= 0 || r4 && i5 < t5 || e5.descending;
          (!e5.continuous || o3 && a3 <= 0) && f3 ? e5.complete(null, y2) : s()(function() {
            v2(h2, g2);
          });
        }
      };
      return v2(e5.since || 0, g2), { cancel: function() {
        e5.aborted = true, p2.abort();
      } };
    }, n4.revsDiff = u2("revsDiff", function(e5, t5, n5) {
      typeof t5 == "function" && (n5 = t5, t5 = {}), c2(mn(r3, "_revs_diff"), { method: "POST", body: JSON.stringify(e5) }, n5).catch(n5);
    }), n4._close = function(e5) {
      e5();
    }, n4._destroy = function(e5, t5) {
      c2(mn(r3, ""), { method: "DELETE" }).then(function(e6) {
        t5(null, e6);
      }).catch(function(e6) {
        e6.status === 404 ? t5(null, { ok: true }) : t5(e6);
      });
    };
  }
  function jn(e4) {
    this.status = 400, this.name = "query_parse_error", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, jn);
    } catch (e5) {
    }
  }
  function On(e4) {
    this.status = 404, this.name = "not_found", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, On);
    } catch (e5) {
    }
  }
  function $n(e4) {
    this.status = 500, this.name = "invalid_value", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, $n);
    } catch (e5) {
    }
  }
  function xn(e4, t4) {
    return t4 && e4.then(function(e5) {
      s()(function() {
        t4(null, e5);
      });
    }, function(e5) {
      s()(function() {
        t4(e5);
      });
    }), e4;
  }
  function qn(e4, t4) {
    return function() {
      var n4 = arguments, r3 = this;
      return e4.add(function() {
        return t4.apply(r3, n4);
      });
    };
  }
  function An(e4) {
    var t4 = new r2(e4), n4 = new Array(t4.size), i3 = -1;
    return t4.forEach(function(e5) {
      n4[++i3] = e5;
    }), n4;
  }
  function Sn(e4) {
    var t4 = new Array(e4.size), n4 = -1;
    return e4.forEach(function(e5, r3) {
      t4[++n4] = r3;
    }), t4;
  }
  function En(e4) {
    return new $n("builtin " + e4 + " function requires map values to be numbers or number arrays");
  }
  function Pn(e4) {
    for (var t4 = 0, n4 = 0, r3 = e4.length; n4 < r3; n4++) {
      var i3 = e4[n4];
      if (typeof i3 != "number") {
        if (!Array.isArray(i3))
          throw En("_sum");
        t4 = typeof t4 == "number" ? [t4] : t4;
        for (var o2 = 0, s2 = i3.length; o2 < s2; o2++) {
          var a2 = i3[o2];
          if (typeof a2 != "number")
            throw En("_sum");
          t4[o2] === void 0 ? t4.push(a2) : t4[o2] += a2;
        }
      } else
        typeof t4 == "number" ? t4 += i3 : t4[0] += i3;
    }
    return t4;
  }
  kn.valid = function() {
    return true;
  }, p()(jn, Error), p()(On, Error), p()($n, Error);
  var Cn = L.bind(null, "log"), Dn = Array.isArray, Ln = JSON.parse;
  function Bn(e4, t4) {
    return he("return (" + e4.replace(/;\s*$/, "") + ");", { emit: t4, sum: Pn, log: Cn, isArray: Dn, toJSON: Ln });
  }
  function In() {
    this.promise = new Promise(function(e4) {
      e4();
    });
  }
  function Tn(e4) {
    if (!e4)
      return "undefined";
    switch (typeof e4) {
      case "function":
      case "string":
        return e4.toString();
      default:
        return JSON.stringify(e4);
    }
  }
  function Mn(e4, t4, n4, r3, i3, o2) {
    var s2, a2 = function(e5, t5) {
      return Tn(e5) + Tn(t5) + "undefined";
    }(n4, r3);
    if (!i3 && (s2 = e4._cachedViews = e4._cachedViews || {})[a2])
      return s2[a2];
    var u2 = e4.info().then(function(u3) {
      var c2 = u3.db_name + "-mrview-" + (i3 ? "temp" : Ae(a2));
      return pe(e4, "_local/" + o2, function(e5) {
        e5.views = e5.views || {};
        var n5 = t4;
        n5.indexOf("/") === -1 && (n5 = t4 + "/" + t4);
        var r4 = e5.views[n5] = e5.views[n5] || {};
        if (!r4[c2])
          return r4[c2] = true, e5;
      }).then(function() {
        return e4.registerDependentDatabase(c2).then(function(t5) {
          var i4 = t5.db;
          i4.auto_compaction = true;
          var o3 = { name: c2, db: i4, sourceDB: e4, adapter: e4.adapter, mapFun: n4, reduceFun: r3 };
          return o3.db.get("_local/lastSeq").catch(function(e5) {
            if (e5.status !== 404)
              throw e5;
          }).then(function(e5) {
            return o3.seq = e5 ? e5.seq : 0, s2 && o3.db.once("destroyed", function() {
              delete s2[a2];
            }), o3;
          });
        });
      });
    });
    return s2 && (s2[a2] = u2), u2;
  }
  In.prototype.add = function(e4) {
    return this.promise = this.promise.catch(function() {
    }).then(function() {
      return e4();
    }), this.promise;
  }, In.prototype.finish = function() {
    return this.promise;
  };
  var Nn = {}, Rn = new In();
  function Fn(e4) {
    return e4.indexOf("/") === -1 ? [e4, e4] : e4.split("/");
  }
  function Un(e4, t4) {
    try {
      e4.emit("error", t4);
    } catch (e5) {
      L("error", "The user's map/reduce function threw an uncaught error.\nYou can debug this error by doing:\nmyDatabase.on('error', function (err) { debugger; });\nPlease double-check your map/reduce function."), L("error", t4);
    }
  }
  var zn = function(e4, t4) {
    return Pn(t4);
  }, Jn = function(e4, t4) {
    return t4.length;
  }, Kn = function(e4, t4) {
    return { sum: Pn(t4), min: Math.min.apply(null, t4), max: Math.max.apply(null, t4), count: t4.length, sumsqr: function(e5) {
      for (var t5 = 0, n4 = 0, r3 = e5.length; n4 < r3; n4++) {
        var i3 = e5[n4];
        t5 += i3 * i3;
      }
      return t5;
    }(t4) };
  }, Vn = function(e4, t4, n4, o2) {
    function a2(e5, t5, n5) {
      try {
        t5(n5);
      } catch (t6) {
        Un(e5, t6);
      }
    }
    function u2(e5, t5, n5, r3, i3) {
      try {
        return { output: t5(n5, r3, i3) };
      } catch (t6) {
        return Un(e5, t6), { error: t6 };
      }
    }
    function c2(e5, t5) {
      var n5 = vt(e5.key, t5.key);
      return n5 !== 0 ? n5 : vt(e5.value, t5.value);
    }
    function f2(e5, t5, n5) {
      return n5 = n5 || 0, typeof t5 == "number" ? e5.slice(n5, t5 + n5) : n5 > 0 ? e5.slice(n5) : e5;
    }
    function l2(e5) {
      var t5 = e5.value;
      return t5 && typeof t5 == "object" && t5._id || e5.id;
    }
    function h2(e5) {
      return function(t5) {
        return e5.include_docs && e5.attachments && e5.binary && function(e6) {
          e6.rows.forEach(function(e7) {
            var t6 = e7.doc && e7.doc._attachments;
            t6 && Object.keys(t6).forEach(function(e8) {
              var n5 = t6[e8];
              t6[e8].data = be(n5.data, n5.content_type);
            });
          });
        }(t5), t5;
      };
    }
    function p2(e5, t5, n5, r3) {
      var i3 = t5[e5];
      i3 !== void 0 && (r3 && (i3 = encodeURIComponent(JSON.stringify(i3))), n5.push(e5 + "=" + i3));
    }
    function v2(e5) {
      if (e5 !== void 0) {
        var t5 = Number(e5);
        return isNaN(t5) || t5 !== parseInt(e5, 10) ? e5 : t5;
      }
    }
    function y2(e5, t5) {
      var n5 = e5.descending ? "endkey" : "startkey", r3 = e5.descending ? "startkey" : "endkey";
      if (e5[n5] !== void 0 && e5[r3] !== void 0 && vt(e5[n5], e5[r3]) > 0)
        throw new jn("No rows can match your key range, reverse your start_key and end_key or set {descending : true}");
      if (t5.reduce && e5.reduce !== false) {
        if (e5.include_docs)
          throw new jn("{include_docs:true} is invalid for reduce");
        if (e5.keys && e5.keys.length > 1 && !e5.group && !e5.group_level)
          throw new jn("Multi-key fetches for reduce views must use {group: true}");
      }
      ["group_level", "limit", "skip"].forEach(function(t6) {
        var n6 = function(e6) {
          if (e6) {
            if (typeof e6 != "number")
              return new jn('Invalid value for integer: "' + e6 + '"');
            if (e6 < 0)
              return new jn('Invalid value for positive integer: "' + e6 + '"');
          }
        }(e5[t6]);
        if (n6)
          throw n6;
      });
    }
    function g2(e5) {
      return function(t5) {
        if (t5.status === 404)
          return e5;
        throw t5;
      };
    }
    function _2(e5) {
      var t5 = typeof e5 == "string" ? e5 : e5.name, n5 = Nn[t5];
      return n5 || (n5 = Nn[t5] = new In()), n5;
    }
    function m2(e5, t5) {
      return qn(_2(e5), function() {
        return function(e6, t6) {
          var n5, o3;
          var s2 = function(e7, t7) {
            if (typeof e7 == "function" && e7.length === 2) {
              var n6 = e7;
              return function(e8) {
                return n6(e8, t7);
              };
            }
            return Bn(e7.toString(), t7);
          }(e6.mapFun, function(e7, t7) {
            var r3 = { id: o3._id, key: yt(e7) };
            t7 != null && (r3.value = yt(t7)), n5.push(r3);
          }), u3 = e6.seq || 0;
          function f3(t7, n6) {
            return function() {
              return function(e7, t8, n7) {
                var i3 = "_local/lastSeq";
                return e7.db.get(i3).catch(g2({ _id: i3, seq: 0 })).then(function(i4) {
                  var o4 = Sn(t8);
                  return Promise.all(o4.map(function(n8) {
                    return function(e8, t9, n9) {
                      var i5 = "_local/doc_" + e8, o5 = { _id: i5, keys: [] }, s3 = n9.get(e8), a3 = s3[0];
                      return (function(e9) {
                        return e9.length === 1 && /^1-/.test(e9[0].rev);
                      }(s3[1]) ? Promise.resolve(o5) : t9.db.get(i5).catch(g2(o5))).then(function(e9) {
                        return function(e10) {
                          return e10.keys.length ? t9.db.allDocs({ keys: e10.keys, include_docs: true }) : Promise.resolve({ rows: [] });
                        }(e9).then(function(t10) {
                          return function(e10, t11) {
                            for (var n10 = [], i6 = new r2(), o6 = 0, s4 = t11.rows.length; o6 < s4; o6++) {
                              var u4 = t11.rows[o6].doc;
                              if (u4 && (n10.push(u4), i6.add(u4._id), u4._deleted = !a3.has(u4._id), !u4._deleted)) {
                                var c3 = a3.get(u4._id);
                                "value" in c3 && (u4.value = c3.value);
                              }
                            }
                            var f4 = Sn(a3);
                            return f4.forEach(function(e11) {
                              if (!i6.has(e11)) {
                                var t12 = { _id: e11 }, r3 = a3.get(e11);
                                "value" in r3 && (t12.value = r3.value), n10.push(t12);
                              }
                            }), e10.keys = An(f4.concat(e10.keys)), n10.push(e10), n10;
                          }(e9, t10);
                        });
                      });
                    }(n8, e7, t8);
                  })).then(function(t9) {
                    var r3 = re(t9);
                    return i4.seq = n7, r3.push(i4), e7.db.bulkDocs({ docs: r3 });
                  });
                });
              }(e6, t7, n6);
            };
          }
          let l3 = 0, d2 = { view: e6.name, indexed_docs: l3 };
          e6.sourceDB.emit("indexing", d2);
          var h3 = new In();
          function p3() {
            return e6.sourceDB.changes({ return_docs: true, conflicts: true, include_docs: true, style: "all_docs", since: u3, limit: t6.changes_batch_size }).then(v3);
          }
          function v3(r3) {
            var d3 = r3.results;
            if (!d3.length)
              return;
            var v4 = function(t7) {
              for (var r4 = new i2(), f4 = 0, l4 = t7.length; f4 < l4; f4++) {
                var d4 = t7[f4];
                if (d4.doc._id[0] !== "_") {
                  n5 = [], (o3 = d4.doc)._deleted || a2(e6.sourceDB, s2, o3), n5.sort(c2);
                  var h4 = y3(n5);
                  r4.set(d4.doc._id, [h4, d4.changes]);
                }
                u3 = d4.seq;
              }
              return r4;
            }(d3);
            h3.add(f3(v4, u3)), l3 += d3.length;
            let g3 = { view: e6.name, last_seq: r3.last_seq, results_count: d3.length, indexed_docs: l3 };
            return e6.sourceDB.emit("indexing", g3), d3.length < t6.changes_batch_size ? void 0 : p3();
          }
          function y3(e7) {
            for (var t7, n6 = new i2(), r3 = 0, o4 = e7.length; r3 < o4; r3++) {
              var s3 = e7[r3], a3 = [s3.key, s3.id];
              r3 > 0 && vt(s3.key, t7) === 0 && a3.push(r3), n6.set(gt(a3), s3), t7 = s3.key;
            }
            return n6;
          }
          return p3().then(function() {
            return h3.finish();
          }).then(function() {
            e6.seq = u3;
          });
        }(e5, t5);
      })();
    }
    function b2(e5, t5) {
      return qn(_2(e5), function() {
        return function(e6, t6) {
          var n5, r3 = e6.reduceFun && t6.reduce !== false, o3 = t6.skip || 0;
          function s2(t7) {
            return t7.include_docs = true, e6.db.allDocs(t7).then(function(e7) {
              return n5 = e7.total_rows, e7.rows.map(function(e8) {
                if ("value" in e8.doc && typeof e8.doc.value == "object" && e8.doc.value !== null) {
                  var t8 = Object.keys(e8.doc.value).sort(), n6 = ["id", "key", "value"];
                  if (!(t8 < n6 || t8 > n6))
                    return e8.doc.value;
                }
                var r4 = function(e9) {
                  for (var t9 = [], n7 = [], r5 = 0; ; ) {
                    var i3 = e9[r5++];
                    if (i3 !== "\0")
                      switch (i3) {
                        case "1":
                          t9.push(null);
                          break;
                        case "2":
                          t9.push(e9[r5] === "1"), r5++;
                          break;
                        case "3":
                          var o4 = _t(e9, r5);
                          t9.push(o4.num), r5 += o4.length;
                          break;
                        case "4":
                          for (var s3 = ""; ; ) {
                            var a4 = e9[r5];
                            if (a4 === "\0")
                              break;
                            s3 += a4, r5++;
                          }
                          s3 = s3.replace(/\u0001\u0001/g, "\0").replace(/\u0001\u0002/g, "").replace(/\u0002\u0002/g, ""), t9.push(s3);
                          break;
                        case "5":
                          var u3 = { element: [], index: t9.length };
                          t9.push(u3.element), n7.push(u3);
                          break;
                        case "6":
                          var c4 = { element: {}, index: t9.length };
                          t9.push(c4.element), n7.push(c4);
                          break;
                        default:
                          throw new Error("bad collationIndex or unexpectedly reached end of input: " + i3);
                      }
                    else {
                      if (t9.length === 1)
                        return t9.pop();
                      mt(t9, n7);
                    }
                  }
                }(e8.doc._id);
                return { key: r4[0], id: r4[1], value: "value" in e8.doc ? e8.doc.value : null };
              });
            });
          }
          function a3(s3) {
            var a4;
            if (a4 = r3 ? function(e7, t7, n6) {
              n6.group_level === 0 && delete n6.group_level;
              var r4 = n6.group || n6.group_level, i3 = function(e8) {
                var t8 = e8.toString(), n7 = function(e9) {
                  if (/^_sum/.test(e9))
                    return zn;
                  if (/^_count/.test(e9))
                    return Jn;
                  if (/^_stats/.test(e9))
                    return Kn;
                  if (/^_/.test(e9))
                    throw new Error(e9 + " is not a supported reduce function.");
                }(t8);
                return n7 || Bn(t8);
              }(e7.reduceFun), o4 = [], s4 = isNaN(n6.group_level) ? Number.POSITIVE_INFINITY : n6.group_level;
              t7.forEach(function(e8) {
                var t8 = o4[o4.length - 1], n7 = r4 ? e8.key : null;
                if (r4 && Array.isArray(n7) && (n7 = n7.slice(0, s4)), t8 && vt(t8.groupKey, n7) === 0)
                  return t8.keys.push([e8.key, e8.id]), void t8.values.push(e8.value);
                o4.push({ keys: [[e8.key, e8.id]], values: [e8.value], groupKey: n7 });
              }), t7 = [];
              for (var a5 = 0, c5 = o4.length; a5 < c5; a5++) {
                var l3 = o4[a5], d3 = u2(e7.sourceDB, i3, l3.keys, l3.values, false);
                if (d3.error && d3.error instanceof $n)
                  throw d3.error;
                t7.push({ value: d3.error ? null : d3.output, key: l3.groupKey });
              }
              return { rows: f2(t7, n6.limit, n6.skip) };
            }(e6, s3, t6) : t6.keys === void 0 ? { total_rows: n5, offset: o3, rows: s3 } : { total_rows: n5, offset: o3, rows: f2(s3, t6.limit, t6.skip) }, t6.update_seq && (a4.update_seq = e6.seq), t6.include_docs) {
              var c4 = An(s3.map(l2));
              return e6.sourceDB.allDocs({ keys: c4, include_docs: true, conflicts: t6.conflicts, attachments: t6.attachments, binary: t6.binary }).then(function(e7) {
                var t7 = new i2();
                return e7.rows.forEach(function(e8) {
                  t7.set(e8.id, e8.doc);
                }), s3.forEach(function(e8) {
                  var n6 = l2(e8), r4 = t7.get(n6);
                  r4 && (e8.doc = r4);
                }), a4;
              });
            }
            return a4;
          }
          if (t6.keys === void 0 || t6.keys.length || (t6.limit = 0, delete t6.keys), t6.keys !== void 0) {
            var c3 = t6.keys.map(function(e7) {
              var n6 = { startkey: gt([e7]), endkey: gt([e7, {}]) };
              return t6.update_seq && (n6.update_seq = true), s2(n6);
            });
            return Promise.all(c3).then(re).then(a3);
          }
          var d2, h3, p3 = { descending: t6.descending };
          if (t6.update_seq && (p3.update_seq = true), "start_key" in t6 && (d2 = t6.start_key), "startkey" in t6 && (d2 = t6.startkey), "end_key" in t6 && (h3 = t6.end_key), "endkey" in t6 && (h3 = t6.endkey), d2 !== void 0 && (p3.startkey = t6.descending ? gt([d2, {}]) : gt([d2])), h3 !== void 0) {
            var v3 = t6.inclusive_end !== false;
            t6.descending && (v3 = !v3), p3.endkey = gt(v3 ? [h3, {}] : [h3]);
          }
          if (t6.key !== void 0) {
            var y3 = gt([t6.key]), g3 = gt([t6.key, {}]);
            p3.descending ? (p3.endkey = y3, p3.startkey = g3) : (p3.startkey = y3, p3.endkey = g3);
          }
          return r3 || (typeof t6.limit == "number" && (p3.limit = t6.limit), p3.skip = o3), s2(p3).then(a3);
        }(e5, t5);
      })();
    }
    function w2(t5, n5, r3) {
      if (typeof t5._query == "function")
        return function(e5, t6, n6) {
          return new Promise(function(r4, i4) {
            e5._query(t6, n6, function(e6, t7) {
              if (e6)
                return i4(e6);
              r4(t7);
            });
          });
        }(t5, n5, r3);
      if (oe(t5))
        return function(e5, t6, n6) {
          var r4, i4, o4, s2 = [], a4 = "GET";
          if (p2("reduce", n6, s2), p2("include_docs", n6, s2), p2("attachments", n6, s2), p2("limit", n6, s2), p2("descending", n6, s2), p2("group", n6, s2), p2("group_level", n6, s2), p2("skip", n6, s2), p2("stale", n6, s2), p2("conflicts", n6, s2), p2("startkey", n6, s2, true), p2("start_key", n6, s2, true), p2("endkey", n6, s2, true), p2("end_key", n6, s2, true), p2("inclusive_end", n6, s2), p2("key", n6, s2, true), p2("update_seq", n6, s2), s2 = (s2 = s2.join("&")) === "" ? "" : "?" + s2, n6.keys !== void 0) {
            var u4 = "keys=" + encodeURIComponent(JSON.stringify(n6.keys));
            u4.length + s2.length + 1 <= 2e3 ? s2 += (s2[0] === "?" ? "&" : "?") + u4 : (a4 = "POST", typeof t6 == "string" ? r4 = { keys: n6.keys } : t6.keys = n6.keys);
          }
          if (typeof t6 == "string") {
            var c4 = Fn(t6);
            return e5.fetch("_design/" + c4[0] + "/_view/" + c4[1] + s2, { headers: new it({ "Content-Type": "application/json" }), method: a4, body: JSON.stringify(r4) }).then(function(e6) {
              return i4 = e6.ok, o4 = e6.status, e6.json();
            }).then(function(e6) {
              if (!i4)
                throw e6.status = o4, te(e6);
              return e6.rows.forEach(function(e7) {
                if (e7.value && e7.value.error && e7.value.error === "builtin_reduce_error")
                  throw new Error(e7.reason);
              }), e6;
            }).then(h2(n6));
          }
          return r4 = r4 || {}, Object.keys(t6).forEach(function(e6) {
            Array.isArray(t6[e6]) ? r4[e6] = t6[e6] : r4[e6] = t6[e6].toString();
          }), e5.fetch("_temp_view" + s2, { headers: new it({ "Content-Type": "application/json" }), method: "POST", body: JSON.stringify(r4) }).then(function(e6) {
            return i4 = e6.ok, o4 = e6.status, e6.json();
          }).then(function(e6) {
            if (!i4)
              throw e6.status = o4, te(e6);
            return e6;
          }).then(h2(n6));
        }(t5, n5, r3);
      var i3 = { changes_batch_size: t5.__opts.view_update_changes_batch_size || 50 };
      if (typeof n5 != "string")
        return y2(r3, n5), Rn.add(function() {
          return Mn(t5, "temp_view/temp_view", n5.map, n5.reduce, true, e4).then(function(e5) {
            return t6 = m2(e5, i3).then(function() {
              return b2(e5, r3);
            }), n6 = function() {
              return e5.db.destroy();
            }, t6.then(function(e6) {
              return n6().then(function() {
                return e6;
              });
            }, function(e6) {
              return n6().then(function() {
                throw e6;
              });
            });
            var t6, n6;
          });
        }), Rn.finish();
      var o3 = n5, a3 = Fn(o3), u3 = a3[0], c3 = a3[1];
      return t5.get("_design/" + u3).then(function(n6) {
        var a4 = n6.views && n6.views[c3];
        if (!a4)
          throw new On("ddoc " + n6._id + " has no view named " + c3);
        return function(e5, t6) {
          var n7 = e5.views && e5.views[t6];
          if (typeof n7.map != "string")
            throw new On("ddoc " + e5._id + " has no string view named " + t6 + ", instead found object of type: " + typeof n7.map);
        }(n6, c3), y2(r3, a4), Mn(t5, o3, a4.map, a4.reduce, false, e4).then(function(e5) {
          return r3.stale === "ok" || r3.stale === "update_after" ? (r3.stale === "update_after" && s()(function() {
            m2(e5, i3);
          }), b2(e5, r3)) : m2(e5, i3).then(function() {
            return b2(e5, r3);
          });
        });
      });
    }
    var k2;
    return { query: function(e5, t5, n5) {
      var r3 = this;
      typeof t5 == "function" && (n5 = t5, t5 = {}), t5 = t5 ? function(e6) {
        return e6.group_level = v2(e6.group_level), e6.limit = v2(e6.limit), e6.skip = v2(e6.skip), e6;
      }(t5) : {}, typeof e5 == "function" && (e5 = { map: e5 });
      var i3 = Promise.resolve().then(function() {
        return w2(r3, e5, t5);
      });
      return xn(i3, n5), i3;
    }, viewCleanup: (k2 = function() {
      var e5 = this;
      return typeof e5._viewCleanup == "function" ? function(e6) {
        return new Promise(function(t5, n5) {
          e6._viewCleanup(function(e7, r3) {
            if (e7)
              return n5(e7);
            t5(r3);
          });
        });
      }(e5) : oe(e5) ? function(e6) {
        return e6.fetch("_view_cleanup", { headers: new it({ "Content-Type": "application/json" }), method: "POST" }).then(function(e7) {
          return e7.json();
        });
      }(e5) : function(e6) {
        return e6.get("_local/mrviews").then(function(t5) {
          var n5 = new i2();
          Object.keys(t5.views).forEach(function(e7) {
            var t6 = Fn(e7), i3 = "_design/" + t6[0], o4 = t6[1], s2 = n5.get(i3);
            s2 || (s2 = new r2(), n5.set(i3, s2)), s2.add(o4);
          });
          var o3 = { keys: Sn(n5), include_docs: true };
          return e6.allDocs(o3).then(function(r3) {
            var i3 = {};
            r3.rows.forEach(function(e7) {
              var r4 = e7.key.substring(8);
              n5.get(e7.key).forEach(function(n6) {
                var o5 = r4 + "/" + n6;
                t5.views[o5] || (o5 = n6);
                var s2 = Object.keys(t5.views[o5]), a3 = e7.doc && e7.doc.views && e7.doc.views[n6];
                s2.forEach(function(e8) {
                  i3[e8] = i3[e8] || a3;
                });
              });
            });
            var o4 = Object.keys(i3).filter(function(e7) {
              return !i3[e7];
            }).map(function(t6) {
              return qn(_2(t6), function() {
                return new e6.constructor(t6, e6.__opts).destroy();
              })();
            });
            return Promise.all(o4).then(function() {
              return { ok: true };
            });
          });
        }, g2({ ok: true }));
      }(e5);
    }, d()(function(e5) {
      var t5 = e5.pop(), n5 = k2.apply(this, e5);
      return typeof t5 == "function" && xn(n5, t5), n5;
    })) };
  }("mrviews"), Qn = { query: function(e4, t4, n4) {
    return Vn.query.call(this, e4, t4, n4);
  }, viewCleanup: function(e4) {
    return Vn.viewCleanup.call(this, e4);
  } };
  function Gn(e4) {
    return /^1-/.test(e4);
  }
  function Wn(e4, t4) {
    var n4 = Object.keys(t4._attachments);
    return Promise.all(n4.map(function(n5) {
      return e4.getAttachment(t4._id, n5, { rev: t4._rev });
    }));
  }
  function Zn(e4, t4, n4, r3) {
    n4 = O(n4);
    var i3 = [], o2 = true;
    return Promise.resolve().then(function() {
      var t5 = Object.keys(n4).filter(function(e5) {
        var t6 = n4[e5].missing;
        return t6.length === 1 && Gn(t6[0]);
      });
      if (t5.length > 0)
        return function(t6) {
          return e4.allDocs({ keys: t6, include_docs: true, conflicts: true }).then(function(e5) {
            if (r3.cancelled)
              throw new Error("cancelled");
            e5.rows.forEach(function(e6) {
              var t7;
              e6.deleted || !e6.doc || !Gn(e6.value.rev) || (t7 = e6.doc)._attachments && Object.keys(t7._attachments).length > 0 || function(e7) {
                return e7._conflicts && e7._conflicts.length > 0;
              }(e6.doc) || (e6.doc._conflicts && delete e6.doc._conflicts, i3.push(e6.doc), delete n4[e6.id]);
            });
          });
        }(t5);
    }).then(function() {
      var s2 = function(e5) {
        var t5 = [];
        return Object.keys(e5).forEach(function(n5) {
          e5[n5].missing.forEach(function(e6) {
            t5.push({ id: n5, rev: e6 });
          });
        }), { docs: t5, revs: true, latest: true };
      }(n4);
      if (s2.docs.length)
        return e4.bulkGet(s2).then(function(n5) {
          if (r3.cancelled)
            throw new Error("cancelled");
          return Promise.all(n5.results.map(function(n6) {
            return Promise.all(n6.docs.map(function(n7) {
              var r4 = n7.ok;
              return n7.error && (o2 = false), r4 && r4._attachments ? function(e5, t5, n8) {
                var r5 = oe(t5) && !oe(e5), i4 = Object.keys(n8._attachments);
                return r5 ? e5.get(n8._id).then(function(r6) {
                  return Promise.all(i4.map(function(i5) {
                    return function(e6, t6, n9) {
                      return !e6._attachments || !e6._attachments[n9] || e6._attachments[n9].digest !== t6._attachments[n9].digest;
                    }(r6, n8, i5) ? t5.getAttachment(n8._id, i5) : e5.getAttachment(r6._id, i5);
                  }));
                }).catch(function(e6) {
                  if (e6.status !== 404)
                    throw e6;
                  return Wn(t5, n8);
                }) : Wn(t5, n8);
              }(t4, e4, r4).then(function(e5) {
                var t5 = Object.keys(r4._attachments);
                return e5.forEach(function(e6, n8) {
                  var i4 = r4._attachments[t5[n8]];
                  delete i4.stub, delete i4.length, i4.data = e6;
                }), r4;
              }) : r4;
            }));
          })).then(function(e5) {
            i3 = i3.concat(re(e5).filter(Boolean));
          });
        });
    }).then(function() {
      return { ok: o2, docs: i3 };
    });
  }
  var Xn = "pouchdb";
  function Yn(e4, t4, n4, r3, i3) {
    return e4.get(t4).catch(function(n5) {
      if (n5.status === 404)
        return e4.adapter !== "http" && e4.adapter !== "https" || I(404, "PouchDB is just checking if a remote checkpoint exists."), { session_id: r3, _id: t4, history: [], replicator: Xn, version: 1 };
      throw n5;
    }).then(function(o2) {
      if (!i3.cancelled && o2.last_seq !== n4)
        return o2.history = (o2.history || []).filter(function(e5) {
          return e5.session_id !== r3;
        }), o2.history.unshift({ last_seq: n4, session_id: r3 }), o2.history = o2.history.slice(0, 5), o2.version = 1, o2.replicator = Xn, o2.session_id = r3, o2.last_seq = n4, e4.put(o2).catch(function(o3) {
          if (o3.status === 409)
            return Yn(e4, t4, n4, r3, i3);
          throw o3;
        });
    });
  }
  function Hn(e4, t4, n4, r3, i3) {
    this.src = e4, this.target = t4, this.id = n4, this.returnValue = r3, this.opts = i3 || {};
  }
  Hn.prototype.writeCheckpoint = function(e4, t4) {
    var n4 = this;
    return this.updateTarget(e4, t4).then(function() {
      return n4.updateSource(e4, t4);
    });
  }, Hn.prototype.updateTarget = function(e4, t4) {
    return this.opts.writeTargetCheckpoint ? Yn(this.target, this.id, e4, t4, this.returnValue) : Promise.resolve(true);
  }, Hn.prototype.updateSource = function(e4, t4) {
    if (this.opts.writeSourceCheckpoint) {
      var n4 = this;
      return Yn(this.src, this.id, e4, t4, this.returnValue).catch(function(e5) {
        if (rr(e5))
          return n4.opts.writeSourceCheckpoint = false, true;
        throw e5;
      });
    }
    return Promise.resolve(true);
  };
  var er = { undefined: function(e4, t4) {
    return vt(e4.last_seq, t4.last_seq) === 0 ? t4.last_seq : 0;
  }, 1: function(e4, t4) {
    return (n4 = t4, r3 = e4, n4.session_id === r3.session_id ? { last_seq: n4.last_seq, history: n4.history } : tr(n4.history, r3.history)).last_seq;
    var n4, r3;
  } };
  function tr(e4, t4) {
    var n4 = e4[0], r3 = e4.slice(1), i3 = t4[0], o2 = t4.slice(1);
    return n4 && t4.length !== 0 ? nr(n4.session_id, t4) ? { last_seq: n4.last_seq, history: e4 } : nr(i3.session_id, r3) ? { last_seq: i3.last_seq, history: o2 } : tr(r3, o2) : { last_seq: 0, history: [] };
  }
  function nr(e4, t4) {
    var n4 = t4[0], r3 = t4.slice(1);
    return !(!e4 || t4.length === 0) && (e4 === n4.session_id || nr(e4, r3));
  }
  function rr(e4) {
    return typeof e4.status == "number" && Math.floor(e4.status / 100) === 4;
  }
  function ir(e4, t4, n4, r3, i3) {
    var o2, a2, u2, c2 = [], f2 = { seq: 0, changes: [], docs: [] }, l2 = false, d2 = false, h2 = false, p2 = 0, v2 = n4.continuous || n4.live || false, y2 = n4.batch_size || 100, g2 = n4.batches_limit || 10, _2 = n4.style || "all_docs", m2 = false, b2 = n4.doc_ids, w2 = n4.selector, k2 = [], j2 = Ee();
    i3 = i3 || { ok: true, start_time: new Date().toISOString(), docs_read: 0, docs_written: 0, doc_write_failures: 0, errors: [] };
    var $2 = {};
    function x2() {
      return u2 ? Promise.resolve() : function(e5, t5, n5) {
        var r4 = n5.doc_ids ? n5.doc_ids.sort(vt) : "", i4 = n5.filter ? n5.filter.toString() : "", o3 = "", s2 = "", a3 = "";
        return n5.selector && (a3 = JSON.stringify(n5.selector)), n5.filter && n5.query_params && (o3 = JSON.stringify(function(e6) {
          return Object.keys(e6).sort(vt).reduce(function(t6, n6) {
            return t6[n6] = e6[n6], t6;
          }, {});
        }(n5.query_params))), n5.filter && n5.filter === "_view" && (s2 = n5.view.toString()), Promise.all([e5.id(), t5.id()]).then(function(e6) {
          var t6 = e6[0] + e6[1] + i4 + s2 + o3 + r4 + a3;
          return new Promise(function(e7) {
            qe(t6, e7);
          });
        }).then(function(e6) {
          return "_local/" + e6.replace(/\//g, ".").replace(/\+/g, "_");
        });
      }(e4, t4, n4).then(function(i4) {
        a2 = i4;
        var o3;
        o3 = n4.checkpoint === false ? { writeSourceCheckpoint: false, writeTargetCheckpoint: false } : n4.checkpoint === "source" ? { writeSourceCheckpoint: true, writeTargetCheckpoint: false } : n4.checkpoint === "target" ? { writeSourceCheckpoint: false, writeTargetCheckpoint: true } : { writeSourceCheckpoint: true, writeTargetCheckpoint: true }, u2 = new Hn(e4, t4, a2, r3, o3);
      });
    }
    function q2() {
      if (k2 = [], o2.docs.length !== 0) {
        var e5 = o2.docs, s2 = { timeout: n4.timeout };
        return t4.bulkDocs({ docs: e5, new_edits: false }, s2).then(function(t5) {
          if (r3.cancelled)
            throw D2(), new Error("cancelled");
          var n5 = Object.create(null);
          t5.forEach(function(e6) {
            e6.error && (n5[e6.id] = e6);
          });
          var o3 = Object.keys(n5).length;
          i3.doc_write_failures += o3, i3.docs_written += e5.length - o3, e5.forEach(function(e6) {
            var t6 = n5[e6._id];
            if (t6) {
              i3.errors.push(t6);
              var o4 = (t6.name || "").toLowerCase();
              if (o4 !== "unauthorized" && o4 !== "forbidden")
                throw t6;
              r3.emit("denied", O(t6));
            } else
              k2.push(e6);
          });
        }, function(t5) {
          throw i3.doc_write_failures += e5.length, t5;
        });
      }
    }
    function A2() {
      if (o2.error)
        throw new Error("There was a problem getting docs.");
      i3.last_seq = p2 = o2.seq;
      var e5 = O(i3);
      return k2.length && (e5.docs = k2, typeof o2.pending == "number" && (e5.pending = o2.pending, delete o2.pending), r3.emit("change", e5)), l2 = true, u2.writeCheckpoint(o2.seq, j2).then(function() {
        if (r3.emit("checkpoint", { checkpoint: o2.seq }), l2 = false, r3.cancelled)
          throw D2(), new Error("cancelled");
        o2 = void 0, M2();
      }).catch(function(e6) {
        throw R2(e6), e6;
      });
    }
    function S2() {
      return Zn(e4, t4, o2.diffs, r3).then(function(e5) {
        o2.error = !e5.ok, e5.docs.forEach(function(e6) {
          delete o2.diffs[e6._id], i3.docs_read++, o2.docs.push(e6);
        });
      });
    }
    function E2() {
      var e5;
      r3.cancelled || o2 || (c2.length !== 0 ? (o2 = c2.shift(), r3.emit("checkpoint", { start_next_batch: o2.seq }), (e5 = {}, o2.changes.forEach(function(t5) {
        r3.emit("checkpoint", { revs_diff: t5 }), t5.id !== "_user/" && (e5[t5.id] = t5.changes.map(function(e6) {
          return e6.rev;
        }));
      }), t4.revsDiff(e5).then(function(e6) {
        if (r3.cancelled)
          throw D2(), new Error("cancelled");
        o2.diffs = e6;
      })).then(S2).then(q2).then(A2).then(E2).catch(function(e6) {
        C2("batch processing terminated with error", e6);
      })) : P2(true));
    }
    function P2(e5) {
      f2.changes.length !== 0 ? (e5 || d2 || f2.changes.length >= y2) && (c2.push(f2), f2 = { seq: 0, changes: [], docs: [] }, r3.state !== "pending" && r3.state !== "stopped" || (r3.state = "active", r3.emit("active")), E2()) : c2.length !== 0 || o2 || ((v2 && $2.live || d2) && (r3.state = "pending", r3.emit("paused")), d2 && D2());
    }
    function C2(e5, t5) {
      h2 || (t5.message || (t5.message = e5), i3.ok = false, i3.status = "aborting", c2 = [], f2 = { seq: 0, changes: [], docs: [] }, D2(t5));
    }
    function D2(o3) {
      if (!(h2 || r3.cancelled && (i3.status = "cancelled", l2)))
        if (i3.status = i3.status || "complete", i3.end_time = new Date().toISOString(), i3.last_seq = p2, h2 = true, o3) {
          (o3 = ee(o3)).result = i3;
          var s2 = (o3.name || "").toLowerCase();
          s2 === "unauthorized" || s2 === "forbidden" ? (r3.emit("error", o3), r3.removeAllListeners()) : function(e5, t5, n5, r4) {
            if (e5.retry === false)
              return t5.emit("error", n5), void t5.removeAllListeners();
            if (typeof e5.back_off_function != "function" && (e5.back_off_function = B), t5.emit("requestError", n5), t5.state === "active" || t5.state === "pending") {
              t5.emit("paused", n5), t5.state = "stopped";
              var i4 = function() {
                e5.current_back_off = 0;
              };
              t5.once("paused", function() {
                t5.removeListener("active", i4);
              }), t5.once("active", i4);
            }
            e5.current_back_off = e5.current_back_off || 0, e5.current_back_off = e5.back_off_function(e5.current_back_off), setTimeout(r4, e5.current_back_off);
          }(n4, r3, o3, function() {
            ir(e4, t4, n4, r3);
          });
        } else
          r3.emit("complete", i3), r3.removeAllListeners();
    }
    function L2(e5, t5, i4) {
      if (r3.cancelled)
        return D2();
      typeof t5 == "number" && (f2.pending = t5), ne(n4)(e5) && (f2.seq = e5.seq || i4, f2.changes.push(e5), r3.emit("checkpoint", { pending_batch: f2.seq }), s()(function() {
        P2(c2.length === 0 && $2.live);
      }));
    }
    function I2(e5) {
      if (m2 = false, r3.cancelled)
        return D2();
      if (e5.results.length > 0)
        $2.since = e5.results[e5.results.length - 1].seq, M2(), P2(true);
      else {
        var t5 = function() {
          v2 ? ($2.live = true, M2()) : d2 = true, P2(true);
        };
        o2 || e5.results.length !== 0 ? t5() : (l2 = true, u2.writeCheckpoint(e5.last_seq, j2).then(function() {
          l2 = false, i3.last_seq = p2 = e5.last_seq, t5();
        }).catch(R2));
      }
    }
    function T2(e5) {
      if (m2 = false, r3.cancelled)
        return D2();
      C2("changes rejected", e5);
    }
    function M2() {
      if (!m2 && !d2 && c2.length < g2) {
        m2 = true, r3._changes && (r3.removeListener("cancel", r3._abortChanges), r3._changes.cancel()), r3.once("cancel", i4);
        var t5 = e4.changes($2).on("change", L2);
        t5.then(o3, o3), t5.then(I2).catch(T2), n4.retry && (r3._changes = t5, r3._abortChanges = i4);
      }
      function i4() {
        t5.cancel();
      }
      function o3() {
        r3.removeListener("cancel", i4);
      }
    }
    function N2() {
      x2().then(function() {
        if (!r3.cancelled)
          return u2.getCheckpoint().then(function(e5) {
            $2 = { since: p2 = e5, limit: y2, batch_size: y2, style: _2, doc_ids: b2, selector: w2, return_docs: true }, n4.filter && (typeof n4.filter != "string" ? $2.include_docs = true : $2.filter = n4.filter), "heartbeat" in n4 && ($2.heartbeat = n4.heartbeat), "timeout" in n4 && ($2.timeout = n4.timeout), n4.query_params && ($2.query_params = n4.query_params), n4.view && ($2.view = n4.view), M2();
          });
        D2();
      }).catch(function(e5) {
        C2("getCheckpoint rejected with ", e5);
      });
    }
    function R2(e5) {
      l2 = false, C2("writeCheckpoint completed with error", e5);
    }
    r3.ready(e4, t4), r3.cancelled ? D2() : (r3._addedListeners || (r3.once("cancel", D2), typeof n4.complete == "function" && (r3.once("error", n4.complete), r3.once("complete", function(e5) {
      n4.complete(null, e5);
    })), r3._addedListeners = true), n4.since === void 0 ? N2() : x2().then(function() {
      return l2 = true, u2.writeCheckpoint(n4.since, j2);
    }).then(function() {
      l2 = false, r3.cancelled ? D2() : (p2 = n4.since, N2());
    }).catch(R2));
  }
  function or() {
    y().call(this), this.cancelled = false, this.state = "pending";
    var e4 = this, t4 = new Promise(function(t5, n4) {
      e4.once("complete", t5), e4.once("error", n4);
    });
    e4.then = function(e5, n4) {
      return t4.then(e5, n4);
    }, e4.catch = function(e5) {
      return t4.catch(e5);
    }, e4.catch(function() {
    });
  }
  function sr(e4, t4) {
    var n4 = t4.PouchConstructor;
    return typeof e4 == "string" ? new n4(e4, t4) : e4;
  }
  function ar(e4, t4, n4, r3) {
    if (typeof n4 == "function" && (r3 = n4, n4 = {}), n4 === void 0 && (n4 = {}), n4.doc_ids && !Array.isArray(n4.doc_ids))
      throw ee(W, "`doc_ids` filter parameter is not a list.");
    n4.complete = r3, (n4 = O(n4)).continuous = n4.continuous || n4.live, n4.retry = "retry" in n4 && n4.retry, n4.PouchConstructor = n4.PouchConstructor || this;
    var i3 = new or(n4);
    return ir(sr(e4, n4), sr(t4, n4), n4, i3), i3;
  }
  function ur(e4, t4, n4, r3) {
    return typeof n4 == "function" && (r3 = n4, n4 = {}), n4 === void 0 && (n4 = {}), (n4 = O(n4)).PouchConstructor = n4.PouchConstructor || this, new cr(e4 = sr(e4, n4), t4 = sr(t4, n4), n4, r3);
  }
  function cr(e4, t4, n4, r3) {
    var i3 = this;
    this.canceled = false;
    var o2 = n4.push ? T({}, n4, n4.push) : n4, s2 = n4.pull ? T({}, n4, n4.pull) : n4;
    function a2(e5) {
      i3.emit("change", { direction: "pull", change: e5 });
    }
    function u2(e5) {
      i3.emit("change", { direction: "push", change: e5 });
    }
    function c2(e5) {
      i3.emit("denied", { direction: "push", doc: e5 });
    }
    function f2(e5) {
      i3.emit("denied", { direction: "pull", doc: e5 });
    }
    function l2() {
      i3.pushPaused = true, i3.pullPaused && i3.emit("paused");
    }
    function d2() {
      i3.pullPaused = true, i3.pushPaused && i3.emit("paused");
    }
    function h2() {
      i3.pushPaused = false, i3.pullPaused && i3.emit("active", { direction: "push" });
    }
    function p2() {
      i3.pullPaused = false, i3.pushPaused && i3.emit("active", { direction: "pull" });
    }
    this.push = ar(e4, t4, o2), this.pull = ar(t4, e4, s2), this.pushPaused = true, this.pullPaused = true;
    var v2 = {};
    function y2(e5) {
      return function(t5, n5) {
        (t5 === "change" && (n5 === a2 || n5 === u2) || t5 === "denied" && (n5 === f2 || n5 === c2) || t5 === "paused" && (n5 === d2 || n5 === l2) || t5 === "active" && (n5 === p2 || n5 === h2)) && (t5 in v2 || (v2[t5] = {}), v2[t5][e5] = true, Object.keys(v2[t5]).length === 2 && i3.removeAllListeners(t5));
      };
    }
    function g2(e5, t5, n5) {
      e5.listeners(t5).indexOf(n5) == -1 && e5.on(t5, n5);
    }
    n4.live && (this.push.on("complete", i3.pull.cancel.bind(i3.pull)), this.pull.on("complete", i3.push.cancel.bind(i3.push))), this.on("newListener", function(e5) {
      e5 === "change" ? (g2(i3.pull, "change", a2), g2(i3.push, "change", u2)) : e5 === "denied" ? (g2(i3.pull, "denied", f2), g2(i3.push, "denied", c2)) : e5 === "active" ? (g2(i3.pull, "active", p2), g2(i3.push, "active", h2)) : e5 === "paused" && (g2(i3.pull, "paused", d2), g2(i3.push, "paused", l2));
    }), this.on("removeListener", function(e5) {
      e5 === "change" ? (i3.pull.removeListener("change", a2), i3.push.removeListener("change", u2)) : e5 === "denied" ? (i3.pull.removeListener("denied", f2), i3.push.removeListener("denied", c2)) : e5 === "active" ? (i3.pull.removeListener("active", p2), i3.push.removeListener("active", h2)) : e5 === "paused" && (i3.pull.removeListener("paused", d2), i3.push.removeListener("paused", l2));
    }), this.pull.on("removeListener", y2("pull")), this.push.on("removeListener", y2("push"));
    var _2 = Promise.all([this.push, this.pull]).then(function(e5) {
      var t5 = { push: e5[0], pull: e5[1] };
      return i3.emit("complete", t5), r3 && r3(null, t5), i3.removeAllListeners(), t5;
    }, function(e5) {
      if (i3.cancel(), r3 ? r3(e5) : i3.emit("error", e5), i3.removeAllListeners(), r3)
        throw e5;
    });
    this.then = function(e5, t5) {
      return _2.then(e5, t5);
    }, this.catch = function(e5) {
      return _2.catch(e5);
    };
  }
  Hn.prototype.getCheckpoint = function() {
    var e4 = this;
    return e4.opts && e4.opts.writeSourceCheckpoint && !e4.opts.writeTargetCheckpoint ? e4.src.get(e4.id).then(function(e5) {
      return e5.last_seq || 0;
    }).catch(function(e5) {
      if (e5.status !== 404)
        throw e5;
      return 0;
    }) : e4.target.get(e4.id).then(function(t4) {
      return e4.opts && e4.opts.writeTargetCheckpoint && !e4.opts.writeSourceCheckpoint ? t4.last_seq || 0 : e4.src.get(e4.id).then(function(e5) {
        return t4.version !== e5.version ? 0 : (n4 = t4.version ? t4.version.toString() : "undefined") in er ? er[n4](t4, e5) : 0;
        var n4;
      }, function(n4) {
        if (n4.status === 404 && t4.last_seq)
          return e4.src.put({ _id: e4.id, last_seq: 0 }).then(function() {
            return 0;
          }, function(n5) {
            return rr(n5) ? (e4.opts.writeSourceCheckpoint = false, t4.last_seq) : 0;
          });
        throw n4;
      });
    }).catch(function(e5) {
      if (e5.status !== 404)
        throw e5;
      return 0;
    });
  }, p()(or, y()), or.prototype.cancel = function() {
    this.cancelled = true, this.state = "cancelled", this.emit("cancel");
  }, or.prototype.ready = function(e4, t4) {
    var n4 = this;
    function r3() {
      n4.cancel();
    }
    function i3() {
      e4.removeListener("destroyed", r3), t4.removeListener("destroyed", r3);
    }
    n4._readyCalled || (n4._readyCalled = true, e4.once("destroyed", r3), t4.once("destroyed", r3), n4.once("complete", i3), n4.once("error", i3));
  }, p()(cr, y()), cr.prototype.cancel = function() {
    this.canceled || (this.canceled = true, this.push.cancel(), this.pull.cancel());
  }, tt.plugin(function(e4) {
    e4.adapter("idb", hn, true);
  }).plugin(function(e4) {
    e4.adapter("http", kn, false), e4.adapter("https", kn, false);
  }).plugin(Qn).plugin(function(e4) {
    e4.replicate = ar, e4.sync = ur, Object.defineProperty(e4.prototype, "replicate", { get: function() {
      var e5 = this;
      return this.replicateMethods === void 0 && (this.replicateMethods = { from: function(t4, n4, r3) {
        return e5.constructor.replicate(t4, e5, n4, r3);
      }, to: function(t4, n4, r3) {
        return e5.constructor.replicate(e5, t4, n4, r3);
      } }), this.replicateMethods;
    } }), e4.prototype.sync = function(e5, t4, n4) {
      return this.constructor.sync(this, e5, t4, n4);
    };
  });
  const fr = tt;
}, 614: (e3, t3, n3) => {
  n3.d(t3, { Z: () => vt });
  var r2 = n3(717), i2 = n3.n(r2);
  function o(e4, t4, n4) {
    Error.call(this, n4), this.status = e4, this.name = t4, this.message = n4, this.error = true;
  }
  i2()(o, Error), o.prototype.toString = function() {
    return JSON.stringify({ status: this.status, name: this.name, message: this.message, reason: this.reason });
  }, new o(401, "unauthorized", "Name or password is incorrect."), new o(400, "bad_request", "Missing JSON list of 'docs'"), new o(404, "not_found", "missing"), new o(409, "conflict", "Document update conflict"), new o(400, "bad_request", "_id field must contain a string"), new o(412, "missing_id", "_id is required for puts"), new o(400, "bad_request", "Only reserved document ids may start with underscore."), new o(412, "precondition_failed", "Database not open");
  var s = new o(500, "unknown_error", "Database encountered an unknown error");
  function a(e4) {
    if (typeof e4 != "object") {
      var t4 = e4;
      (e4 = s).data = t4;
    }
    return "error" in e4 && e4.error === "conflict" && (e4.name = "conflict", e4.status = 409), "name" in e4 || (e4.name = e4.error || "unknown"), "status" in e4 || (e4.status = 500), "message" in e4 || (e4.message = e4.message || e4.reason), "stack" in e4 || (e4.stack = new Error().stack), e4;
  }
  new o(500, "badarg", "Some query argument is invalid"), new o(400, "invalid_request", "Request was invalid"), new o(400, "query_parse_error", "Some query parameter is invalid"), new o(500, "doc_validation", "Bad special document member"), new o(400, "bad_request", "Something wrong with the request"), new o(400, "bad_request", "Document must be a JSON object"), new o(404, "not_found", "Database not found"), new o(500, "indexed_db_went_bad", "unknown"), new o(500, "web_sql_went_bad", "unknown"), new o(500, "levelDB_went_went_bad", "unknown"), new o(403, "forbidden", "Forbidden by design doc validate_doc_update function"), new o(400, "bad_request", "Invalid rev format"), new o(412, "file_exists", "The database could not be created, the file already exists."), new o(412, "missing_stub", "A pre-existing attachment stub wasn't found"), new o(413, "invalid_url", "Provided URL is invalid"), typeof AbortController != "undefined" && AbortController, fetch;
  var u, c, f = Headers;
  function l(e4) {
    return "$" + e4;
  }
  function d(e4) {
    return e4.substring(1);
  }
  function h() {
    this._store = {};
  }
  function p(e4) {
    if (this._store = new h(), e4 && Array.isArray(e4))
      for (var t4 = 0, n4 = e4.length; t4 < n4; t4++)
        this.add(e4[t4]);
  }
  function v(e4) {
    for (var t4 = e4.length, n4 = new ArrayBuffer(t4), r3 = new Uint8Array(n4), i3 = 0; i3 < t4; i3++)
      r3[i3] = e4.charCodeAt(i3);
    return n4;
  }
  function y(e4, t4) {
    return function(e5, t5) {
      return function(e6, t6) {
        e6 = e6 || [], t6 = t6 || {};
        try {
          return new Blob(e6, t6);
        } catch (i3) {
          if (i3.name !== "TypeError")
            throw i3;
          for (var n4 = new (typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder)(), r3 = 0; r3 < e6.length; r3 += 1)
            n4.append(e6[r3]);
          return n4.getBlob(t6.type);
        }
      }([v(e5)], { type: t5 });
    }(atob(e4), t4);
  }
  h.prototype.get = function(e4) {
    var t4 = l(e4);
    return this._store[t4];
  }, h.prototype.set = function(e4, t4) {
    var n4 = l(e4);
    return this._store[n4] = t4, true;
  }, h.prototype.has = function(e4) {
    return l(e4) in this._store;
  }, h.prototype.keys = function() {
    return Object.keys(this._store).map((e4) => d(e4));
  }, h.prototype.delete = function(e4) {
    var t4 = l(e4), n4 = t4 in this._store;
    return delete this._store[t4], n4;
  }, h.prototype.forEach = function(e4) {
    for (var t4 = Object.keys(this._store), n4 = 0, r3 = t4.length; n4 < r3; n4++) {
      var i3 = t4[n4];
      e4(this._store[i3], i3 = d(i3));
    }
  }, Object.defineProperty(h.prototype, "size", { get: function() {
    return Object.keys(this._store).length;
  } }), p.prototype.add = function(e4) {
    return this._store.set(e4, true);
  }, p.prototype.has = function(e4) {
    return this._store.has(e4);
  }, p.prototype.forEach = function(e4) {
    this._store.forEach(function(t4, n4) {
      e4(n4);
    });
  }, Object.defineProperty(p.prototype, "size", { get: function() {
    return this._store.size;
  } }), function() {
    if (typeof Symbol == "undefined" || typeof Map == "undefined" || typeof Set == "undefined")
      return false;
    var e4 = Object.getOwnPropertyDescriptor(Map, Symbol.species);
    return e4 && "get" in e4 && Map[Symbol.species] === Map;
  }() ? (u = Set, c = Map) : (u = p, c = h);
  function g(e4, t4) {
    if (e4 === t4)
      return 0;
    e4 = _(e4), t4 = _(t4);
    var n4 = k(e4), r3 = k(t4);
    if (n4 - r3 != 0)
      return n4 - r3;
    switch (typeof e4) {
      case "number":
        return e4 - t4;
      case "boolean":
        return e4 < t4 ? -1 : 1;
      case "string":
        return function(e5, t5) {
          return e5 === t5 ? 0 : e5 > t5 ? 1 : -1;
        }(e4, t4);
    }
    return Array.isArray(e4) ? function(e5, t5) {
      for (var n5 = Math.min(e5.length, t5.length), r4 = 0; r4 < n5; r4++) {
        var i3 = g(e5[r4], t5[r4]);
        if (i3 !== 0)
          return i3;
      }
      return e5.length === t5.length ? 0 : e5.length > t5.length ? 1 : -1;
    }(e4, t4) : function(e5, t5) {
      for (var n5 = Object.keys(e5), r4 = Object.keys(t5), i3 = Math.min(n5.length, r4.length), o2 = 0; o2 < i3; o2++) {
        var s2 = g(n5[o2], r4[o2]);
        if (s2 !== 0)
          return s2;
        if ((s2 = g(e5[n5[o2]], t5[r4[o2]])) !== 0)
          return s2;
      }
      return n5.length === r4.length ? 0 : n5.length > r4.length ? 1 : -1;
    }(e4, t4);
  }
  function _(e4) {
    switch (typeof e4) {
      case "undefined":
        return null;
      case "number":
        return e4 === 1 / 0 || e4 === -1 / 0 || isNaN(e4) ? null : e4;
      case "object":
        var t4 = e4;
        if (Array.isArray(e4)) {
          var n4 = e4.length;
          e4 = new Array(n4);
          for (var r3 = 0; r3 < n4; r3++)
            e4[r3] = _(t4[r3]);
        } else {
          if (e4 instanceof Date)
            return e4.toJSON();
          if (e4 !== null) {
            for (var i3 in e4 = {}, t4)
              if (Object.prototype.hasOwnProperty.call(t4, i3)) {
                var o2 = t4[i3];
                o2 !== void 0 && (e4[i3] = _(o2));
              }
          }
        }
    }
    return e4;
  }
  function m(e4) {
    return k(e4 = _(e4)) + "" + function(e5) {
      if (e5 !== null)
        switch (typeof e5) {
          case "boolean":
            return e5 ? 1 : 0;
          case "number":
            return function(e6) {
              if (e6 === 0)
                return "1";
              var t5, n5 = e6.toExponential().split(/e\+?/), r4 = parseInt(n5[1], 10), i4 = e6 < 0, o3 = i4 ? "0" : "2";
              o3 += "" + (function(e7, t6, n6) {
                for (var r5 = "", i5 = 3 - e7.length; r5.length < i5; )
                  r5 += "0";
                return r5;
              }(t5 = ((i4 ? -r4 : r4) - -324).toString()) + t5);
              var s3 = Math.abs(parseFloat(n5[0]));
              i4 && (s3 = 10 - s3);
              var a2 = s3.toFixed(20);
              return o3 + "" + a2.replace(/\.?0+$/, "");
            }(e5);
          case "string":
            return e5.replace(/\u0002/g, "").replace(/\u0001/g, "").replace(/\u0000/g, "");
          case "object":
            var t4 = Array.isArray(e5), n4 = t4 ? e5 : Object.keys(e5), r3 = -1, i3 = n4.length, o2 = "";
            if (t4)
              for (; ++r3 < i3; )
                o2 += m(n4[r3]);
            else
              for (; ++r3 < i3; ) {
                var s2 = n4[r3];
                o2 += m(s2) + m(e5[s2]);
              }
            return o2;
        }
      return "";
    }(e4) + "\0";
  }
  function b(e4, t4) {
    var n4, r3 = t4;
    if (e4[t4] === "1")
      n4 = 0, t4++;
    else {
      var i3 = e4[t4] === "0";
      t4++;
      var o2 = "", s2 = e4.substring(t4, t4 + 3), a2 = parseInt(s2, 10) + -324;
      for (i3 && (a2 = -a2), t4 += 3; ; ) {
        var u2 = e4[t4];
        if (u2 === "\0")
          break;
        o2 += u2, t4++;
      }
      n4 = (o2 = o2.split(".")).length === 1 ? parseInt(o2, 10) : parseFloat(o2[0] + "." + o2[1]), i3 && (n4 -= 10), a2 !== 0 && (n4 = parseFloat(n4 + "e" + a2));
    }
    return { num: n4, length: t4 - r3 };
  }
  function w(e4, t4) {
    var n4 = e4.pop();
    if (t4.length) {
      var r3 = t4[t4.length - 1];
      n4 === r3.element && (t4.pop(), r3 = t4[t4.length - 1]);
      var i3 = r3.element, o2 = r3.index;
      Array.isArray(i3) ? i3.push(n4) : o2 === e4.length - 2 ? i3[e4.pop()] = n4 : e4.push(n4);
    }
  }
  function k(e4) {
    var t4 = ["boolean", "number", "string", "object"].indexOf(typeof e4);
    return ~t4 ? e4 === null ? 1 : Array.isArray(e4) ? 5 : t4 < 3 ? t4 + 2 : t4 + 3 : Array.isArray(e4) ? 5 : void 0;
  }
  var j = n3(105), O = n3.n(j), $ = n3(624), x = n3.n($), q = n3(187), A = n3.n(q), S = n3(586), E = n3(322), P = n3.n(E);
  function C(e4) {
    return P().hash(e4);
  }
  self.setImmediate || self.setTimeout;
  var D, L = Function.prototype.toString, B = L.call(Object);
  function I(e4) {
    var t4, n4, r3;
    if (!e4 || typeof e4 != "object")
      return e4;
    if (Array.isArray(e4)) {
      for (t4 = [], n4 = 0, r3 = e4.length; n4 < r3; n4++)
        t4[n4] = I(e4[n4]);
      return t4;
    }
    if (e4 instanceof Date && isFinite(e4))
      return e4.toISOString();
    if (function(e5) {
      return typeof ArrayBuffer != "undefined" && e5 instanceof ArrayBuffer || typeof Blob != "undefined" && e5 instanceof Blob;
    }(e4))
      return function(e5) {
        if (e5 instanceof ArrayBuffer)
          return function(e6) {
            if (typeof e6.slice == "function")
              return e6.slice(0);
            var t6 = new ArrayBuffer(e6.byteLength), n6 = new Uint8Array(t6), r4 = new Uint8Array(e6);
            return n6.set(r4), t6;
          }(e5);
        var t5 = e5.size, n5 = e5.type;
        return typeof e5.slice == "function" ? e5.slice(0, t5, n5) : e5.webkitSlice(0, t5, n5);
      }(e4);
    if (!function(e5) {
      var t5 = Object.getPrototypeOf(e5);
      if (t5 === null)
        return true;
      var n5 = t5.constructor;
      return typeof n5 == "function" && n5 instanceof n5 && L.call(n5) == B;
    }(e4))
      return e4;
    for (n4 in t4 = {}, e4)
      if (Object.prototype.hasOwnProperty.call(e4, n4)) {
        var i3 = I(e4[n4]);
        i3 !== void 0 && (t4[n4] = i3);
      }
    return t4;
  }
  function T(e4) {
    return O()(function(t4) {
      t4 = I(t4);
      var n4 = this, r3 = typeof t4[t4.length - 1] == "function" && t4.pop(), i3 = new Promise(function(r4, i4) {
        var o2, s2, a2;
        try {
          var u2 = (s2 = function(e5, t5) {
            e5 ? i4(e5) : r4(t5);
          }, a2 = false, O()(function(e5) {
            if (a2)
              throw new Error("once called more than once");
            a2 = true, s2.apply(this, e5);
          }));
          t4.push(u2), (o2 = e4.apply(n4, t4)) && typeof o2.then == "function" && r4(o2);
        } catch (e5) {
          i4(e5);
        }
      });
      return r3 && i3.then(function(e5) {
        r3(null, e5);
      }, r3), i3;
    });
  }
  try {
    localStorage.setItem("_pouch_check_localstorage", 1), D = !!localStorage.getItem("_pouch_check_localstorage");
  } catch (e4) {
    D = false;
  }
  function M() {
    return D;
  }
  function N() {
    A().call(this), this._listeners = {}, function(e4) {
      M() && addEventListener("storage", function(t4) {
        e4.emit(t4.key);
      });
    }(this);
  }
  function R(e4) {
    if (typeof console != "undefined" && typeof console[e4] == "function") {
      var t4 = Array.prototype.slice.call(arguments, 1);
      console[e4].apply(console, t4);
    }
  }
  i2()(N, A()), N.prototype.addListener = function(e4, t4, n4, r3) {
    if (!this._listeners[t4]) {
      var i3 = this, o2 = false;
      this._listeners[t4] = s2, this.on(e4, s2);
    }
    function s2() {
      if (i3._listeners[t4])
        if (o2)
          o2 = "waiting";
        else {
          o2 = true;
          var e5 = function(e6, t5) {
            for (var n5 = {}, r4 = 0, i4 = t5.length; r4 < i4; r4++) {
              var o3 = t5[r4];
              o3 in e6 && (n5[o3] = e6[o3]);
            }
            return n5;
          }(r3, ["style", "include_docs", "attachments", "conflicts", "filter", "doc_ids", "view", "since", "query_params", "binary", "return_docs"]);
          n4.changes(e5).on("change", function(e6) {
            e6.seq > r3.since && !r3.cancelled && (r3.since = e6.seq, r3.onChange(e6));
          }).on("complete", function() {
            o2 === "waiting" && x()(s2), o2 = false;
          }).on("error", function() {
            o2 = false;
          });
        }
    }
  }, N.prototype.removeListener = function(e4, t4) {
    t4 in this._listeners && (A().prototype.removeListener.call(this, e4, this._listeners[t4]), delete this._listeners[t4]);
  }, N.prototype.notifyLocalWindows = function(e4) {
    M() && (localStorage[e4] = localStorage[e4] === "a" ? "b" : "a");
  }, N.prototype.notify = function(e4) {
    this.emit(e4), this.notifyLocalWindows(e4);
  };
  var F = typeof Object.assign == "function" ? Object.assign : function(e4) {
    for (var t4 = Object(e4), n4 = 1; n4 < arguments.length; n4++) {
      var r3 = arguments[n4];
      if (r3 != null)
        for (var i3 in r3)
          Object.prototype.hasOwnProperty.call(r3, i3) && (t4[i3] = r3[i3]);
    }
    return t4;
  };
  function U(e4) {
    for (var t4 = [], n4 = 0, r3 = e4.length; n4 < r3; n4++)
      t4 = t4.concat(e4[n4]);
    return t4;
  }
  function z(e4) {
    return typeof e4._remote == "boolean" ? e4._remote : typeof e4.type == "function" && (R("warn", "db.type() is deprecated and will be removed in a future version of PouchDB"), e4.type() === "http");
  }
  function J(e4, t4, n4) {
    return e4.get(t4).catch(function(e5) {
      if (e5.status !== 404)
        throw e5;
      return {};
    }).then(function(r3) {
      var i3 = r3._rev, o2 = n4(r3);
      return o2 ? (o2._id = t4, o2._rev = i3, function(e5, t5, n5) {
        return e5.put(t5).then(function(e6) {
          return { updated: true, rev: e6.rev };
        }, function(r4) {
          if (r4.status !== 409)
            throw r4;
          return J(e5, t5._id, n5);
        });
      }(e4, o2, n4)) : { updated: false, rev: i3 };
    });
  }
  function K(e4) {
    this.status = 400, this.name = "query_parse_error", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, K);
    } catch (e5) {
    }
  }
  function V(e4) {
    this.status = 404, this.name = "not_found", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, V);
    } catch (e5) {
    }
  }
  function Q(e4) {
    this.status = 500, this.name = "invalid_value", this.message = e4, this.error = true;
    try {
      Error.captureStackTrace(this, Q);
    } catch (e5) {
    }
  }
  function G(e4, t4) {
    return t4 && e4.then(function(e5) {
      x()(function() {
        t4(null, e5);
      });
    }, function(e5) {
      x()(function() {
        t4(e5);
      });
    }), e4;
  }
  function W(e4, t4) {
    return function() {
      var n4 = arguments, r3 = this;
      return e4.add(function() {
        return t4.apply(r3, n4);
      });
    };
  }
  function Z(e4) {
    var t4 = new u(e4), n4 = new Array(t4.size), r3 = -1;
    return t4.forEach(function(e5) {
      n4[++r3] = e5;
    }), n4;
  }
  function X(e4) {
    var t4 = new Array(e4.size), n4 = -1;
    return e4.forEach(function(e5, r3) {
      t4[++n4] = r3;
    }), t4;
  }
  function Y() {
    this.promise = new Promise(function(e4) {
      e4();
    });
  }
  function H(e4) {
    if (!e4)
      return "undefined";
    switch (typeof e4) {
      case "function":
      case "string":
        return e4.toString();
      default:
        return JSON.stringify(e4);
    }
  }
  function ee(e4, t4, n4, r3, i3, o2) {
    var s2, a2 = function(e5, t5) {
      return H(e5) + H(t5) + "undefined";
    }(n4, r3);
    if (!i3 && (s2 = e4._cachedViews = e4._cachedViews || {})[a2])
      return s2[a2];
    var u2 = e4.info().then(function(u3) {
      var c2 = u3.db_name + "-mrview-" + (i3 ? "temp" : C(a2));
      return J(e4, "_local/" + o2, function(e5) {
        e5.views = e5.views || {};
        var n5 = t4;
        n5.indexOf("/") === -1 && (n5 = t4 + "/" + t4);
        var r4 = e5.views[n5] = e5.views[n5] || {};
        if (!r4[c2])
          return r4[c2] = true, e5;
      }).then(function() {
        return e4.registerDependentDatabase(c2).then(function(t5) {
          var i4 = t5.db;
          i4.auto_compaction = true;
          var o3 = { name: c2, db: i4, sourceDB: e4, adapter: e4.adapter, mapFun: n4, reduceFun: r3 };
          return o3.db.get("_local/lastSeq").catch(function(e5) {
            if (e5.status !== 404)
              throw e5;
          }).then(function(e5) {
            return o3.seq = e5 ? e5.seq : 0, s2 && o3.db.once("destroyed", function() {
              delete s2[a2];
            }), o3;
          });
        });
      });
    });
    return s2 && (s2[a2] = u2), u2;
  }
  S.Z, i2()(K, Error), i2()(V, Error), i2()(Q, Error), Y.prototype.add = function(e4) {
    return this.promise = this.promise.catch(function() {
    }).then(function() {
      return e4();
    }), this.promise;
  }, Y.prototype.finish = function() {
    return this.promise;
  };
  var te = {}, ne = new Y();
  function re(e4) {
    return e4.indexOf("/") === -1 ? [e4, e4] : e4.split("/");
  }
  function ie(e4, t4) {
    try {
      e4.emit("error", t4);
    } catch (e5) {
      R("error", "The user's map/reduce function threw an uncaught error.\nYou can debug this error by doing:\nmyDatabase.on('error', function (err) { debugger; });\nPlease double-check your map/reduce function."), R("error", t4);
    }
  }
  function oe(e4, t4) {
    for (var n4 = e4, r3 = 0, i3 = t4.length; r3 < i3 && (n4 = n4[t4[r3]]); r3++)
      ;
    return n4;
  }
  function se(e4, t4, n4) {
    for (var r3 = 0, i3 = t4.length; r3 < i3 - 1; r3++) {
      var o2 = t4[r3];
      e4 = e4[o2] = e4[o2] || {};
    }
    e4[t4[i3 - 1]] = n4;
  }
  function ae(e4, t4) {
    return e4 < t4 ? -1 : e4 > t4 ? 1 : 0;
  }
  function ue(e4) {
    for (var t4 = [], n4 = "", r3 = 0, i3 = e4.length; r3 < i3; r3++) {
      var o2 = e4[r3];
      r3 > 0 && e4[r3 - 1] === "\\" && (o2 === "$" || o2 === ".") ? n4 = n4.substring(0, n4.length - 1) + o2 : o2 === "." ? (t4.push(n4), n4 = "") : n4 += o2;
    }
    return t4.push(n4), t4;
  }
  var ce = ["$or", "$nor", "$not"];
  function fe(e4) {
    return ce.indexOf(e4) > -1;
  }
  function le(e4) {
    return Object.keys(e4)[0];
  }
  function de(e4) {
    return e4[le(e4)];
  }
  function he(e4) {
    var t4 = {}, n4 = { $or: true, $nor: true };
    return e4.forEach(function(e5) {
      Object.keys(e5).forEach(function(r3) {
        var i3 = e5[r3];
        if (typeof i3 != "object" && (i3 = { $eq: i3 }), fe(r3))
          if (i3 instanceof Array) {
            if (n4[r3])
              return n4[r3] = false, void (t4[r3] = i3);
            var o2 = [];
            t4[r3].forEach(function(e6) {
              Object.keys(i3).forEach(function(t5) {
                var n5 = i3[t5], r4 = Math.max(Object.keys(e6).length, Object.keys(n5).length), s3 = he([e6, n5]);
                Object.keys(s3).length <= r4 || o2.push(s3);
              });
            }), t4[r3] = o2;
          } else
            t4[r3] = he([i3]);
        else {
          var s2 = t4[r3] = t4[r3] || {};
          Object.keys(i3).forEach(function(e6) {
            var t5 = i3[e6];
            return e6 === "$gt" || e6 === "$gte" ? function(e7, t6, n5) {
              n5.$eq === void 0 && (n5.$gte !== void 0 ? e7 === "$gte" ? t6 > n5.$gte && (n5.$gte = t6) : t6 >= n5.$gte && (delete n5.$gte, n5.$gt = t6) : n5.$gt !== void 0 ? e7 === "$gte" ? t6 > n5.$gt && (delete n5.$gt, n5.$gte = t6) : t6 > n5.$gt && (n5.$gt = t6) : n5[e7] = t6);
            }(e6, t5, s2) : e6 === "$lt" || e6 === "$lte" ? function(e7, t6, n5) {
              n5.$eq === void 0 && (n5.$lte !== void 0 ? e7 === "$lte" ? t6 < n5.$lte && (n5.$lte = t6) : t6 <= n5.$lte && (delete n5.$lte, n5.$lt = t6) : n5.$lt !== void 0 ? e7 === "$lte" ? t6 < n5.$lt && (delete n5.$lt, n5.$lte = t6) : t6 < n5.$lt && (n5.$lt = t6) : n5[e7] = t6);
            }(e6, t5, s2) : e6 === "$ne" ? function(e7, t6) {
              "$ne" in t6 ? t6.$ne.push(e7) : t6.$ne = [e7];
            }(t5, s2) : e6 === "$eq" ? function(e7, t6) {
              delete t6.$gt, delete t6.$gte, delete t6.$lt, delete t6.$lte, delete t6.$ne, t6.$eq = e7;
            }(t5, s2) : e6 === "$regex" ? function(e7, t6) {
              "$regex" in t6 ? t6.$regex.push(e7) : t6.$regex = [e7];
            }(t5, s2) : void (s2[e6] = t5);
          });
        }
      });
    }), t4;
  }
  function pe(e4) {
    for (var t4 in e4) {
      if (Array.isArray(e4))
        for (var n4 in e4)
          e4[n4].$and && (e4[n4] = he(e4[n4].$and));
      var r3 = e4[t4];
      typeof r3 == "object" && pe(r3);
    }
    return e4;
  }
  function ve(e4, t4) {
    for (var n4 in e4) {
      n4 === "$and" && (t4 = true);
      var r3 = e4[n4];
      typeof r3 == "object" && (t4 = ve(r3, t4));
    }
    return t4;
  }
  function ye(e4) {
    var t4 = I(e4), n4 = false;
    ve(t4, false) && ("$and" in (t4 = pe(t4)) && (t4 = he(t4.$and)), n4 = true), ["$or", "$nor"].forEach(function(e5) {
      e5 in t4 && t4[e5].forEach(function(e6) {
        for (var t5 = Object.keys(e6), n5 = 0; n5 < t5.length; n5++) {
          var r4 = t5[n5], i4 = e6[r4];
          typeof i4 == "object" && i4 !== null || (e6[r4] = { $eq: i4 });
        }
      });
    }), "$not" in t4 && (t4.$not = he([t4.$not]));
    for (var r3 = Object.keys(t4), i3 = 0; i3 < r3.length; i3++) {
      var o2 = r3[i3], s2 = t4[o2];
      typeof s2 != "object" || s2 === null ? s2 = { $eq: s2 } : n4 || ("$ne" in s2 && (s2.$ne = [s2.$ne]), "$regex" in s2 && (s2.$regex = [s2.$regex])), t4[o2] = s2;
    }
    return t4;
  }
  function ge(e4, t4, n4) {
    if (e4 = e4.filter(function(e5) {
      return _e(e5.doc, t4.selector, n4);
    }), t4.sort) {
      var r3 = function(e5) {
        function t5(t6) {
          return e5.map(function(e6) {
            var n5 = ue(le(e6));
            return oe(t6, n5);
          });
        }
        return function(e6, n5) {
          var r4 = g(t5(e6.doc), t5(n5.doc));
          return r4 !== 0 ? r4 : ae(e6.doc._id, n5.doc._id);
        };
      }(t4.sort);
      e4 = e4.sort(r3), typeof t4.sort[0] != "string" && de(t4.sort[0]) === "desc" && (e4 = e4.reverse());
    }
    if ("limit" in t4 || "skip" in t4) {
      var i3 = t4.skip || 0, o2 = ("limit" in t4 ? t4.limit : e4.length) + i3;
      e4 = e4.slice(i3, o2);
    }
    return e4;
  }
  function _e(e4, t4, n4) {
    return n4.every(function(n5) {
      var r3 = t4[n5], i3 = ue(n5), o2 = oe(e4, i3);
      return fe(n5) ? function(e5, t5, n6) {
        return e5 === "$or" ? t5.some(function(e6) {
          return _e(n6, e6, Object.keys(e6));
        }) : e5 === "$not" ? !_e(n6, t5, Object.keys(t5)) : !t5.find(function(e6) {
          return _e(n6, e6, Object.keys(e6));
        });
      }(n5, r3, e4) : me(r3, e4, i3, o2);
    });
  }
  function me(e4, t4, n4, r3) {
    return !e4 || (typeof e4 == "object" ? Object.keys(e4).every(function(i3) {
      var o2 = e4[i3];
      if (i3.indexOf("$") === 0)
        return be(i3, t4, o2, n4, r3);
      var s2 = ue(i3);
      if (r3 === void 0 && typeof o2 != "object" && s2.length > 0)
        return false;
      var a2 = oe(r3, s2);
      return typeof o2 == "object" ? me(o2, t4, n4, a2) : be("$eq", t4, o2, s2, a2);
    }) : e4 === r3);
  }
  function be(e4, t4, n4, r3, i3) {
    if (!Oe[e4])
      throw new Error('unknown operator "' + e4 + '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, $nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
    return Oe[e4](t4, n4, r3, i3);
  }
  function we(e4) {
    return e4 != null;
  }
  function ke(e4) {
    return e4 !== void 0;
  }
  function je(e4, t4) {
    return t4.some(function(t5) {
      return e4 instanceof Array ? e4.some(function(e5) {
        return g(t5, e5) === 0;
      }) : g(t5, e4) === 0;
    });
  }
  var Oe = { $elemMatch: function(e4, t4, n4, r3) {
    return !!Array.isArray(r3) && r3.length !== 0 && (typeof r3[0] == "object" ? r3.some(function(e5) {
      return _e(e5, t4, Object.keys(t4));
    }) : r3.some(function(r4) {
      return me(t4, e4, n4, r4);
    }));
  }, $allMatch: function(e4, t4, n4, r3) {
    return !!Array.isArray(r3) && r3.length !== 0 && (typeof r3[0] == "object" ? r3.every(function(e5) {
      return _e(e5, t4, Object.keys(t4));
    }) : r3.every(function(r4) {
      return me(t4, e4, n4, r4);
    }));
  }, $eq: function(e4, t4, n4, r3) {
    return ke(r3) && g(r3, t4) === 0;
  }, $gte: function(e4, t4, n4, r3) {
    return ke(r3) && g(r3, t4) >= 0;
  }, $gt: function(e4, t4, n4, r3) {
    return ke(r3) && g(r3, t4) > 0;
  }, $lte: function(e4, t4, n4, r3) {
    return ke(r3) && g(r3, t4) <= 0;
  }, $lt: function(e4, t4, n4, r3) {
    return ke(r3) && g(r3, t4) < 0;
  }, $exists: function(e4, t4, n4, r3) {
    return t4 ? ke(r3) : !ke(r3);
  }, $mod: function(e4, t4, n4, r3) {
    return we(r3) && function(e5, t5) {
      return typeof e5 == "number" && parseInt(e5, 10) === e5 && e5 % t5[0] === t5[1];
    }(r3, t4);
  }, $ne: function(e4, t4, n4, r3) {
    return t4.every(function(e5) {
      return g(r3, e5) !== 0;
    });
  }, $in: function(e4, t4, n4, r3) {
    return we(r3) && je(r3, t4);
  }, $nin: function(e4, t4, n4, r3) {
    return we(r3) && !je(r3, t4);
  }, $size: function(e4, t4, n4, r3) {
    return we(r3) && Array.isArray(r3) && function(e5, t5) {
      return e5.length === t5;
    }(r3, t4);
  }, $all: function(e4, t4, n4, r3) {
    return Array.isArray(r3) && function(e5, t5) {
      return t5.every(function(t6) {
        return e5.some(function(e6) {
          return g(t6, e6) === 0;
        });
      });
    }(r3, t4);
  }, $regex: function(e4, t4, n4, r3) {
    return we(r3) && typeof r3 == "string" && t4.every(function(e5) {
      return function(e6, t5) {
        return new RegExp(t5).test(e6);
      }(r3, e5);
    });
  }, $type: function(e4, t4, n4, r3) {
    return function(e5, t5) {
      switch (t5) {
        case "null":
          return e5 === null;
        case "boolean":
          return typeof e5 == "boolean";
        case "number":
          return typeof e5 == "number";
        case "string":
          return typeof e5 == "string";
        case "array":
          return e5 instanceof Array;
        case "object":
          return {}.toString.call(e5) === "[object Object]";
      }
    }(r3, t4);
  } };
  function $e(e4, t4) {
    if (typeof t4 != "object")
      throw new Error("Selector error: expected a JSON object");
    var n4 = ge([{ doc: e4 }], { selector: t4 = ye(t4) }, Object.keys(t4));
    return n4 && n4.length === 1;
  }
  function xe(e4) {
    return (e4 = I(e4)).index || (e4.index = {}), ["type", "name", "ddoc"].forEach(function(t4) {
      e4.index[t4] && (e4[t4] = e4.index[t4], delete e4.index[t4]);
    }), e4.fields && (e4.index.fields = e4.fields, delete e4.fields), e4.type || (e4.type = "json"), e4;
  }
  function qe(e4, t4, n4) {
    var r3 = "", i3 = t4, o2 = true;
    if (["$in", "$nin", "$or", "$and", "$mod", "$nor", "$all"].indexOf(e4) !== -1 && (Array.isArray(t4) || (r3 = "Query operator " + e4 + " must be an array.")), ["$not", "$elemMatch", "$allMatch"].indexOf(e4) !== -1 && (Array.isArray(t4) || typeof t4 != "object" || t4 === null) && (r3 = "Query operator " + e4 + " must be an object."), e4 === "$mod" && Array.isArray(t4))
      if (t4.length !== 2)
        r3 = "Query operator $mod must be in the format [divisor, remainder], where divisor and remainder are both integers.";
      else {
        var s2 = t4[0], a2 = t4[1];
        s2 === 0 && (r3 = "Query operator $mod's divisor cannot be 0, cannot divide by zero.", o2 = false), typeof s2 == "number" && parseInt(s2, 10) === s2 || (r3 = "Query operator $mod's divisor is not an integer.", i3 = s2), parseInt(a2, 10) !== a2 && (r3 = "Query operator $mod's remainder is not an integer.", i3 = a2);
      }
    if (e4 === "$exists" && typeof t4 != "boolean" && (r3 = "Query operator $exists must be a boolean."), e4 === "$type") {
      var u2 = ["null", "boolean", "number", "string", "array", "object"], c2 = '"' + u2.slice(0, u2.length - 1).join('", "') + '", or "' + u2[u2.length - 1] + '"';
      (typeof t4 != "string" || u2.indexOf(t4) == -1) && (r3 = "Query operator $type must be a string. Supported values: " + c2 + ".");
    }
    if (e4 === "$size" && parseInt(t4, 10) !== t4 && (r3 = "Query operator $size must be a integer."), e4 === "$regex" && typeof t4 != "string" && (console.log("here", n4), n4 ? r3 = "Query operator $regex must be a string." : t4 instanceof RegExp || (r3 = "Query operator $regex must be a string or an instance of a javascript regular expression.")), r3)
      throw o2 && (r3 += " Received" + (i3 === null ? " " : Array.isArray(i3) ? " array" : " " + typeof i3) + ": " + (typeof i3 == "object" && i3 !== null ? JSON.stringify(i3, null, "	") : i3)), new Error(r3);
  }
  var Ae = ["$all", "$allMatch", "$and", "$elemMatch", "$exists", "$in", "$mod", "$nin", "$nor", "$not", "$or", "$regex", "$size", "$type"], Se = ["$in", "$nin", "$mod", "$all"], Ee = ["$eq", "$gt", "$gte", "$lt", "$lte"];
  function Pe(e4, t4) {
    if (Array.isArray(e4))
      for (var n4 of e4)
        typeof n4 == "object" && s2 !== null && Pe(n4, t4);
    else
      for (var r3 = Object.keys(e4), i3 = 0; i3 < r3.length; i3++) {
        var o2 = r3[i3], s2 = e4[o2];
        Ae.indexOf(o2) !== -1 && qe(o2, s2, t4), Ee.indexOf(o2) === -1 && Se.indexOf(o2) === -1 && typeof s2 == "object" && s2 !== null && Pe(s2, t4);
      }
  }
  function Ce(e4, t4, n4, r3) {
    var i3, o2;
    n4.headers = new f({ "Content-type": "application/json" }), e4.fetch(t4, n4).then(function(e5) {
      return i3 = e5.status, o2 = e5.ok, e5.json();
    }).then(function(e5) {
      if (o2)
        r3(null, e5);
      else {
        e5.status = i3;
        var t5 = a(e5);
        r3(t5);
      }
    }).catch(r3);
  }
  function De(e4, t4, n4) {
    t4 = xe(t4), Ce(e4, "_index", { method: "POST", body: JSON.stringify(t4) }, n4);
  }
  function Le(e4, t4, n4) {
    Pe(t4.selector, true), Ce(e4, "_find", { method: "POST", body: JSON.stringify(t4) }, n4);
  }
  function Be(e4, t4, n4) {
    Ce(e4, "_explain", { method: "POST", body: JSON.stringify(t4) }, n4);
  }
  function Ie(e4, t4) {
    Ce(e4, "_index", { method: "GET" }, t4);
  }
  function Te(e4, t4, n4) {
    var r3 = t4.ddoc, i3 = t4.type || "json", o2 = t4.name;
    return r3 ? o2 ? void Ce(e4, "_index/" + [r3, i3, o2].map(encodeURIComponent).join("/"), { method: "DELETE" }, n4) : n4(new Error("you must provide an index's name")) : n4(new Error("you must provide an index's ddoc"));
  }
  function Me(e4) {
    return function() {
      for (var t4 = arguments.length, n4 = new Array(t4), r3 = -1; ++r3 < t4; )
        n4[r3] = arguments[r3];
      return e4.call(this, n4);
    };
  }
  function Ne(e4) {
    return Me(function(t4) {
      var n4 = t4.pop(), r3 = e4.apply(this, t4);
      return function(e5, t5) {
        e5.then(function(e6) {
          x()(function() {
            t5(null, e6);
          });
        }, function(e6) {
          x()(function() {
            t5(e6);
          });
        });
      }(r3, n4), r3;
    });
  }
  var Re = Me(function(e4) {
    for (var t4 = [], n4 = 0, r3 = e4.length; n4 < r3; n4++) {
      var i3 = e4[n4];
      Array.isArray(i3) ? t4 = t4.concat(Re.apply(null, i3)) : t4.push(i3);
    }
    return t4;
  });
  function Fe(e4) {
    for (var t4 = {}, n4 = 0, r3 = e4.length; n4 < r3; n4++)
      t4 = F(t4, e4[n4]);
    return t4;
  }
  function Ue(e4, t4) {
    for (var n4 = 0, r3 = Math.min(e4.length, t4.length); n4 < r3; n4++)
      if (e4[n4] !== t4[n4])
        return false;
    return true;
  }
  function ze(e4, t4) {
    if (e4.length !== t4.length)
      return false;
    for (var n4 = 0, r3 = e4.length; n4 < r3; n4++)
      if (e4[n4] !== t4[n4])
        return false;
    return true;
  }
  var Je = function(e4, t4, n4, r3) {
    function i3(e5, t5, n5) {
      try {
        t5(n5);
      } catch (t6) {
        ie(e5, t6);
      }
    }
    function o2(e5, t5, n5, r4, i4) {
      try {
        return { output: t5(n5, r4, i4) };
      } catch (t6) {
        return ie(e5, t6), { error: t6 };
      }
    }
    function s2(e5, t5) {
      var n5 = g(e5.key, t5.key);
      return n5 !== 0 ? n5 : g(e5.value, t5.value);
    }
    function l2(e5, t5, n5) {
      return n5 = n5 || 0, typeof t5 == "number" ? e5.slice(n5, t5 + n5) : n5 > 0 ? e5.slice(n5) : e5;
    }
    function d2(e5) {
      var t5 = e5.value;
      return t5 && typeof t5 == "object" && t5._id || e5.id;
    }
    function h2(e5) {
      return function(t5) {
        return e5.include_docs && e5.attachments && e5.binary && function(e6) {
          e6.rows.forEach(function(e7) {
            var t6 = e7.doc && e7.doc._attachments;
            t6 && Object.keys(t6).forEach(function(e8) {
              var n5 = t6[e8];
              t6[e8].data = y(n5.data, n5.content_type);
            });
          });
        }(t5), t5;
      };
    }
    function p2(e5, t5, n5, r4) {
      var i4 = t5[e5];
      i4 !== void 0 && (r4 && (i4 = encodeURIComponent(JSON.stringify(i4))), n5.push(e5 + "=" + i4));
    }
    function v2(e5) {
      if (e5 !== void 0) {
        var t5 = Number(e5);
        return isNaN(t5) || t5 !== parseInt(e5, 10) ? e5 : t5;
      }
    }
    function k2(e5, t5) {
      var n5 = e5.descending ? "endkey" : "startkey", r4 = e5.descending ? "startkey" : "endkey";
      if (e5[n5] !== void 0 && e5[r4] !== void 0 && g(e5[n5], e5[r4]) > 0)
        throw new K("No rows can match your key range, reverse your start_key and end_key or set {descending : true}");
      if (t5.reduce && e5.reduce !== false) {
        if (e5.include_docs)
          throw new K("{include_docs:true} is invalid for reduce");
        if (e5.keys && e5.keys.length > 1 && !e5.group && !e5.group_level)
          throw new K("Multi-key fetches for reduce views must use {group: true}");
      }
      ["group_level", "limit", "skip"].forEach(function(t6) {
        var n6 = function(e6) {
          if (e6) {
            if (typeof e6 != "number")
              return new K('Invalid value for integer: "' + e6 + '"');
            if (e6 < 0)
              return new K('Invalid value for positive integer: "' + e6 + '"');
          }
        }(e5[t6]);
        if (n6)
          throw n6;
      });
    }
    function j2(e5) {
      return function(t5) {
        if (t5.status === 404)
          return e5;
        throw t5;
      };
    }
    function $2(e5) {
      var t5 = typeof e5 == "string" ? e5 : e5.name, n5 = te[t5];
      return n5 || (n5 = te[t5] = new Y()), n5;
    }
    function q2(e5, n5) {
      return W($2(e5), function() {
        return function(e6, n6) {
          var r4, o3;
          var a2 = t4(e6.mapFun, function(e7, t5) {
            var n7 = { id: o3._id, key: _(e7) };
            t5 != null && (n7.value = _(t5)), r4.push(n7);
          }), f2 = e6.seq || 0;
          function l3(t5, n7) {
            return function() {
              return function(e7, t6, n8) {
                var r5 = "_local/lastSeq";
                return e7.db.get(r5).catch(j2({ _id: r5, seq: 0 })).then(function(r6) {
                  var i4 = X(t6);
                  return Promise.all(i4.map(function(n9) {
                    return function(e8, t7, n10) {
                      var r7, i5 = "_local/doc_" + e8, o4 = { _id: i5, keys: [] }, s3 = n10.get(e8), a3 = s3[0];
                      return (r7 = s3[1], r7.length === 1 && /^1-/.test(r7[0].rev) ? Promise.resolve(o4) : t7.db.get(i5).catch(j2(o4))).then(function(e9) {
                        return function(e10) {
                          return e10.keys.length ? t7.db.allDocs({ keys: e10.keys, include_docs: true }) : Promise.resolve({ rows: [] });
                        }(e9).then(function(t8) {
                          return function(e10, t9) {
                            for (var n11 = [], r8 = new u(), i6 = 0, o5 = t9.rows.length; i6 < o5; i6++) {
                              var s4 = t9.rows[i6].doc;
                              if (s4 && (n11.push(s4), r8.add(s4._id), s4._deleted = !a3.has(s4._id), !s4._deleted)) {
                                var c2 = a3.get(s4._id);
                                "value" in c2 && (s4.value = c2.value);
                              }
                            }
                            var f3 = X(a3);
                            return f3.forEach(function(e11) {
                              if (!r8.has(e11)) {
                                var t10 = { _id: e11 }, i7 = a3.get(e11);
                                "value" in i7 && (t10.value = i7.value), n11.push(t10);
                              }
                            }), e10.keys = Z(f3.concat(e10.keys)), n11.push(e10), n11;
                          }(e9, t8);
                        });
                      });
                    }(n9, e7, t6);
                  })).then(function(t7) {
                    var i5 = U(t7);
                    return r6.seq = n8, i5.push(r6), e7.db.bulkDocs({ docs: i5 });
                  });
                });
              }(e6, t5, n7);
            };
          }
          let d3 = 0, h3 = { view: e6.name, indexed_docs: d3 };
          e6.sourceDB.emit("indexing", h3);
          var p3 = new Y();
          function v3() {
            return e6.sourceDB.changes({ return_docs: true, conflicts: true, include_docs: true, style: "all_docs", since: f2, limit: n6.changes_batch_size }).then(y2);
          }
          function y2(t5) {
            var u2 = t5.results;
            if (!u2.length)
              return;
            var h4 = function(t6) {
              for (var n7 = new c(), u3 = 0, l4 = t6.length; u3 < l4; u3++) {
                var d4 = t6[u3];
                if (d4.doc._id[0] !== "_") {
                  r4 = [], (o3 = d4.doc)._deleted || i3(e6.sourceDB, a2, o3), r4.sort(s2);
                  var h5 = b2(r4);
                  n7.set(d4.doc._id, [h5, d4.changes]);
                }
                f2 = d4.seq;
              }
              return n7;
            }(u2);
            p3.add(l3(h4, f2)), d3 += u2.length;
            let y3 = { view: e6.name, last_seq: t5.last_seq, results_count: u2.length, indexed_docs: d3 };
            return e6.sourceDB.emit("indexing", y3), u2.length < n6.changes_batch_size ? void 0 : v3();
          }
          function b2(e7) {
            for (var t5, n7 = new c(), r5 = 0, i4 = e7.length; r5 < i4; r5++) {
              var o4 = e7[r5], s3 = [o4.key, o4.id];
              r5 > 0 && g(o4.key, t5) === 0 && s3.push(r5), n7.set(m(s3), o4), t5 = o4.key;
            }
            return n7;
          }
          return v3().then(function() {
            return p3.finish();
          }).then(function() {
            e6.seq = f2;
          });
        }(e5, n5);
      })();
    }
    function A2(e5, t5) {
      return W($2(e5), function() {
        return function(e6, t6) {
          var r4, i4 = e6.reduceFun && t6.reduce !== false, s3 = t6.skip || 0;
          function a2(t7) {
            return t7.include_docs = true, e6.db.allDocs(t7).then(function(e7) {
              return r4 = e7.total_rows, e7.rows.map(function(e8) {
                if ("value" in e8.doc && typeof e8.doc.value == "object" && e8.doc.value !== null) {
                  var t8 = Object.keys(e8.doc.value).sort(), n5 = ["id", "key", "value"];
                  if (!(t8 < n5 || t8 > n5))
                    return e8.doc.value;
                }
                var r5 = function(e9) {
                  for (var t9 = [], n6 = [], r6 = 0; ; ) {
                    var i5 = e9[r6++];
                    if (i5 !== "\0")
                      switch (i5) {
                        case "1":
                          t9.push(null);
                          break;
                        case "2":
                          t9.push(e9[r6] === "1"), r6++;
                          break;
                        case "3":
                          var o3 = b(e9, r6);
                          t9.push(o3.num), r6 += o3.length;
                          break;
                        case "4":
                          for (var s4 = ""; ; ) {
                            var a3 = e9[r6];
                            if (a3 === "\0")
                              break;
                            s4 += a3, r6++;
                          }
                          s4 = s4.replace(/\u0001\u0001/g, "\0").replace(/\u0001\u0002/g, "").replace(/\u0002\u0002/g, ""), t9.push(s4);
                          break;
                        case "5":
                          var u3 = { element: [], index: t9.length };
                          t9.push(u3.element), n6.push(u3);
                          break;
                        case "6":
                          var c2 = { element: {}, index: t9.length };
                          t9.push(c2.element), n6.push(c2);
                          break;
                        default:
                          throw new Error("bad collationIndex or unexpectedly reached end of input: " + i5);
                      }
                    else {
                      if (t9.length === 1)
                        return t9.pop();
                      w(t9, n6);
                    }
                  }
                }(e8.doc._id);
                return { key: r5[0], id: r5[1], value: "value" in e8.doc ? e8.doc.value : null };
              });
            });
          }
          function u2(a3) {
            var u3;
            if (u3 = i4 ? function(e7, t7, r5) {
              r5.group_level === 0 && delete r5.group_level;
              var i5 = r5.group || r5.group_level, s4 = n4(e7.reduceFun), a4 = [], u4 = isNaN(r5.group_level) ? Number.POSITIVE_INFINITY : r5.group_level;
              t7.forEach(function(e8) {
                var t8 = a4[a4.length - 1], n5 = i5 ? e8.key : null;
                if (i5 && Array.isArray(n5) && (n5 = n5.slice(0, u4)), t8 && g(t8.groupKey, n5) === 0)
                  return t8.keys.push([e8.key, e8.id]), void t8.values.push(e8.value);
                a4.push({ keys: [[e8.key, e8.id]], values: [e8.value], groupKey: n5 });
              }), t7 = [];
              for (var c2 = 0, f4 = a4.length; c2 < f4; c2++) {
                var d3 = a4[c2], h4 = o2(e7.sourceDB, s4, d3.keys, d3.values, false);
                if (h4.error && h4.error instanceof Q)
                  throw h4.error;
                t7.push({ value: h4.error ? null : h4.output, key: d3.groupKey });
              }
              return { rows: l2(t7, r5.limit, r5.skip) };
            }(e6, a3, t6) : t6.keys === void 0 ? { total_rows: r4, offset: s3, rows: a3 } : { total_rows: r4, offset: s3, rows: l2(a3, t6.limit, t6.skip) }, t6.update_seq && (u3.update_seq = e6.seq), t6.include_docs) {
              var f3 = Z(a3.map(d2));
              return e6.sourceDB.allDocs({ keys: f3, include_docs: true, conflicts: t6.conflicts, attachments: t6.attachments, binary: t6.binary }).then(function(e7) {
                var t7 = new c();
                return e7.rows.forEach(function(e8) {
                  t7.set(e8.id, e8.doc);
                }), a3.forEach(function(e8) {
                  var n5 = d2(e8), r5 = t7.get(n5);
                  r5 && (e8.doc = r5);
                }), u3;
              });
            }
            return u3;
          }
          if (t6.keys === void 0 || t6.keys.length || (t6.limit = 0, delete t6.keys), t6.keys !== void 0) {
            var f2 = t6.keys.map(function(e7) {
              var n5 = { startkey: m([e7]), endkey: m([e7, {}]) };
              return t6.update_seq && (n5.update_seq = true), a2(n5);
            });
            return Promise.all(f2).then(U).then(u2);
          }
          var h3, p3, v3 = { descending: t6.descending };
          if (t6.update_seq && (v3.update_seq = true), "start_key" in t6 && (h3 = t6.start_key), "startkey" in t6 && (h3 = t6.startkey), "end_key" in t6 && (p3 = t6.end_key), "endkey" in t6 && (p3 = t6.endkey), h3 !== void 0 && (v3.startkey = t6.descending ? m([h3, {}]) : m([h3])), p3 !== void 0) {
            var y2 = t6.inclusive_end !== false;
            t6.descending && (y2 = !y2), v3.endkey = m(y2 ? [p3, {}] : [p3]);
          }
          if (t6.key !== void 0) {
            var _2 = m([t6.key]), k3 = m([t6.key, {}]);
            v3.descending ? (v3.endkey = _2, v3.startkey = k3) : (v3.startkey = _2, v3.endkey = k3);
          }
          return i4 || (typeof t6.limit == "number" && (v3.limit = t6.limit), v3.skip = s3), a2(v3).then(u2);
        }(e5, t5);
      })();
    }
    var S2;
    return { query: function(t5, n5, i4) {
      var o3 = this;
      typeof n5 == "function" && (i4 = n5, n5 = {}), n5 = n5 ? function(e5) {
        return e5.group_level = v2(e5.group_level), e5.limit = v2(e5.limit), e5.skip = v2(e5.skip), e5;
      }(n5) : {}, typeof t5 == "function" && (t5 = { map: t5 });
      var s3 = Promise.resolve().then(function() {
        return function(t6, n6, i5) {
          if (typeof t6._query == "function")
            return function(e5, t7, n7) {
              return new Promise(function(r4, i6) {
                e5._query(t7, n7, function(e6, t8) {
                  if (e6)
                    return i6(e6);
                  r4(t8);
                });
              });
            }(t6, n6, i5);
          if (z(t6))
            return function(e5, t7, n7) {
              var r4, i6, o5, s5 = [], u3 = "GET";
              if (p2("reduce", n7, s5), p2("include_docs", n7, s5), p2("attachments", n7, s5), p2("limit", n7, s5), p2("descending", n7, s5), p2("group", n7, s5), p2("group_level", n7, s5), p2("skip", n7, s5), p2("stale", n7, s5), p2("conflicts", n7, s5), p2("startkey", n7, s5, true), p2("start_key", n7, s5, true), p2("endkey", n7, s5, true), p2("end_key", n7, s5, true), p2("inclusive_end", n7, s5), p2("key", n7, s5, true), p2("update_seq", n7, s5), s5 = (s5 = s5.join("&")) === "" ? "" : "?" + s5, n7.keys !== void 0) {
                var c3 = "keys=" + encodeURIComponent(JSON.stringify(n7.keys));
                c3.length + s5.length + 1 <= 2e3 ? s5 += (s5[0] === "?" ? "&" : "?") + c3 : (u3 = "POST", typeof t7 == "string" ? r4 = { keys: n7.keys } : t7.keys = n7.keys);
              }
              if (typeof t7 == "string") {
                var l4 = re(t7);
                return e5.fetch("_design/" + l4[0] + "/_view/" + l4[1] + s5, { headers: new f({ "Content-Type": "application/json" }), method: u3, body: JSON.stringify(r4) }).then(function(e6) {
                  return i6 = e6.ok, o5 = e6.status, e6.json();
                }).then(function(e6) {
                  if (!i6)
                    throw e6.status = o5, a(e6);
                  return e6.rows.forEach(function(e7) {
                    if (e7.value && e7.value.error && e7.value.error === "builtin_reduce_error")
                      throw new Error(e7.reason);
                  }), e6;
                }).then(h2(n7));
              }
              return r4 = r4 || {}, Object.keys(t7).forEach(function(e6) {
                Array.isArray(t7[e6]) ? r4[e6] = t7[e6] : r4[e6] = t7[e6].toString();
              }), e5.fetch("_temp_view" + s5, { headers: new f({ "Content-Type": "application/json" }), method: "POST", body: JSON.stringify(r4) }).then(function(e6) {
                return i6 = e6.ok, o5 = e6.status, e6.json();
              }).then(function(e6) {
                if (!i6)
                  throw e6.status = o5, a(e6);
                return e6;
              }).then(h2(n7));
            }(t6, n6, i5);
          var o4 = { changes_batch_size: t6.__opts.view_update_changes_batch_size || 50 };
          if (typeof n6 != "string")
            return k2(i5, n6), ne.add(function() {
              return ee(t6, "temp_view/temp_view", n6.map, n6.reduce, true, e4).then(function(e5) {
                return t7 = q2(e5, o4).then(function() {
                  return A2(e5, i5);
                }), n7 = function() {
                  return e5.db.destroy();
                }, t7.then(function(e6) {
                  return n7().then(function() {
                    return e6;
                  });
                }, function(e6) {
                  return n7().then(function() {
                    throw e6;
                  });
                });
                var t7, n7;
              });
            }), ne.finish();
          var s4 = n6, u2 = re(s4), c2 = u2[0], l3 = u2[1];
          return t6.get("_design/" + c2).then(function(n7) {
            var a2 = n7.views && n7.views[l3];
            if (!a2)
              throw new V("ddoc " + n7._id + " has no view named " + l3);
            return r3(n7, l3), k2(i5, a2), ee(t6, s4, a2.map, a2.reduce, false, e4).then(function(e5) {
              return i5.stale === "ok" || i5.stale === "update_after" ? (i5.stale === "update_after" && x()(function() {
                q2(e5, o4);
              }), A2(e5, i5)) : q2(e5, o4).then(function() {
                return A2(e5, i5);
              });
            });
          });
        }(o3, t5, n5);
      });
      return G(s3, i4), s3;
    }, viewCleanup: (S2 = function() {
      var t5 = this;
      return typeof t5._viewCleanup == "function" ? function(e5) {
        return new Promise(function(t6, n5) {
          e5._viewCleanup(function(e6, r4) {
            if (e6)
              return n5(e6);
            t6(r4);
          });
        });
      }(t5) : z(t5) ? function(e5) {
        return e5.fetch("_view_cleanup", { headers: new f({ "Content-Type": "application/json" }), method: "POST" }).then(function(e6) {
          return e6.json();
        });
      }(t5) : function(t6) {
        return t6.get("_local/" + e4).then(function(e5) {
          var n5 = new c();
          Object.keys(e5.views).forEach(function(e6) {
            var t7 = re(e6), r5 = "_design/" + t7[0], i4 = t7[1], o3 = n5.get(r5);
            o3 || (o3 = new u(), n5.set(r5, o3)), o3.add(i4);
          });
          var r4 = { keys: X(n5), include_docs: true };
          return t6.allDocs(r4).then(function(r5) {
            var i4 = {};
            r5.rows.forEach(function(t7) {
              var r6 = t7.key.substring(8);
              n5.get(t7.key).forEach(function(n6) {
                var o4 = r6 + "/" + n6;
                e5.views[o4] || (o4 = n6);
                var s3 = Object.keys(e5.views[o4]), a2 = t7.doc && t7.doc.views && t7.doc.views[n6];
                s3.forEach(function(e6) {
                  i4[e6] = i4[e6] || a2;
                });
              });
            });
            var o3 = Object.keys(i4).filter(function(e6) {
              return !i4[e6];
            }).map(function(e6) {
              return W($2(e6), function() {
                return new t6.constructor(e6, t6.__opts).destroy();
              })();
            });
            return Promise.all(o3).then(function() {
              return { ok: true };
            });
          });
        }, j2({ ok: true }));
      }(t5);
    }, O()(function(e5) {
      var t5 = e5.pop(), n5 = S2.apply(this, e5);
      return typeof t5 == "function" && G(n5, t5), n5;
    })) };
  }("indexes", function(e4, t4) {
    return function(e5, t5, n4) {
      var r3 = function(e6) {
        for (var t6 = 0, n5 = e6.length; t6 < n5; t6++)
          if (e6[t6].indexOf(".") !== -1)
            return false;
        return true;
      }(e5), i3 = e5.length === 1;
      return r3 ? i3 ? function(e6, t6, n5) {
        return function(r4) {
          n5 && !$e(r4, n5) || t6(r4[e6]);
        };
      }(e5[0], t5, n4) : function(e6, t6, n5) {
        return function(r4) {
          if (!n5 || $e(r4, n5)) {
            for (var i4 = [], o2 = 0, s2 = e6.length; o2 < s2; o2++)
              i4.push(r4[e6[o2]]);
            t6(i4);
          }
        };
      }(e5, t5, n4) : i3 ? function(e6, t6, n5) {
        var r4 = ue(e6);
        return function(e7) {
          if (!n5 || $e(e7, n5)) {
            for (var i4 = e7, o2 = 0, s2 = r4.length; o2 < s2; o2++)
              if ((i4 = i4[r4[o2]]) === void 0)
                return;
            t6(i4);
          }
        };
      }(e5[0], t5, n4) : function(e6, t6, n5) {
        return function(r4) {
          if (!n5 || $e(r4, n5)) {
            for (var i4 = [], o2 = 0, s2 = e6.length; o2 < s2; o2++) {
              for (var a2 = ue(e6[o2]), u2 = r4, c2 = 0, f2 = a2.length; c2 < f2; c2++)
                if ((u2 = u2[a2[c2]]) === void 0)
                  return;
              i4.push(u2);
            }
            t6(i4);
          }
        };
      }(e5, t5, n4);
    }(Object.keys(e4.fields), t4, e4.partial_filter_selector);
  }, function() {
    throw new Error("reduce not supported");
  }, function(e4, t4) {
    var n4 = e4.views[t4];
    if (!n4.map || !n4.map.fields)
      throw new Error("ddoc " + e4._id + " with view " + t4 + " doesn't have map.fields defined. maybe it wasn't created by this plugin?");
  });
  function Ke(e4) {
    return e4._customFindAbstractMapper || Je;
  }
  function Ve(e4) {
    return e4.fields = e4.fields.map(function(e5) {
      if (typeof e5 == "string") {
        var t4 = {};
        return t4[e5] = "asc", t4;
      }
      return e5;
    }), e4;
  }
  function Qe(e4, t4) {
    for (var n4 = [], r3 = 0; r3 < t4.def.fields.length; r3++) {
      var i3 = le(t4.def.fields[r3]);
      n4.push(e4[i3]);
    }
    return n4;
  }
  function Ge(e4) {
    return e4.allDocs({ startkey: "_design/", endkey: "_design/\uFFFF", include_docs: true }).then(function(e5) {
      var t4 = { indexes: [{ ddoc: null, name: "_all_docs", type: "special", def: { fields: [{ _id: "asc" }] } }] };
      return t4.indexes = Re(t4.indexes, e5.rows.filter(function(e6) {
        return e6.doc.language === "query";
      }).map(function(e6) {
        return (e6.doc.views !== void 0 ? Object.keys(e6.doc.views) : []).map(function(t5) {
          var n4 = e6.doc.views[t5];
          return { ddoc: e6.id, name: t5, type: "json", def: Ve(n4.options.def) };
        });
      })), t4.indexes.sort(function(e6, t5) {
        return ae(e6.name, t5.name);
      }), t4.total_rows = t4.indexes.length, t4;
    });
  }
  var We = null, Ze = { "\uFFFF": {} };
  const Xe = { queryOpts: { limit: 0, startkey: Ze, endkey: We }, inMemoryFields: [] };
  function Ye(e4, t4) {
    for (var n4 = e4.def.fields.map(le), r3 = 0, i3 = n4.length; r3 < i3; r3++)
      if (t4 === n4[r3])
        return true;
    return false;
  }
  function He(e4, t4) {
    return le(e4[t4]) !== "$eq";
  }
  function et(e4, t4) {
    var n4 = t4.def.fields.map(le);
    return e4.slice().sort(function(e5, t5) {
      var r3 = n4.indexOf(e5), i3 = n4.indexOf(t5);
      return r3 === -1 && (r3 = Number.MAX_VALUE), i3 === -1 && (i3 = Number.MAX_VALUE), ae(r3, i3);
    });
  }
  function tt(e4, t4, n4, r3) {
    var i3 = Re(e4, function(e5, t5, n5) {
      for (var r4 = false, i4 = 0, o2 = (n5 = et(n5, e5)).length; i4 < o2; i4++) {
        var s2 = n5[i4];
        if (r4 || !Ye(e5, s2))
          return n5.slice(i4);
        i4 < o2 - 1 && He(t5, s2) && (r4 = true);
      }
      return [];
    }(t4, n4, r3), function(e5) {
      var t5 = [];
      return Object.keys(e5).forEach(function(n5) {
        var r4 = e5[n5];
        Object.keys(r4).forEach(function(e6) {
          e6 === "$ne" && t5.push(n5);
        });
      }), t5;
    }(n4));
    return et(function(e5) {
      for (var t5 = {}, n5 = 0; n5 < e5.length; n5++)
        t5["$" + e5[n5]] = true;
      return Object.keys(t5).map(function(e6) {
        return e6.substring(1);
      });
    }(i3), t4);
  }
  var nt = ["$eq", "$gt", "$gte", "$lt", "$lte"];
  function rt(e4) {
    return nt.indexOf(e4) === -1;
  }
  function it(e4, t4, n4, r3) {
    var i3 = e4.def.fields.map(le);
    return !!function(e5, t5, n5) {
      if (t5) {
        var r4 = (s2 = e5, !((o2 = t5).length > s2.length) && Ue(o2, s2)), i4 = Ue(n5, e5);
        return r4 && i4;
      }
      var o2, s2;
      return function(e6, t6) {
        e6 = e6.slice();
        for (var n6 = 0, r5 = t6.length; n6 < r5; n6++) {
          var i5 = t6[n6];
          if (!e6.length)
            break;
          var o3 = e6.indexOf(i5);
          if (o3 === -1)
            return false;
          e6.splice(o3, 1);
        }
        return true;
      }(n5, e5);
    }(i3, t4, n4) && function(e5, t5) {
      var n5 = t5[e5[0]];
      return n5 === void 0 || !(Object.keys(n5).length === 1 && le(n5) === "$ne");
    }(i3, r3);
  }
  function ot(e4, t4) {
    switch (e4) {
      case "$eq":
        return { startkey: t4, endkey: t4 };
      case "$lte":
        return { endkey: t4 };
      case "$gte":
        return { startkey: t4 };
      case "$lt":
        return { endkey: t4, inclusive_end: false };
      case "$gt":
        return { startkey: t4, inclusive_start: false };
    }
  }
  function st(e4, t4) {
    return t4.defaultUsed ? function(e5) {
      return { queryOpts: { startkey: null }, inMemoryFields: [Object.keys(e5)] };
    }(e4) : t4.def.fields.length === 1 ? function(e5, t5) {
      var n4, r3 = le(t5.def.fields[0]), i3 = e5[r3] || {}, o2 = [];
      return Object.keys(i3).forEach(function(e6) {
        rt(e6) && o2.push(r3);
        var t6 = function(e7, t7) {
          switch (e7) {
            case "$eq":
              return { key: t7 };
            case "$lte":
              return { endkey: t7 };
            case "$gte":
              return { startkey: t7 };
            case "$lt":
              return { endkey: t7, inclusive_end: false };
            case "$gt":
              return { startkey: t7, inclusive_start: false };
          }
          return { startkey: We };
        }(e6, i3[e6]);
        n4 = n4 ? Fe([n4, t6]) : t6;
      }), { queryOpts: n4, inMemoryFields: o2 };
    }(e4, t4) : function(e5, t5) {
      var n4, r3, i3 = t5.def.fields.map(le), o2 = [], s2 = [], a2 = [];
      function u2(e6) {
        n4 !== false && s2.push(We), r3 !== false && a2.push(Ze), o2 = i3.slice(e6);
      }
      for (var c2 = 0, f2 = i3.length; c2 < f2; c2++) {
        var l2 = e5[i3[c2]];
        if (!l2 || !Object.keys(l2).length) {
          u2(c2);
          break;
        }
        if (Object.keys(l2).some(rt)) {
          u2(c2);
          break;
        }
        if (c2 > 0) {
          var d2 = "$gt" in l2 || "$gte" in l2 || "$lt" in l2 || "$lte" in l2, h2 = Object.keys(e5[i3[c2 - 1]]), p2 = ze(h2, ["$eq"]), v2 = ze(h2, Object.keys(l2));
          if (d2 && !p2 && !v2) {
            u2(c2);
            break;
          }
        }
        for (var y2 = Object.keys(l2), g2 = null, _2 = 0; _2 < y2.length; _2++) {
          var m2 = y2[_2], b2 = ot(m2, l2[m2]);
          g2 = g2 ? Fe([g2, b2]) : b2;
        }
        s2.push("startkey" in g2 ? g2.startkey : We), a2.push("endkey" in g2 ? g2.endkey : Ze), "inclusive_start" in g2 && (n4 = g2.inclusive_start), "inclusive_end" in g2 && (r3 = g2.inclusive_end);
      }
      var w2 = { startkey: s2, endkey: a2 };
      return n4 !== void 0 && (w2.inclusive_start = n4), r3 !== void 0 && (w2.inclusive_end = r3), { queryOpts: w2, inMemoryFields: o2 };
    }(e4, t4);
  }
  function at(e4, t4) {
    var n4 = e4.selector, r3 = e4.sort;
    if (function(e5) {
      return Object.keys(e5).map(function(t5) {
        return e5[t5];
      }).some(function(e6) {
        return typeof e6 == "object" && Object.keys(e6).length === 0;
      });
    }(n4))
      return F({}, Xe, { index: t4[0] });
    var i3 = function(e5, t5) {
      var n5, r4 = Object.keys(e5), i4 = t5 ? t5.map(le) : [];
      return n5 = r4.length >= i4.length ? r4 : i4, i4.length === 0 ? { fields: n5 } : { fields: n5 = n5.sort(function(e6, t6) {
        var n6 = i4.indexOf(e6);
        n6 === -1 && (n6 = Number.MAX_VALUE);
        var r5 = i4.indexOf(t6);
        return r5 === -1 && (r5 = Number.MAX_VALUE), n6 < r5 ? -1 : n6 > r5 ? 1 : 0;
      }), sortOrder: t5.map(le) };
    }(n4, r3), o2 = i3.fields, s2 = function(e5, t5, n5, r4, i4) {
      var o3 = function(e6, t6, n6, r5) {
        return r5.filter(function(r6) {
          return it(r6, n6, t6, e6);
        });
      }(e5, t5, n5, r4);
      if (o3.length === 0) {
        if (i4)
          throw { error: "no_usable_index", message: "There is no index available for this selector." };
        var s3 = r4[0];
        return s3.defaultUsed = true, s3;
      }
      if (o3.length === 1 && !i4)
        return o3[0];
      var a3 = function(e6) {
        for (var t6 = {}, n6 = 0, r5 = e6.length; n6 < r5; n6++)
          t6[e6[n6]] = true;
        return t6;
      }(t5);
      if (i4) {
        var u2 = "_design/" + i4[0], c2 = i4.length === 2 && i4[1], f2 = o3.find(function(e6) {
          return !(!c2 || e6.ddoc !== u2 || c2 !== e6.name) || e6.ddoc === u2;
        });
        if (!f2)
          throw { error: "unknown_error", message: "Could not find that index or could not use that index for the query" };
        return f2;
      }
      return function(e6, t6) {
        for (var n6 = null, r5 = -1, i5 = 0, o4 = e6.length; i5 < o4; i5++) {
          var s4 = e6[i5], a4 = t6(s4);
          a4 > r5 && (r5 = a4, n6 = s4);
        }
        return n6;
      }(o3, function(e6) {
        for (var t6 = e6.def.fields.map(le), n6 = 0, r5 = 0, i5 = t6.length; r5 < i5; r5++) {
          var o4 = t6[r5];
          a3[o4] && n6++;
        }
        return n6;
      });
    }(n4, o2, i3.sortOrder, t4, e4.use_index), a2 = st(n4, s2);
    return { queryOpts: a2.queryOpts, index: s2, inMemoryFields: tt(a2.inMemoryFields, s2, n4, o2) };
  }
  function ut(e4, t4, n4) {
    var r3, i3;
    return t4.selector && (Pe(t4.selector, false), t4.selector = ye(t4.selector)), t4.sort && (t4.sort = function(e5) {
      if (!Array.isArray(e5))
        throw new Error("invalid sort json - should be an array");
      return e5.map(function(e6) {
        if (typeof e6 == "string") {
          var t5 = {};
          return t5[e6] = "asc", t5;
        }
        return e6;
      });
    }(t4.sort)), t4.use_index && (t4.use_index = (i3 = [], typeof (r3 = t4.use_index) == "string" ? i3.push(r3) : i3 = r3, i3.map(function(e5) {
      return e5.replace("_design/", "");
    }))), function(e5) {
      if (typeof e5.selector != "object")
        throw new Error("you must provide a selector when you find()");
    }(t4), Ge(e4).then(function(r4) {
      e4.constructor.emit("debug", ["find", "planning query", t4]);
      var i4 = at(t4, r4.indexes);
      e4.constructor.emit("debug", ["find", "query plan", i4]);
      var o2 = i4.index;
      !function(e5, t5) {
        if (t5.defaultUsed && e5.sort) {
          var n5 = e5.sort.filter(function(e6) {
            return Object.keys(e6)[0] !== "_id";
          }).map(function(e6) {
            return Object.keys(e6)[0];
          });
          if (n5.length > 0)
            throw new Error('Cannot sort on field(s) "' + n5.join(",") + '" when using the default index');
        }
        t5.defaultUsed;
      }(t4, o2);
      var s2 = F({ include_docs: true, reduce: false, indexes_count: r4.total_rows }, i4.queryOpts);
      return "startkey" in s2 && "endkey" in s2 && g(s2.startkey, s2.endkey) > 0 ? { docs: [] } : (t4.sort && typeof t4.sort[0] != "string" && de(t4.sort[0]) === "desc" && (s2.descending = true, s2 = function(e5) {
        var t5 = I(e5);
        return delete t5.startkey, delete t5.endkey, delete t5.inclusive_start, delete t5.inclusive_end, "endkey" in e5 && (t5.startkey = e5.endkey), "startkey" in e5 && (t5.endkey = e5.startkey), "inclusive_start" in e5 && (t5.inclusive_end = e5.inclusive_start), "inclusive_end" in e5 && (t5.inclusive_start = e5.inclusive_end), t5;
      }(s2)), i4.inMemoryFields.length || ("limit" in t4 && (s2.limit = t4.limit), "skip" in t4 && (s2.skip = t4.skip)), n4 ? Promise.resolve(i4, s2) : Promise.resolve().then(function() {
        if (o2.name === "_all_docs")
          return function(e5, t6) {
            var n6 = I(t6);
            return n6.descending ? ("endkey" in n6 && typeof n6.endkey != "string" && (n6.endkey = ""), "startkey" in n6 && typeof n6.startkey != "string" && (n6.limit = 0)) : ("startkey" in n6 && typeof n6.startkey != "string" && (n6.startkey = ""), "endkey" in n6 && typeof n6.endkey != "string" && (n6.limit = 0)), "key" in n6 && typeof n6.key != "string" && (n6.limit = 0), n6.limit > 0 && n6.indexes_count && (n6.original_limit = n6.limit, n6.limit += n6.indexes_count), e5.allDocs(n6).then(function(e6) {
              return e6.rows = e6.rows.filter(function(e7) {
                return !/^_design\//.test(e7.id);
              }), n6.original_limit && (n6.limit = n6.original_limit), e6.rows = e6.rows.slice(0, n6.limit), e6;
            });
          }(e4, s2);
        var t5, n5 = (t5 = o2).ddoc.substring(8) + "/" + t5.name;
        return Ke(e4).query.call(e4, n5, s2);
      }).then(function(e5) {
        s2.inclusive_start === false && (e5.rows = function(e6, t5, n6) {
          for (var r5 = n6.def.fields, i5 = 0, o3 = e6.length; i5 < o3; i5++) {
            var s3 = Qe(e6[i5].doc, n6);
            if (r5.length === 1)
              s3 = s3[0];
            else
              for (; s3.length > t5.length; )
                s3.pop();
            if (Math.abs(g(s3, t5)) > 0)
              break;
          }
          return i5 > 0 ? e6.slice(i5) : e6;
        }(e5.rows, s2.startkey, o2)), i4.inMemoryFields.length && (e5.rows = ge(e5.rows, t4, i4.inMemoryFields));
        var n5 = { docs: e5.rows.map(function(e6) {
          var n6 = e6.doc;
          return t4.fields ? function(e7, t5) {
            for (var n7 = {}, r5 = 0, i5 = t5.length; r5 < i5; r5++) {
              var o3 = ue(t5[r5]), s3 = oe(e7, o3);
              s3 !== void 0 && se(n7, o3, s3);
            }
            return n7;
          }(n6, t4.fields) : n6;
        }) };
        return o2.defaultUsed && (n5.warning = "No matching index found, create an index to optimize query time."), n5;
      }));
    });
  }
  var ct = Ne(function(e4, t4) {
    var n4, r3 = I((t4 = xe(t4)).index);
    function i3() {
      return n4 || (n4 = C(JSON.stringify(t4)));
    }
    t4.index = Ve(t4.index), function(e5) {
      var t5 = e5.fields.filter(function(e6) {
        return de(e6) === "asc";
      });
      if (t5.length !== 0 && t5.length !== e5.fields.length)
        throw new Error("unsupported mixed sorting");
    }(t4.index);
    var o2 = t4.name || "idx-" + i3(), s2 = t4.ddoc || "idx-" + i3(), a2 = "_design/" + s2, u2 = false, c2 = false;
    return e4.constructor.emit("debug", ["find", "creating index", a2]), J(e4, a2, function(e5) {
      return e5._rev && e5.language !== "query" && (u2 = true), e5.language = "query", e5.views = e5.views || {}, !(c2 = !!e5.views[o2]) && (e5.views[o2] = { map: { fields: Fe(t4.index.fields) }, reduce: "_count", options: { def: r3 } }, e5);
    }).then(function() {
      if (u2)
        throw new Error('invalid language for ddoc with id "' + a2 + '" (should be "query")');
    }).then(function() {
      var t5 = s2 + "/" + o2;
      return Ke(e4).query.call(e4, t5, { limit: 0, reduce: false }).then(function() {
        return { id: a2, name: o2, result: c2 ? "exists" : "created" };
      });
    });
  }), ft = Ne(ut), lt = Ne(function(e4, t4) {
    return ut(e4, t4, true).then(function(n4) {
      return { dbname: e4.name, index: n4.index, selector: t4.selector, range: { start_key: n4.queryOpts.startkey, end_key: n4.queryOpts.endkey }, opts: { use_index: t4.use_index || [], bookmark: "nil", limit: t4.limit, skip: t4.skip, sort: t4.sort || {}, fields: t4.fields, conflicts: false, r: [49] }, limit: t4.limit, skip: t4.skip || 0, fields: t4.fields };
    });
  }), dt = Ne(Ge), ht = Ne(function(e4, t4) {
    if (!t4.ddoc)
      throw new Error("you must supply an index.ddoc when deleting");
    if (!t4.name)
      throw new Error("you must supply an index.name when deleting");
    var n4 = t4.ddoc, r3 = t4.name;
    return J(e4, n4, function(e5) {
      return Object.keys(e5.views).length === 1 && e5.views[r3] ? { _id: n4, _deleted: true } : (delete e5.views[r3], e5);
    }).then(function() {
      return Ke(e4).viewCleanup.apply(e4);
    }).then(function() {
      return { ok: true };
    });
  }), pt = {};
  pt.createIndex = T(function(e4, t4) {
    if (typeof e4 != "object")
      return t4(new Error("you must provide an index to create"));
    (z(this) ? De : ct)(this, e4, t4);
  }), pt.find = T(function(e4, t4) {
    if (t4 === void 0 && (t4 = e4, e4 = void 0), typeof e4 != "object")
      return t4(new Error("you must provide search parameters to find()"));
    (z(this) ? Le : ft)(this, e4, t4);
  }), pt.explain = T(function(e4, t4) {
    if (t4 === void 0 && (t4 = e4, e4 = void 0), typeof e4 != "object")
      return t4(new Error("you must provide search parameters to explain()"));
    (z(this) ? Be : lt)(this, e4, t4);
  }), pt.getIndexes = T(function(e4) {
    (z(this) ? Ie : dt)(this, e4);
  }), pt.deleteIndex = T(function(e4, t4) {
    if (typeof e4 != "object")
      return t4(new Error("you must provide an index to delete"));
    (z(this) ? Te : ht)(this, e4, t4);
  });
  const vt = pt;
}, 552: (e3) => {
  function t3(e4, t4) {
    return function(...n4) {
      function r2() {
        let r3 = null;
        const i2 = t4 === "query" ? 1 : 0;
        n4.length > i2 && typeof n4[n4.length - 1] == "function" && (r3 = n4.pop());
        let o = e4._originals[t4].bind(e4);
        for (const n5 of e4._handlers[t4])
          o = n5.bind(e4, o);
        const s = o(...n4);
        return s.then && r3 && function(e5, t5) {
          e5.then((...e6) => {
            t5(null, ...e6);
          }).catch((e6) => {
            t5(e6);
          });
        }(s, r3), s;
      }
      return t4 !== "changes" && e4.taskqueue && !e4.taskqueue.isReady ? new Promise((t5, n5) => {
        e4.taskqueue.addTask((e5) => {
          e5 ? n5(e5) : t5();
        });
      }).then(r2) : r2();
    };
  }
  const n3 = { install: function(e4, n4 = {}) {
    e4._originals && e4._handlers || (e4._originals = {}, e4._handlers = {});
    for (const [r2, i2] of Object.entries(n4)) {
      if (!(r2 in e4))
        throw new Error(`Method '${r2}' does not exist on given base, so it cannot be wrapped.`);
      r2 in e4._originals || (e4._originals[r2] = e4[r2]), r2 in e4._handlers ? e4._handlers[r2].unshift(i2) : (e4._handlers[r2] = [i2], e4[r2] = t3(e4, r2));
    }
  }, uninstall: function(e4, t4) {
    if (!e4._originals || !e4._handlers)
      throw new Error("No wrapper methods installed, so no methods can be uninstalled.");
    for (const [n4, r2] of Object.entries(t4)) {
      const t5 = `Wrapper method for '${n4}' not installed: ${r2.toString()}`;
      if (!(n4 in e4._handlers))
        throw new Error(t5);
      const i2 = e4._handlers[n4].indexOf(r2);
      if (i2 === -1)
        throw new Error(t5);
      e4._handlers[n4].splice(i2, 1);
    }
  } };
  try {
    e3.exports = n3;
  } catch (e4) {
  }
  try {
    window.PouchDBWrappers = n3;
  } catch (e4) {
  }
}, 322: (e3) => {
  e3.exports = function(e4) {
    var t3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function n3(e5, t4) {
      var n4 = e5[0], r3 = e5[1], i3 = e5[2], o2 = e5[3];
      r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & i3 | ~r3 & o2) + t4[0] - 680876936 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & i3) + t4[1] - 389564586 | 0) << 12 | o2 >>> 20) + n4 | 0) & n4 | ~o2 & r3) + t4[2] + 606105819 | 0) << 17 | i3 >>> 15) + o2 | 0) & o2 | ~i3 & n4) + t4[3] - 1044525330 | 0) << 22 | r3 >>> 10) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & i3 | ~r3 & o2) + t4[4] - 176418897 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & i3) + t4[5] + 1200080426 | 0) << 12 | o2 >>> 20) + n4 | 0) & n4 | ~o2 & r3) + t4[6] - 1473231341 | 0) << 17 | i3 >>> 15) + o2 | 0) & o2 | ~i3 & n4) + t4[7] - 45705983 | 0) << 22 | r3 >>> 10) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & i3 | ~r3 & o2) + t4[8] + 1770035416 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & i3) + t4[9] - 1958414417 | 0) << 12 | o2 >>> 20) + n4 | 0) & n4 | ~o2 & r3) + t4[10] - 42063 | 0) << 17 | i3 >>> 15) + o2 | 0) & o2 | ~i3 & n4) + t4[11] - 1990404162 | 0) << 22 | r3 >>> 10) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & i3 | ~r3 & o2) + t4[12] + 1804603682 | 0) << 7 | n4 >>> 25) + r3 | 0) & r3 | ~n4 & i3) + t4[13] - 40341101 | 0) << 12 | o2 >>> 20) + n4 | 0) & n4 | ~o2 & r3) + t4[14] - 1502002290 | 0) << 17 | i3 >>> 15) + o2 | 0) & o2 | ~i3 & n4) + t4[15] + 1236535329 | 0) << 22 | r3 >>> 10) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & o2 | i3 & ~o2) + t4[1] - 165796510 | 0) << 5 | n4 >>> 27) + r3 | 0) & i3 | r3 & ~i3) + t4[6] - 1069501632 | 0) << 9 | o2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[11] + 643717713 | 0) << 14 | i3 >>> 18) + o2 | 0) & n4 | o2 & ~n4) + t4[0] - 373897302 | 0) << 20 | r3 >>> 12) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & o2 | i3 & ~o2) + t4[5] - 701558691 | 0) << 5 | n4 >>> 27) + r3 | 0) & i3 | r3 & ~i3) + t4[10] + 38016083 | 0) << 9 | o2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[15] - 660478335 | 0) << 14 | i3 >>> 18) + o2 | 0) & n4 | o2 & ~n4) + t4[4] - 405537848 | 0) << 20 | r3 >>> 12) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & o2 | i3 & ~o2) + t4[9] + 568446438 | 0) << 5 | n4 >>> 27) + r3 | 0) & i3 | r3 & ~i3) + t4[14] - 1019803690 | 0) << 9 | o2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[3] - 187363961 | 0) << 14 | i3 >>> 18) + o2 | 0) & n4 | o2 & ~n4) + t4[8] + 1163531501 | 0) << 20 | r3 >>> 12) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 & o2 | i3 & ~o2) + t4[13] - 1444681467 | 0) << 5 | n4 >>> 27) + r3 | 0) & i3 | r3 & ~i3) + t4[2] - 51403784 | 0) << 9 | o2 >>> 23) + n4 | 0) & r3 | n4 & ~r3) + t4[7] + 1735328473 | 0) << 14 | i3 >>> 18) + o2 | 0) & n4 | o2 & ~n4) + t4[12] - 1926607734 | 0) << 20 | r3 >>> 12) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 ^ i3 ^ o2) + t4[5] - 378558 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ i3) + t4[8] - 2022574463 | 0) << 11 | o2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[11] + 1839030562 | 0) << 16 | i3 >>> 16) + o2 | 0) ^ o2 ^ n4) + t4[14] - 35309556 | 0) << 23 | r3 >>> 9) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 ^ i3 ^ o2) + t4[1] - 1530992060 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ i3) + t4[4] + 1272893353 | 0) << 11 | o2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[7] - 155497632 | 0) << 16 | i3 >>> 16) + o2 | 0) ^ o2 ^ n4) + t4[10] - 1094730640 | 0) << 23 | r3 >>> 9) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 ^ i3 ^ o2) + t4[13] + 681279174 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ i3) + t4[0] - 358537222 | 0) << 11 | o2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[3] - 722521979 | 0) << 16 | i3 >>> 16) + o2 | 0) ^ o2 ^ n4) + t4[6] + 76029189 | 0) << 23 | r3 >>> 9) + i3 | 0, r3 = ((r3 += ((i3 = ((i3 += ((o2 = ((o2 += ((n4 = ((n4 += (r3 ^ i3 ^ o2) + t4[9] - 640364487 | 0) << 4 | n4 >>> 28) + r3 | 0) ^ r3 ^ i3) + t4[12] - 421815835 | 0) << 11 | o2 >>> 21) + n4 | 0) ^ n4 ^ r3) + t4[15] + 530742520 | 0) << 16 | i3 >>> 16) + o2 | 0) ^ o2 ^ n4) + t4[2] - 995338651 | 0) << 23 | r3 >>> 9) + i3 | 0, r3 = ((r3 += ((o2 = ((o2 += (r3 ^ ((n4 = ((n4 += (i3 ^ (r3 | ~o2)) + t4[0] - 198630844 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~i3)) + t4[7] + 1126891415 | 0) << 10 | o2 >>> 22) + n4 | 0) ^ ((i3 = ((i3 += (n4 ^ (o2 | ~r3)) + t4[14] - 1416354905 | 0) << 15 | i3 >>> 17) + o2 | 0) | ~n4)) + t4[5] - 57434055 | 0) << 21 | r3 >>> 11) + i3 | 0, r3 = ((r3 += ((o2 = ((o2 += (r3 ^ ((n4 = ((n4 += (i3 ^ (r3 | ~o2)) + t4[12] + 1700485571 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~i3)) + t4[3] - 1894986606 | 0) << 10 | o2 >>> 22) + n4 | 0) ^ ((i3 = ((i3 += (n4 ^ (o2 | ~r3)) + t4[10] - 1051523 | 0) << 15 | i3 >>> 17) + o2 | 0) | ~n4)) + t4[1] - 2054922799 | 0) << 21 | r3 >>> 11) + i3 | 0, r3 = ((r3 += ((o2 = ((o2 += (r3 ^ ((n4 = ((n4 += (i3 ^ (r3 | ~o2)) + t4[8] + 1873313359 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~i3)) + t4[15] - 30611744 | 0) << 10 | o2 >>> 22) + n4 | 0) ^ ((i3 = ((i3 += (n4 ^ (o2 | ~r3)) + t4[6] - 1560198380 | 0) << 15 | i3 >>> 17) + o2 | 0) | ~n4)) + t4[13] + 1309151649 | 0) << 21 | r3 >>> 11) + i3 | 0, r3 = ((r3 += ((o2 = ((o2 += (r3 ^ ((n4 = ((n4 += (i3 ^ (r3 | ~o2)) + t4[4] - 145523070 | 0) << 6 | n4 >>> 26) + r3 | 0) | ~i3)) + t4[11] - 1120210379 | 0) << 10 | o2 >>> 22) + n4 | 0) ^ ((i3 = ((i3 += (n4 ^ (o2 | ~r3)) + t4[2] + 718787259 | 0) << 15 | i3 >>> 17) + o2 | 0) | ~n4)) + t4[9] - 343485551 | 0) << 21 | r3 >>> 11) + i3 | 0, e5[0] = n4 + e5[0] | 0, e5[1] = r3 + e5[1] | 0, e5[2] = i3 + e5[2] | 0, e5[3] = o2 + e5[3] | 0;
    }
    function r2(e5) {
      var t4, n4 = [];
      for (t4 = 0; t4 < 64; t4 += 4)
        n4[t4 >> 2] = e5.charCodeAt(t4) + (e5.charCodeAt(t4 + 1) << 8) + (e5.charCodeAt(t4 + 2) << 16) + (e5.charCodeAt(t4 + 3) << 24);
      return n4;
    }
    function i2(e5) {
      var t4, n4 = [];
      for (t4 = 0; t4 < 64; t4 += 4)
        n4[t4 >> 2] = e5[t4] + (e5[t4 + 1] << 8) + (e5[t4 + 2] << 16) + (e5[t4 + 3] << 24);
      return n4;
    }
    function o(e5) {
      var t4, i3, o2, s2, a2, u2, c2 = e5.length, f2 = [1732584193, -271733879, -1732584194, 271733878];
      for (t4 = 64; t4 <= c2; t4 += 64)
        n3(f2, r2(e5.substring(t4 - 64, t4)));
      for (i3 = (e5 = e5.substring(t4 - 64)).length, o2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t4 = 0; t4 < i3; t4 += 1)
        o2[t4 >> 2] |= e5.charCodeAt(t4) << (t4 % 4 << 3);
      if (o2[t4 >> 2] |= 128 << (t4 % 4 << 3), t4 > 55)
        for (n3(f2, o2), t4 = 0; t4 < 16; t4 += 1)
          o2[t4] = 0;
      return s2 = (s2 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a2 = parseInt(s2[2], 16), u2 = parseInt(s2[1], 16) || 0, o2[14] = a2, o2[15] = u2, n3(f2, o2), f2;
    }
    function s(e5) {
      var n4, r3 = "";
      for (n4 = 0; n4 < 4; n4 += 1)
        r3 += t3[e5 >> 8 * n4 + 4 & 15] + t3[e5 >> 8 * n4 & 15];
      return r3;
    }
    function a(e5) {
      var t4;
      for (t4 = 0; t4 < e5.length; t4 += 1)
        e5[t4] = s(e5[t4]);
      return e5.join("");
    }
    function u(e5) {
      return /[\u0080-\uFFFF]/.test(e5) && (e5 = unescape(encodeURIComponent(e5))), e5;
    }
    function c(e5) {
      var t4, n4 = [], r3 = e5.length;
      for (t4 = 0; t4 < r3 - 1; t4 += 2)
        n4.push(parseInt(e5.substr(t4, 2), 16));
      return String.fromCharCode.apply(String, n4);
    }
    function f() {
      this.reset();
    }
    return a(o("hello")), typeof ArrayBuffer == "undefined" || ArrayBuffer.prototype.slice || function() {
      function e5(e6, t4) {
        return (e6 = 0 | e6 || 0) < 0 ? Math.max(e6 + t4, 0) : Math.min(e6, t4);
      }
      ArrayBuffer.prototype.slice = function(t4, n4) {
        var r3, i3, o2, s2, a2 = this.byteLength, u2 = e5(t4, a2), c2 = a2;
        return n4 !== void 0 && (c2 = e5(n4, a2)), u2 > c2 ? new ArrayBuffer(0) : (r3 = c2 - u2, i3 = new ArrayBuffer(r3), o2 = new Uint8Array(i3), s2 = new Uint8Array(this, u2, r3), o2.set(s2), i3);
      };
    }(), f.prototype.append = function(e5) {
      return this.appendBinary(u(e5)), this;
    }, f.prototype.appendBinary = function(e5) {
      this._buff += e5, this._length += e5.length;
      var t4, i3 = this._buff.length;
      for (t4 = 64; t4 <= i3; t4 += 64)
        n3(this._hash, r2(this._buff.substring(t4 - 64, t4)));
      return this._buff = this._buff.substring(t4 - 64), this;
    }, f.prototype.end = function(e5) {
      var t4, n4, r3 = this._buff, i3 = r3.length, o2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < i3; t4 += 1)
        o2[t4 >> 2] |= r3.charCodeAt(t4) << (t4 % 4 << 3);
      return this._finish(o2, i3), n4 = a(this._hash), e5 && (n4 = c(n4)), this.reset(), n4;
    }, f.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, f.prototype.getState = function() {
      return { buff: this._buff, length: this._length, hash: this._hash.slice() };
    }, f.prototype.setState = function(e5) {
      return this._buff = e5.buff, this._length = e5.length, this._hash = e5.hash, this;
    }, f.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length;
    }, f.prototype._finish = function(e5, t4) {
      var r3, i3, o2, s2 = t4;
      if (e5[s2 >> 2] |= 128 << (s2 % 4 << 3), s2 > 55)
        for (n3(this._hash, e5), s2 = 0; s2 < 16; s2 += 1)
          e5[s2] = 0;
      r3 = (r3 = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/), i3 = parseInt(r3[2], 16), o2 = parseInt(r3[1], 16) || 0, e5[14] = i3, e5[15] = o2, n3(this._hash, e5);
    }, f.hash = function(e5, t4) {
      return f.hashBinary(u(e5), t4);
    }, f.hashBinary = function(e5, t4) {
      var n4 = a(o(e5));
      return t4 ? c(n4) : n4;
    }, f.ArrayBuffer = function() {
      this.reset();
    }, f.ArrayBuffer.prototype.append = function(e5) {
      var t4, r3, o2, s2, a2, u2 = (r3 = this._buff.buffer, o2 = e5, s2 = true, (a2 = new Uint8Array(r3.byteLength + o2.byteLength)).set(new Uint8Array(r3)), a2.set(new Uint8Array(o2), r3.byteLength), s2 ? a2 : a2.buffer), c2 = u2.length;
      for (this._length += e5.byteLength, t4 = 64; t4 <= c2; t4 += 64)
        n3(this._hash, i2(u2.subarray(t4 - 64, t4)));
      return this._buff = t4 - 64 < c2 ? new Uint8Array(u2.buffer.slice(t4 - 64)) : new Uint8Array(0), this;
    }, f.ArrayBuffer.prototype.end = function(e5) {
      var t4, n4, r3 = this._buff, i3 = r3.length, o2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t4 = 0; t4 < i3; t4 += 1)
        o2[t4 >> 2] |= r3[t4] << (t4 % 4 << 3);
      return this._finish(o2, i3), n4 = a(this._hash), e5 && (n4 = c(n4)), this.reset(), n4;
    }, f.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
    }, f.ArrayBuffer.prototype.getState = function() {
      var e5, t4 = f.prototype.getState.call(this);
      return t4.buff = (e5 = t4.buff, String.fromCharCode.apply(null, new Uint8Array(e5))), t4;
    }, f.ArrayBuffer.prototype.setState = function(e5) {
      return e5.buff = function(e6, t4) {
        var n4, r3 = e6.length, i3 = new ArrayBuffer(r3), o2 = new Uint8Array(i3);
        for (n4 = 0; n4 < r3; n4 += 1)
          o2[n4] = e6.charCodeAt(n4);
        return t4 ? o2 : i3;
      }(e5.buff, true), f.prototype.setState.call(this, e5);
    }, f.ArrayBuffer.prototype.destroy = f.prototype.destroy, f.ArrayBuffer.prototype._finish = f.prototype._finish, f.ArrayBuffer.hash = function(e5, t4) {
      var r3 = a(function(e6) {
        var t5, r4, o2, s2, a2, u2, c2 = e6.length, f2 = [1732584193, -271733879, -1732584194, 271733878];
        for (t5 = 64; t5 <= c2; t5 += 64)
          n3(f2, i2(e6.subarray(t5 - 64, t5)));
        for (r4 = (e6 = t5 - 64 < c2 ? e6.subarray(t5 - 64) : new Uint8Array(0)).length, o2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t5 = 0; t5 < r4; t5 += 1)
          o2[t5 >> 2] |= e6[t5] << (t5 % 4 << 3);
        if (o2[t5 >> 2] |= 128 << (t5 % 4 << 3), t5 > 55)
          for (n3(f2, o2), t5 = 0; t5 < 16; t5 += 1)
            o2[t5] = 0;
        return s2 = (s2 = 8 * c2).toString(16).match(/(.*?)(.{0,8})$/), a2 = parseInt(s2[2], 16), u2 = parseInt(s2[1], 16) || 0, o2[14] = a2, o2[15] = u2, n3(f2, o2), f2;
      }(new Uint8Array(e5)));
      return t4 ? c(r3) : r3;
    }, f;
  }();
}, 380: (e3, t3, n3) => {
  const r2 = n3(552);
  function i2(e4) {
    return e4[0] !== "_";
  }
  function o(e4) {
    return !(typeof e4._id != "string" || !/^_local/.test(e4._id)) || !!e4._deleted && Object.keys(e4).filter(i2).length === 0;
  }
  function s(e4) {
    const t4 = function(t5) {
      return !o(t5) && e4.incoming ? e4.incoming(t5) : t5;
    }, n4 = function(t5) {
      return !o(t5) && e4.outgoing ? e4.outgoing(t5) : t5;
    }, i3 = { get(e5, ...t5) {
      return __async(this, null, function* () {
        const r3 = yield e5(...t5);
        return Array.isArray(r3) ? (yield Promise.all(r3.map((e6) => __async(this, null, function* () {
          e6.ok && (e6.ok = yield n4(e6.ok));
        }))), r3) : n4(r3);
      });
    }, bulkDocs: (e5, n5, ...r3) => __async(this, null, function* () {
      return n5.docs ? n5.docs = yield Promise.all(n5.docs.map(t4)) : n5 = yield Promise.all(n5.map(t4)), e5(n5, ...r3);
    }), allDocs(e5, ...t5) {
      return __async(this, null, function* () {
        const r3 = yield e5(...t5);
        return yield Promise.all(r3.rows.map((e6) => __async(this, null, function* () {
          e6.doc && (e6.doc = yield n4(e6.doc));
        }))), r3;
      });
    }, bulkGet(e5, ...t5) {
      return __async(this, null, function* () {
        const r3 = (e6) => __async(this, null, function* () {
          return e6.ok ? { ok: yield n4(e6.ok) } : e6;
        });
        let _a = yield e5(...t5), { results: i4 } = _a, o2 = __objRest(_a, ["results"]);
        return i4 = yield Promise.all(i4.map((e6) => __async(this, null, function* () {
          const { id: t6, docs: n5 } = e6;
          return t6 && n5 && Array.isArray(n5) ? { id: t6, docs: yield Promise.all(n5.map(r3)) } : e6;
        }))), __spreadValues({ results: i4 }, o2);
      });
    }, changes(e5, ...t5) {
      function r3(e6) {
        return __async(this, null, function* () {
          return e6.doc ? (e6.doc = yield n4(e6.doc), e6) : e6;
        });
      }
      function i4(e6) {
        return __async(this, null, function* () {
          return e6.results ? (e6.results = yield Promise.all(e6.results.map(r3)), e6) : e6;
        });
      }
      const o2 = e5(...t5), { on: s2, then: a } = o2;
      return Object.assign(o2, { on(e6, t6) {
        const n5 = t6;
        return e6 === "change" ? t6 = (e7) => __async(this, null, function* () {
          n5(yield r3(e7));
        }) : e6 === "complete" && (t6 = (e7) => __async(this, null, function* () {
          n5(yield i4(e7));
        })), s2.call(o2, e6, t6);
      }, then: (e6, t6) => a.call(o2, i4).then(e6, t6) });
    } };
    this.type() === "http" && (i3.put = function(e5, n5, ...r3) {
      return __async(this, null, function* () {
        return e5(n5 = yield t4(n5), ...r3);
      });
    }, i3.query = function(e5, ...t5) {
      return __async(this, null, function* () {
        const r3 = yield e5(...t5);
        return yield Promise.all(r3.rows.map((e6) => __async(this, null, function* () {
          e6.doc && (e6.doc = yield n4(e6.doc));
        }))), r3;
      });
    }), r2.install(this, i3);
  }
  e3.exports = { transform: s, filter: s }, typeof window != "undefined" && window.PouchDB && window.PouchDB.plugin(t3);
}, 586: (e3, t3, n3) => {
  var r2;
  n3.d(t3, { Z: () => f });
  var i2 = new Uint8Array(16);
  function o() {
    if (!r2 && !(r2 = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto)))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return r2(i2);
  }
  const s = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, a = function(e4) {
    return typeof e4 == "string" && s.test(e4);
  };
  for (var u = [], c = 0; c < 256; ++c)
    u.push((c + 256).toString(16).substr(1));
  const f = function(e4, t4, n4) {
    var r3 = (e4 = e4 || {}).random || (e4.rng || o)();
    if (r3[6] = 15 & r3[6] | 64, r3[8] = 63 & r3[8] | 128, t4) {
      n4 = n4 || 0;
      for (var i3 = 0; i3 < 16; ++i3)
        t4[n4 + i3] = r3[i3];
      return t4;
    }
    return function(e5) {
      var t5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n5 = (u[e5[t5 + 0]] + u[e5[t5 + 1]] + u[e5[t5 + 2]] + u[e5[t5 + 3]] + "-" + u[e5[t5 + 4]] + u[e5[t5 + 5]] + "-" + u[e5[t5 + 6]] + u[e5[t5 + 7]] + "-" + u[e5[t5 + 8]] + u[e5[t5 + 9]] + "-" + u[e5[t5 + 10]] + u[e5[t5 + 11]] + u[e5[t5 + 12]] + u[e5[t5 + 13]] + u[e5[t5 + 14]] + u[e5[t5 + 15]]).toLowerCase();
      if (!a(n5))
        throw TypeError("Stringified UUID is invalid");
      return n5;
    }(r3);
  };
}, 684: (e3, t3) => {
  function n3(e4, t4, n4) {
    var r2 = n4[n4.length - 1];
    e4 === r2.element && (n4.pop(), r2 = n4[n4.length - 1]);
    var i2 = r2.element, o = r2.index;
    Array.isArray(i2) ? i2.push(e4) : o === t4.length - 2 ? i2[t4.pop()] = e4 : t4.push(e4);
  }
  t3.stringify = function(e4) {
    var t4 = [];
    t4.push({ obj: e4 });
    for (var n4, r2, i2, o, s, a, u, c, f, l, d = ""; n4 = t4.pop(); )
      if (r2 = n4.obj, d += n4.prefix || "", i2 = n4.val || "")
        d += i2;
      else if (typeof r2 != "object")
        d += r2 === void 0 ? null : JSON.stringify(r2);
      else if (r2 === null)
        d += "null";
      else if (Array.isArray(r2)) {
        for (t4.push({ val: "]" }), o = r2.length - 1; o >= 0; o--)
          s = o === 0 ? "" : ",", t4.push({ obj: r2[o], prefix: s });
        t4.push({ val: "[" });
      } else {
        for (u in a = [], r2)
          r2.hasOwnProperty(u) && a.push(u);
        for (t4.push({ val: "}" }), o = a.length - 1; o >= 0; o--)
          f = r2[c = a[o]], l = o > 0 ? "," : "", l += JSON.stringify(c) + ":", t4.push({ obj: f, prefix: l });
        t4.push({ val: "{" });
      }
    return d;
  }, t3.parse = function(e4) {
    for (var t4, r2, i2, o, s, a, u, c, f, l = [], d = [], h = 0; ; )
      if ((t4 = e4[h++]) !== "}" && t4 !== "]" && t4 !== void 0)
        switch (t4) {
          case " ":
          case "	":
          case "\n":
          case ":":
          case ",":
            break;
          case "n":
            h += 3, n3(null, l, d);
            break;
          case "t":
            h += 3, n3(true, l, d);
            break;
          case "f":
            h += 4, n3(false, l, d);
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
          case "-":
            for (r2 = "", h--; ; ) {
              if (i2 = e4[h++], !/[\d\.\-e\+]/.test(i2)) {
                h--;
                break;
              }
              r2 += i2;
            }
            n3(parseFloat(r2), l, d);
            break;
          case '"':
            for (o = "", s = void 0, a = 0; (u = e4[h++]) !== '"' || s === "\\" && a % 2 == 1; )
              o += u, (s = u) === "\\" ? a++ : a = 0;
            n3(JSON.parse('"' + o + '"'), l, d);
            break;
          case "[":
            c = { element: [], index: l.length }, l.push(c.element), d.push(c);
            break;
          case "{":
            f = { element: {}, index: l.length }, l.push(f.element), d.push(f);
            break;
          default:
            throw new Error("unexpectedly reached end of input: " + t4);
        }
      else {
        if (l.length === 1)
          return l.pop();
        n3(l.pop(), l, d);
      }
  };
}, 525: () => {
} };
var t = {};
function n(r2) {
  var i2 = t[r2];
  if (i2 !== void 0)
    return i2.exports;
  var o = t[r2] = { exports: {} };
  return e[r2](o, o.exports, n), o.exports;
}
n.n = (e3) => {
  var t3 = e3 && e3.__esModule ? () => e3.default : () => e3;
  return n.d(t3, { a: t3 }), t3;
}, n.d = (e3, t3) => {
  for (var r2 in t3)
    n.o(t3, r2) && !n.o(e3, r2) && Object.defineProperty(e3, r2, { enumerable: true, get: t3[r2] });
}, n.g = function() {
  if (typeof globalThis == "object")
    return globalThis;
  try {
    return this || new Function("return this")();
  } catch (e3) {
    if (typeof window == "object")
      return window;
  }
}(), n.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3);
var r = {};
(() => {
  n.d(r, { o: () => o });
  const e3 = n(198).Z, t3 = n(614).Z, i2 = n(380), o = e3.plugin(t3).plugin(i2);
})();
var i = r.o;

// src/pouchdb-browser.ts
var Pouch = i;

// node_modules/xxhash-wasm/esm/xxhash-wasm.js
var t2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 2, 127, 127, 0, 96, 3, 127, 127, 127, 1, 127, 3, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 23, 3, 3, 109, 101, 109, 2, 0, 5, 120, 120, 104, 51, 50, 0, 0, 5, 120, 120, 104, 54, 52, 0, 1, 10, 152, 9, 2, 242, 2, 1, 4, 127, 32, 0, 32, 1, 106, 33, 3, 32, 1, 32, 1, 65, 16, 79, 4, 127, 32, 3, 65, 16, 107, 33, 6, 32, 2, 65, 168, 136, 141, 161, 2, 106, 33, 1, 32, 2, 65, 137, 235, 208, 208, 7, 107, 33, 4, 32, 2, 65, 207, 140, 162, 142, 6, 106, 33, 5, 3, 64, 32, 1, 32, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 1, 32, 4, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 4, 32, 2, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 5, 32, 0, 65, 4, 106, 34, 0, 40, 2, 0, 65, 247, 148, 175, 175, 120, 108, 106, 65, 13, 119, 65, 177, 243, 221, 241, 121, 108, 33, 5, 32, 6, 32, 0, 65, 4, 106, 34, 0, 79, 13, 0, 11, 32, 2, 65, 12, 119, 32, 5, 65, 18, 119, 106, 32, 4, 65, 7, 119, 106, 32, 1, 65, 1, 119, 106, 5, 32, 2, 65, 177, 207, 217, 178, 1, 106, 11, 106, 33, 2, 3, 64, 32, 3, 32, 0, 65, 4, 106, 79, 4, 64, 32, 2, 32, 0, 40, 2, 0, 65, 189, 220, 202, 149, 124, 108, 106, 65, 17, 119, 65, 175, 214, 211, 190, 2, 108, 33, 2, 32, 0, 65, 4, 106, 33, 0, 12, 1, 11, 11, 3, 64, 32, 0, 32, 3, 73, 4, 64, 32, 2, 32, 0, 45, 0, 0, 65, 177, 207, 217, 178, 1, 108, 106, 65, 11, 119, 65, 177, 243, 221, 241, 121, 108, 33, 2, 32, 0, 65, 1, 106, 33, 0, 12, 1, 11, 11, 32, 2, 32, 2, 65, 15, 118, 115, 65, 247, 148, 175, 175, 120, 108, 34, 0, 65, 13, 118, 32, 0, 115, 65, 189, 220, 202, 149, 124, 108, 34, 0, 65, 16, 118, 32, 0, 115, 11, 161, 6, 2, 4, 126, 3, 127, 32, 0, 65, 4, 106, 53, 2, 0, 32, 0, 53, 2, 0, 66, 32, 134, 132, 33, 2, 32, 1, 32, 0, 65, 8, 106, 34, 6, 106, 33, 7, 32, 1, 65, 32, 79, 4, 126, 32, 7, 65, 32, 107, 33, 8, 32, 2, 66, 214, 235, 130, 238, 234, 253, 137, 245, 224, 0, 124, 33, 3, 32, 2, 66, 177, 169, 172, 193, 173, 184, 212, 166, 61, 125, 33, 4, 32, 2, 66, 249, 234, 208, 208, 231, 201, 161, 228, 225, 0, 124, 33, 5, 3, 64, 32, 3, 32, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 3, 32, 4, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 4, 32, 2, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 5, 32, 6, 65, 8, 106, 34, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 124, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 5, 32, 8, 32, 6, 65, 8, 106, 34, 6, 79, 13, 0, 11, 32, 2, 66, 12, 137, 32, 5, 66, 18, 137, 124, 32, 4, 66, 7, 137, 124, 32, 3, 66, 1, 137, 124, 32, 3, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 4, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 2, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 32, 5, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 5, 32, 2, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 124, 11, 32, 1, 173, 124, 33, 2, 3, 64, 32, 7, 32, 6, 65, 8, 106, 79, 4, 64, 32, 2, 32, 6, 41, 3, 0, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 31, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 27, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 66, 157, 163, 181, 234, 131, 177, 141, 138, 250, 0, 125, 33, 2, 32, 6, 65, 8, 106, 33, 6, 12, 1, 11, 11, 32, 6, 65, 4, 106, 32, 7, 77, 4, 64, 32, 2, 32, 6, 53, 2, 0, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 133, 66, 23, 137, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 124, 33, 2, 32, 6, 65, 4, 106, 33, 6, 11, 3, 64, 32, 6, 32, 7, 73, 4, 64, 32, 2, 32, 6, 49, 0, 0, 66, 197, 207, 217, 178, 241, 229, 186, 234, 39, 126, 133, 66, 11, 137, 66, 135, 149, 175, 175, 152, 182, 222, 155, 158, 127, 126, 33, 2, 32, 6, 65, 1, 106, 33, 6, 12, 1, 11, 11, 32, 0, 32, 2, 32, 2, 66, 33, 136, 133, 66, 207, 214, 211, 190, 210, 199, 171, 217, 66, 126, 34, 2, 66, 29, 136, 32, 2, 133, 66, 249, 243, 221, 241, 153, 246, 153, 171, 22, 126, 34, 2, 66, 32, 136, 32, 2, 133, 34, 2, 66, 32, 136, 62, 2, 0, 32, 0, 65, 4, 106, 32, 2, 62, 2, 0, 11]);
var e2;
function n2(t3, e3, n3) {
  if (e3.buffer.byteLength < t3.byteLength + n3) {
    const i2 = Math.ceil((t3.byteLength + n3 - e3.buffer.byteLength) / 65536);
    e3.grow(i2);
  }
  new Uint8Array(e3.buffer, n3).set(t3);
}
function xxhash_wasm_default() {
  return __async(this, null, function* () {
    const { instance: { exports: { mem: i2, xxh32: o, xxh64: r2 } } } = yield WebAssembly.instantiate(t2);
    function h(t3) {
      let e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      return n2(t3, i2, 0), o(0, t3.byteLength, e3) >>> 0;
    }
    function c(t3) {
      let e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      n2(t3, i2, 8);
      const h2 = new DataView(i2.buffer);
      return h2.setUint32(0, e3, true), h2.setUint32(4, o2, true), r2(0, t3.byteLength), h2;
    }
    return { h32: function(t3) {
      let n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      e2 || (e2 = new TextEncoder());
      const i3 = e2.encode(t3);
      return h(i3, n3).toString(16);
    }, h32Raw: h, h64: function(t3) {
      let n3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      e2 || (e2 = new TextEncoder());
      const o2 = e2.encode(t3), r3 = c(o2, n3, i3), h2 = r3.getUint32(0, true).toString(16) + r3.getUint32(4, true).toString(16);
      return h2;
    }, h64Raw: function(t3) {
      let e3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return new Uint8Array(c(t3, e3, n3).buffer, 0, 8);
    } };
  });
}

// src/utils.ts
var import_obsidian = __toModule(require("obsidian"));
function path2id(filename) {
  const x = (0, import_obsidian.normalizePath)(filename);
  return path2id_base(x);
}
function id2path(filename) {
  return id2path_base((0, import_obsidian.normalizePath)(filename));
}

// src/utils_couchdb.ts
var import_obsidian2 = __toModule(require("obsidian"));
var isValidRemoteCouchDBURI = (uri) => {
  if (uri.startsWith("https://"))
    return true;
  if (uri.startsWith("http://"))
    return true;
  return false;
};
var last_post_successed = false;
var getLastPostFailedBySize = () => {
  return !last_post_successed;
};
var fetchByAPI = (request) => __async(void 0, null, function* () {
  var _a, _b;
  const ret = yield (0, import_obsidian2.requestUrl)(request);
  if (ret.status - ret.status % 100 !== 200) {
    const er = new Error(`Request Error:${ret.status}`);
    if (ret.json) {
      er.message = ret.json.reason;
      er.name = `${(_a = ret.json.error) != null ? _a : ""}:${(_b = ret.json.message) != null ? _b : ""}`;
    }
    er.status = ret.status;
    throw er;
  }
  return ret;
});
var connectRemoteCouchDBWithSetting = (settings, isMobile) => connectRemoteCouchDB(settings.couchDB_URI + (settings.couchDB_DBNAME == "" ? "" : "/" + settings.couchDB_DBNAME), {
  username: settings.couchDB_USER,
  password: settings.couchDB_PASSWORD
}, settings.disableRequestURI || isMobile, settings.encrypt ? settings.passphrase : settings.encrypt);
var connectRemoteCouchDB = (uri, auth, disableRequestURI, passphrase) => __async(void 0, null, function* () {
  if (!isValidRemoteCouchDBURI(uri))
    return "Remote URI is not valid";
  let authHeader = "";
  if (auth.username && auth.password) {
    const utf8str = String.fromCharCode.apply(null, new TextEncoder().encode(`${auth.username}:${auth.password}`));
    const encoded = window.btoa(utf8str);
    authHeader = "Basic " + encoded;
  } else {
    authHeader = "";
  }
  const conf = {
    adapter: "http",
    auth,
    fetch: function(url, opts) {
      return __async(this, null, function* () {
        var _a, _b;
        let size = "";
        const localURL = url.toString().substring(uri.length);
        const method = (_a = opts.method) != null ? _a : "GET";
        if (opts.body) {
          const opts_length = opts.body.toString().length;
          if (opts_length > 1024 * 1024 * 10) {
            if (uri.contains(".cloudantnosqldb.")) {
              last_post_successed = false;
              Logger("This request should fail on IBM Cloudant.", LOG_LEVEL.VERBOSE);
              throw new Error("This request should fail on IBM Cloudant.");
            }
          }
          size = ` (${opts_length})`;
        }
        if (!disableRequestURI && typeof url == "string" && typeof ((_b = opts.body) != null ? _b : "") == "string") {
          const body = opts.body;
          const transformedHeaders = __spreadValues({}, opts.headers);
          if (authHeader != "")
            transformedHeaders["authorization"] = authHeader;
          delete transformedHeaders["host"];
          delete transformedHeaders["Host"];
          delete transformedHeaders["content-length"];
          delete transformedHeaders["Content-Length"];
          const requestParam = {
            url,
            method: opts.method,
            body,
            headers: transformedHeaders,
            contentType: "application/json"
          };
          try {
            const r2 = yield fetchByAPI(requestParam);
            if (method == "POST" || method == "PUT") {
              last_post_successed = r2.status - r2.status % 100 == 200;
            } else {
              last_post_successed = true;
            }
            Logger(`HTTP:${method}${size} to:${localURL} -> ${r2.status}`, LOG_LEVEL.DEBUG);
            return new Response(r2.arrayBuffer, {
              headers: r2.headers,
              status: r2.status,
              statusText: `${r2.status}`
            });
          } catch (ex) {
            Logger(`HTTP:${method}${size} to:${localURL} -> failed`, LOG_LEVEL.VERBOSE);
            if (url.toString().indexOf("_bulk_docs") !== -1) {
              last_post_successed = false;
            }
            Logger(ex);
            throw ex;
          }
        }
        try {
          const responce = yield fetch(url, opts);
          if (method == "POST" || method == "PUT") {
            last_post_successed = responce.ok;
          } else {
            last_post_successed = true;
          }
          Logger(`HTTP:${method}${size} to:${localURL} -> ${responce.status}`, LOG_LEVEL.DEBUG);
          return responce;
        } catch (ex) {
          Logger(`HTTP:${method}${size} to:${localURL} -> failed`, LOG_LEVEL.VERBOSE);
          if (url.toString().indexOf("_bulk_docs") !== -1) {
            last_post_successed = false;
          }
          Logger(ex);
          throw ex;
        }
      });
    }
  };
  const db = new Pouch(uri, conf);
  if (passphrase && typeof passphrase === "string") {
    enableEncryption(db, passphrase);
  }
  try {
    const info = yield db.info();
    return { db, info };
  } catch (ex) {
    let msg = `${ex.name}:${ex.message}`;
    if (ex.name == "TypeError" && ex.message == "Failed to fetch") {
      msg += "\n**Note** This error caused by many reasons. The only sure thing is you didn't touch the server.\nTo check details, open inspector.";
    }
    Logger(ex, LOG_LEVEL.VERBOSE);
    return msg;
  }
});
var checkRemoteVersion = (_0, _1, ..._2) => __async(void 0, [_0, _1, ..._2], function* (db, migrate, barrier = VER) {
  try {
    const versionInfo = yield db.get(VERSIONINFO_DOCID);
    if (versionInfo.type != "versioninfo") {
      return false;
    }
    const version = versionInfo.version;
    if (version < barrier) {
      const versionUpResult = yield migrate(version, barrier);
      if (versionUpResult) {
        yield bumpRemoteVersion(db);
        return true;
      }
    }
    if (version == barrier)
      return true;
    return false;
  } catch (ex) {
    if (ex.status && ex.status == 404) {
      if (yield bumpRemoteVersion(db)) {
        return true;
      }
      return false;
    }
    throw ex;
  }
});
var bumpRemoteVersion = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (db, barrier = VER) {
  const vi = {
    _id: VERSIONINFO_DOCID,
    version: barrier,
    type: "versioninfo"
  };
  const versionInfo = yield resolveWithIgnoreKnownError(db.get(VERSIONINFO_DOCID), vi);
  if (versionInfo.type != "versioninfo") {
    return false;
  }
  vi._rev = versionInfo._rev;
  yield db.put(vi);
  return true;
});
var checkSyncInfo = (db) => __async(void 0, null, function* () {
  try {
    const syncinfo = yield db.get(SYNCINFO_ID);
    console.log(syncinfo);
    return true;
  } catch (ex) {
    if (ex.status && ex.status == 404) {
      const randomStrSrc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const temp = [...Array(30)].map((e3) => Math.floor(Math.random() * randomStrSrc.length)).map((e3) => randomStrSrc[e3]).join("");
      const newSyncInfo = {
        _id: SYNCINFO_ID,
        type: "syncinfo",
        data: temp
      };
      if (yield db.put(newSyncInfo)) {
        return true;
      }
      return false;
    } else {
      console.dir(ex);
      return false;
    }
  }
});

// node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = new WeakMap();
var transactionDoneMap = new WeakMap();
var transactionStoreNamesMap = new WeakMap();
var transformCache = new WeakMap();
var reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);

// node_modules/idb/build/index.js
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
    });
  }
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking)
      db.addEventListener("versionchange", () => blocking());
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  return wrap(request).then(() => void 0);
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method = function(storeName, ...args) {
    return __async(this, null, function* () {
      const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
      let target2 = tx.store;
      if (useIndex)
        target2 = target2.index(args.shift());
      return (yield Promise.all([
        target2[targetFuncName](...args),
        isWrite && tx.done
      ]))[0];
    });
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => __spreadProps(__spreadValues({}, oldTraps), {
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// src/KeyValueDB.ts
var databaseCache = {};
var OpenKeyValueDatabase = (dbKey) => {
  if (dbKey in databaseCache) {
    databaseCache[dbKey].close();
    delete databaseCache[dbKey];
  }
  const storeKey = dbKey;
  const dbPromise = openDB(dbKey, 1, {
    upgrade(db) {
      db.createObjectStore(storeKey);
    }
  });
  ~(() => __async(void 0, null, function* () {
    return databaseCache[dbKey] = yield dbPromise;
  }))();
  return {
    get(key) {
      return __async(this, null, function* () {
        return (yield dbPromise).get(storeKey, key);
      });
    },
    set(key, value) {
      return __async(this, null, function* () {
        return (yield dbPromise).put(storeKey, value, key);
      });
    },
    del(key) {
      return __async(this, null, function* () {
        return (yield dbPromise).delete(storeKey, key);
      });
    },
    clear() {
      return __async(this, null, function* () {
        return (yield dbPromise).clear(storeKey);
      });
    },
    keys(query, count) {
      return __async(this, null, function* () {
        return (yield dbPromise).getAllKeys(storeKey, query, count);
      });
    },
    close() {
      return __async(this, null, function* () {
        delete databaseCache[dbKey];
        return (yield dbPromise).close();
      });
    },
    destroy() {
      return __async(this, null, function* () {
        delete databaseCache[dbKey];
        (yield dbPromise).close();
        yield deleteDB(dbKey);
      });
    }
  };
};

// src/LocalPouchDB.ts
var LRUCache = class {
  constructor() {
    this.cache = new Map([]);
    this.revCache = new Map([]);
    this.maxCache = 100;
  }
  get(key) {
    const v = this.cache.get(key);
    if (v) {
      this.cache.delete(key);
      this.revCache.delete(v);
      this.cache.set(key, v);
      this.revCache.set(v, key);
    }
    return v;
  }
  revGet(value) {
    const key = this.revCache.get(value);
    if (value) {
      this.cache.delete(key);
      this.revCache.delete(value);
      this.cache.set(key, value);
      this.revCache.set(value, key);
    }
    return key;
  }
  set(key, value) {
    this.cache.set(key, value);
    this.revCache.set(value, key);
    if (this.cache.size > this.maxCache) {
      for (const kv of this.cache) {
        this.revCache.delete(kv[1]);
        this.cache.delete(kv[0]);
        if (this.cache.size <= this.maxCache)
          break;
      }
    }
  }
};
var LocalPouchDB = class {
  constructor(settings, dbname, isMobile) {
    this.nodeid = "";
    this.isReady = false;
    this.recentModifiedDocs = [];
    this.hashCaches = new LRUCache();
    this.corruptedEntries = {};
    this.remoteLocked = false;
    this.remoteLockedAndDeviceNotAccepted = false;
    this.changeHandler = null;
    this.syncHandler = null;
    this.leafArrivedCallbacks = {};
    this.syncStatus = "NOT_CONNECTED";
    this.docArrived = 0;
    this.docSent = 0;
    this.docSeq = "";
    this.isMobile = false;
    this.updateInfo = () => {
      console.log("default updinfo");
    };
    this.originalSetting = null;
    this.gcRunning = false;
    this.auth = {
      username: "",
      password: ""
    };
    this.dbname = dbname;
    this.settings = settings;
    this.cancelHandler = this.cancelHandler.bind(this);
    this.isMobile = isMobile;
  }
  cancelHandler(handler) {
    if (handler != null) {
      handler.removeAllListeners();
      handler.cancel();
      handler = null;
    }
    return null;
  }
  onunload() {
    this.kvDB.close();
    this.recentModifiedDocs = [];
    this.leafArrivedCallbacks;
    this.changeHandler = this.cancelHandler(this.changeHandler);
    this.syncHandler = this.cancelHandler(this.syncHandler);
    this.localDatabase.removeAllListeners();
  }
  close() {
    Logger("Database closed (by close)");
    this.isReady = false;
    this.changeHandler = this.cancelHandler(this.changeHandler);
    if (this.localDatabase != null) {
      this.localDatabase.close();
    }
    this.kvDB.close();
  }
  isOldDatabaseExists() {
    return __async(this, null, function* () {
      const db = new Pouch(this.dbname + "-livesync", {
        auto_compaction: this.settings.useHistory ? false : true,
        revs_limit: 20,
        deterministic_revs: true,
        skip_setup: true
      });
      try {
        const info = yield db.info();
        Logger(info, LOG_LEVEL.VERBOSE);
        return db;
      } catch (ex) {
        return false;
      }
    });
  }
  initializeDatabase() {
    return __async(this, null, function* () {
      yield this.prepareHashFunctions();
      if (this.localDatabase != null)
        this.localDatabase.close();
      this.changeHandler = this.cancelHandler(this.changeHandler);
      this.localDatabase = null;
      this.localDatabase = new Pouch(this.dbname + "-livesync-v2", {
        auto_compaction: this.settings.useHistory ? false : true,
        revs_limit: 100,
        deterministic_revs: true
      });
      this.kvDB = OpenKeyValueDatabase(this.dbname + "-livesync-kv");
      Logger("Database info", LOG_LEVEL.VERBOSE);
      Logger(yield this.localDatabase.info(), LOG_LEVEL.VERBOSE);
      Logger("Open Database...");
      const nextSeq = () => __async(this, null, function* () {
        Logger("Database Info");
        Logger(yield this.localDatabase.info(), LOG_LEVEL.VERBOSE);
        const nodeinfo = yield resolveWithIgnoreKnownError(this.localDatabase.get(NODEINFO_DOCID), {
          _id: NODEINFO_DOCID,
          type: "nodeinfo",
          nodeid: "",
          v20220607: true
        });
        if (nodeinfo.nodeid == "") {
          nodeinfo.nodeid = Math.random().toString(36).slice(-10);
          yield this.localDatabase.put(nodeinfo);
        }
        this.localDatabase.on("close", () => {
          Logger("Database closed.");
          this.isReady = false;
          this.localDatabase.removeAllListeners();
        });
        this.nodeid = nodeinfo.nodeid;
        const changes = this.localDatabase.changes({
          since: "now",
          live: true,
          filter: (doc) => doc.type == "leaf"
        }).on("change", (e3) => {
          if (e3.deleted)
            return;
          this.leafArrived(e3.id);
          this.docSeq = `${e3.seq}`;
        });
        this.changeHandler = changes;
        this.isReady = true;
        Logger("Database is now ready.");
        return true;
      });
      Logger("Checking old database", LOG_LEVEL.VERBOSE);
      const old = yield this.isOldDatabaseExists();
      if (old) {
        const oi = yield old.info();
        if (oi.doc_count == 0) {
          Logger("Old database is empty, proceed to next step", LOG_LEVEL.VERBOSE);
          return nextSeq();
        }
        const progress = NewNotice("Converting..", 0);
        try {
          Logger("We have to upgrade database..", LOG_LEVEL.NOTICE);
          const newDbStatus = yield this.localDatabase.info();
          Logger("New database is initialized");
          Logger(newDbStatus);
          if (this.settings.encrypt) {
            enableEncryption(old, this.settings.passphrase, true);
          }
          const rep = old.replicate.to(this.localDatabase, { batch_size: 25, batches_limit: 10 });
          rep.on("change", (e3) => {
            progress.setMessage(`Converting ${e3.docs_written} docs...`);
            Logger(`Converting ${e3.docs_written} docs...`, LOG_LEVEL.VERBOSE);
          });
          const w = yield rep;
          progress.hide();
          if (w.ok) {
            Logger("Conversion completed!", LOG_LEVEL.NOTICE);
            old.destroy();
            this.isReady = true;
            return yield nextSeq();
          } else {
            throw new Error("Conversion failed!");
          }
        } catch (ex) {
          progress.hide();
          Logger("Conversion failed!, If you are fully synchronized, please drop the old database in the Hatch pane in setting dialog. or please make an issue on Github.", LOG_LEVEL.NOTICE);
          Logger(ex);
          this.isReady = false;
          return false;
        }
      } else {
        return yield nextSeq();
      }
    });
  }
  prepareHashFunctions() {
    return __async(this, null, function* () {
      if (this.h32 != null)
        return;
      const { h32, h64, h32Raw } = yield xxhash_wasm_default();
      this.h32 = h32;
      this.h64 = h64;
      this.h32Raw = h32Raw;
    });
  }
  leafArrived(id) {
    if (typeof this.leafArrivedCallbacks[id] !== "undefined") {
      for (const func of this.leafArrivedCallbacks[id]) {
        func();
      }
      delete this.leafArrivedCallbacks[id];
    }
  }
  waitForLeafReady(id) {
    return new Promise((res, rej) => {
      const timer = setTimeout(() => rej(new Error(`Chunk reading timed out:${id}`)), LEAF_WAIT_TIMEOUT);
      if (typeof this.leafArrivedCallbacks[id] == "undefined") {
        this.leafArrivedCallbacks[id] = [];
      }
      this.leafArrivedCallbacks[id].push(() => {
        clearTimeout(timer);
        res(true);
      });
    });
  }
  getDBLeaf(id, waitForReady) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const leaf = this.hashCaches.revGet(id);
      if (leaf) {
        return leaf;
      }
      try {
        const w = yield this.localDatabase.get(id);
        if (w.type == "leaf") {
          this.hashCaches.set(id, w.data);
          return w.data;
        }
        throw new Error(`Corrupted chunk detected: ${id}`);
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          if (waitForReady) {
            if ((yield this.waitForLeafReady(id)) === false) {
              throw new Error(`time out (waiting chunk)`);
            }
            return this.getDBLeaf(id, false);
          } else {
            throw new Error(`Chunk was not found: ${id}`);
          }
        } else {
          Logger(`Something went wrong on retriving chunk`);
          throw ex;
        }
      }
    });
  }
  getDBEntryMeta(path, opt) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const id = path2id(path);
      try {
        let obj = null;
        if (opt) {
          obj = yield this.localDatabase.get(id, opt);
        } else {
          obj = yield this.localDatabase.get(id);
        }
        if (obj.type && obj.type == "leaf") {
          return false;
        }
        if (!obj.type || obj.type && obj.type == "notes" || obj.type == "newnote" || obj.type == "plain") {
          const note = obj;
          let children2 = [];
          if (obj.type == "newnote" || obj.type == "plain") {
            children2 = obj.children;
          }
          const doc = {
            data: "",
            _id: note._id,
            ctime: note.ctime,
            mtime: note.mtime,
            size: note.size,
            _deleted: obj._deleted,
            _rev: obj._rev,
            _conflicts: obj._conflicts,
            children: children2,
            datatype: "newnote"
          };
          return doc;
        }
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
        throw ex;
      }
      return false;
    });
  }
  getDBEntry(path, opt, dump = false, waitForReady = true) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const id = path2id(path);
      try {
        let obj = null;
        if (opt) {
          obj = yield this.localDatabase.get(id, opt);
        } else {
          obj = yield this.localDatabase.get(id);
        }
        if (obj.type && obj.type == "leaf") {
          return false;
        }
        if (!obj.type || obj.type && obj.type == "notes") {
          const note = obj;
          const doc = {
            data: note.data,
            _id: note._id,
            ctime: note.ctime,
            mtime: note.mtime,
            size: note.size,
            _deleted: obj._deleted,
            _rev: obj._rev,
            _conflicts: obj._conflicts,
            children: [],
            datatype: "newnote"
          };
          if (typeof this.corruptedEntries[doc._id] != "undefined") {
            delete this.corruptedEntries[doc._id];
          }
          if (dump) {
            Logger(`Simple doc`);
            Logger(doc);
          }
          return doc;
        }
        if (obj.type == "newnote" || obj.type == "plain") {
          try {
            if (dump) {
              Logger(`Enhanced doc`);
              Logger(obj);
            }
            let childrens;
            try {
              childrens = yield Promise.all(obj.children.map((e3) => this.getDBLeaf(e3, waitForReady)));
              if (dump) {
                Logger(`Chunks:`);
                Logger(childrens);
              }
            } catch (ex) {
              Logger(`Something went wrong on reading chunks of ${obj._id} from database, see verbose info for detail.`, LOG_LEVEL.NOTICE);
              Logger(ex, LOG_LEVEL.VERBOSE);
              this.corruptedEntries[obj._id] = obj;
              return false;
            }
            const data = childrens.join("");
            const doc = {
              data,
              _id: obj._id,
              ctime: obj.ctime,
              mtime: obj.mtime,
              size: obj.size,
              _deleted: obj._deleted,
              _rev: obj._rev,
              children: obj.children,
              datatype: obj.type,
              _conflicts: obj._conflicts
            };
            if (dump) {
              Logger(`therefore:`);
              Logger(doc);
            }
            if (typeof this.corruptedEntries[doc._id] != "undefined") {
              delete this.corruptedEntries[doc._id];
            }
            return doc;
          } catch (ex) {
            if (ex.status && ex.status == 404) {
              Logger(`Missing document content!, could not read ${obj._id} from database.`, LOG_LEVEL.NOTICE);
              return false;
            }
            Logger(`Something went wrong on reading ${obj._id} from database:`, LOG_LEVEL.NOTICE);
            Logger(ex);
          }
        }
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
        throw ex;
      }
      return false;
    });
  }
  deleteDBEntry(path, opt) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const id = path2id(path);
      try {
        let obj = null;
        return yield runWithLock("file:" + id, false, () => __async(this, null, function* () {
          if (opt) {
            obj = yield this.localDatabase.get(id, opt);
          } else {
            obj = yield this.localDatabase.get(id);
          }
          if (obj.type && obj.type == "leaf") {
            return false;
          }
          if (!obj.type || obj.type && obj.type == "notes") {
            obj._deleted = true;
            const r2 = yield this.localDatabase.put(obj);
            Logger(`entry removed:${obj._id}-${r2.rev}`);
            if (typeof this.corruptedEntries[obj._id] != "undefined") {
              delete this.corruptedEntries[obj._id];
            }
            return true;
          }
          if (obj.type == "newnote" || obj.type == "plain") {
            obj._deleted = true;
            const r2 = yield this.localDatabase.put(obj);
            Logger(`entry removed:${obj._id}-${r2.rev}`);
            if (typeof this.corruptedEntries[obj._id] != "undefined") {
              delete this.corruptedEntries[obj._id];
            }
            return true;
          } else {
            return false;
          }
        }));
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
        throw ex;
      }
    });
  }
  deleteDBEntryPrefix(prefixSrc) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      let c = 0;
      let readCount = 0;
      const delDocs = [];
      const prefix = path2id(prefixSrc);
      do {
        const result = yield this.localDatabase.allDocs({ include_docs: false, skip: c, limit: 100, conflicts: true });
        readCount = result.rows.length;
        if (readCount > 0) {
          for (const v of result.rows) {
            if (v.id.startsWith(prefix) || v.id.startsWith("/" + prefix)) {
              delDocs.push(v.id);
            } else {
              if (!v.id.startsWith("h:")) {
              }
            }
          }
        }
        c += readCount;
      } while (readCount != 0);
      let deleteCount = 0;
      let notfound = 0;
      for (const v of delDocs) {
        try {
          yield runWithLock("file:" + v, false, () => __async(this, null, function* () {
            const item = yield this.localDatabase.get(v);
            item._deleted = true;
            yield this.localDatabase.put(item);
          }));
          deleteCount++;
        } catch (ex) {
          if (ex.status && ex.status == 404) {
            notfound++;
          } else {
            throw ex;
          }
        }
      }
      Logger(`deleteDBEntryPrefix:deleted ${deleteCount} items, skipped ${notfound}`);
      return true;
    });
  }
  putDBEntry(note) {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      const savenNotes = [];
      let processed = 0;
      let made = 0;
      let skiped = 0;
      let pieceSize = MAX_DOC_SIZE_BIN;
      let plainSplit = false;
      let cacheUsed = 0;
      const userpasswordHash = this.h32Raw(new TextEncoder().encode(this.settings.passphrase));
      if (shouldSplitAsPlainText(note._id)) {
        pieceSize = MAX_DOC_SIZE;
        plainSplit = true;
      }
      const newLeafs = [];
      let minimumChunkSize = this.settings.minimumChunkSize;
      if (minimumChunkSize < 10)
        minimumChunkSize = 10;
      let longLineThreshold = this.settings.longLineThreshold;
      if (longLineThreshold < 100)
        longLineThreshold = 100;
      const pieces = splitPieces2(note.data, pieceSize, plainSplit, minimumChunkSize, longLineThreshold);
      for (const piece of pieces()) {
        processed++;
        let leafid = "";
        let hashedPiece = "";
        let hashQ = 0;
        let tryNextHash = false;
        let needMake = true;
        const cache = this.hashCaches.get(piece);
        if (cache) {
          hashedPiece = "";
          leafid = cache;
          needMake = false;
          skiped++;
          cacheUsed++;
        } else {
          if (this.settings.encrypt) {
            hashedPiece = "+" + (this.h32Raw(new TextEncoder().encode(piece)) ^ userpasswordHash).toString(16);
          } else {
            hashedPiece = this.h32(piece);
          }
          leafid = "h:" + hashedPiece;
          do {
            let nleafid = leafid;
            try {
              nleafid = `${leafid}${hashQ}`;
              const pieceData = yield this.localDatabase.get(nleafid);
              if (pieceData.type == "leaf" && pieceData.data == piece) {
                leafid = nleafid;
                needMake = false;
                tryNextHash = false;
                this.hashCaches.set(piece, leafid);
              } else if (pieceData.type == "leaf") {
                Logger("hash:collision!!");
                hashQ++;
                tryNextHash = true;
              } else {
                leafid = nleafid;
                tryNextHash = false;
              }
            } catch (ex) {
              if (ex.status && ex.status == 404) {
                leafid = nleafid;
                needMake = true;
                tryNextHash = false;
              } else {
                needMake = false;
                tryNextHash = false;
                throw ex;
              }
            }
          } while (tryNextHash);
          if (needMake) {
            const savePiece = piece;
            const d = {
              _id: leafid,
              data: savePiece,
              type: "leaf"
            };
            newLeafs.push(d);
            this.hashCaches.set(piece, leafid);
            made++;
          } else {
            skiped++;
          }
        }
        savenNotes.push(leafid);
      }
      let saved = true;
      if (newLeafs.length > 0) {
        try {
          const result = yield this.localDatabase.bulkDocs(newLeafs);
          for (const item of result) {
            if (!item.ok) {
              if (item.status && item.status == 409) {
              } else {
                Logger(`Save failed:id:${item.id} rev:${item.rev}`, LOG_LEVEL.NOTICE);
                Logger(item);
                saved = false;
              }
            }
          }
          if (saved) {
            Logger(`Chunk saved:${newLeafs.length} chunks`);
          }
        } catch (ex) {
          Logger("Chunk save failed:", LOG_LEVEL.NOTICE);
          Logger(ex, LOG_LEVEL.NOTICE);
          saved = false;
        }
      }
      if (saved) {
        Logger(`note content saven, pieces:${processed} new:${made}, skip:${skiped}, cache:${cacheUsed}`);
        const newDoc = {
          NewNote: true,
          children: savenNotes,
          _id: note._id,
          ctime: note.ctime,
          mtime: note.mtime,
          size: note.size,
          type: plainSplit ? "plain" : "newnote"
        };
        yield runWithLock("file:" + newDoc._id, false, () => __async(this, null, function* () {
          try {
            const old = yield this.localDatabase.get(newDoc._id);
            if (!old.type || old.type == "notes" || old.type == "newnote" || old.type == "plain") {
              newDoc._rev = old._rev;
            }
          } catch (ex) {
            if (ex.status && ex.status == 404) {
            } else {
              throw ex;
            }
          }
          const r2 = yield this.localDatabase.put(newDoc, { force: true });
          if (typeof this.corruptedEntries[note._id] != "undefined") {
            delete this.corruptedEntries[note._id];
          }
          if (this.settings.checkIntegrityOnSave) {
            if (!this.sanCheck(yield this.localDatabase.get(r2.id))) {
              Logger("note save failed!", LOG_LEVEL.NOTICE);
            } else {
              Logger(`note has been surely saved:${newDoc._id}:${r2.rev}`);
            }
          } else {
            Logger(`note saved:${newDoc._id}:${r2.rev}`);
          }
        }));
      } else {
        Logger(`note coud not saved:${note._id}`);
      }
    });
  }
  migrate(from, to) {
    return __async(this, null, function* () {
      Logger(`Database updated from ${from} to ${to}`, LOG_LEVEL.NOTICE);
      return true;
    });
  }
  replicateAllToServer(setting, showingNotice) {
    return new Promise((res, rej) => __async(this, null, function* () {
      yield this.waitForGCComplete();
      this.openOneshotReplication(setting, showingNotice, (e3) => __async(this, null, function* () {
      }), false, (e3) => {
        if (e3 === true)
          res(e3);
        rej(e3);
      }, true, false);
    }));
  }
  checkReplicationConnectivity(setting, keepAlive, skipCheck, showResult) {
    return __async(this, null, function* () {
      if (!this.isReady) {
        Logger("Database is not ready.");
        return false;
      }
      yield this.waitForGCComplete();
      if (setting.versionUpFlash != "") {
        NewNotice("Open settings and check message, please.");
        return false;
      }
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      if (this.syncHandler != null) {
        Logger("Another replication running.");
        return false;
      }
      const dbret = yield connectRemoteCouchDBWithSetting(setting, this.isMobile);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}: ${dbret}`, showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
        return false;
      }
      if (!skipCheck) {
        if (!(yield checkRemoteVersion(dbret.db, this.migrate.bind(this), VER))) {
          Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL.NOTICE);
          return false;
        }
        const defMilestonePoint = {
          _id: MILSTONE_DOCID,
          type: "milestoneinfo",
          created: new Date() / 1,
          locked: false,
          accepted_nodes: [this.nodeid]
        };
        const remoteMilestone = yield resolveWithIgnoreKnownError(dbret.db.get(MILSTONE_DOCID), defMilestonePoint);
        this.remoteLocked = remoteMilestone.locked;
        this.remoteLockedAndDeviceNotAccepted = remoteMilestone.locked && remoteMilestone.accepted_nodes.indexOf(this.nodeid) == -1;
        if (remoteMilestone.locked && remoteMilestone.accepted_nodes.indexOf(this.nodeid) == -1) {
          Logger("Remote database marked as 'Auto Sync Locked'. And this devide does not marked as resolved device. see settings dialog.", LOG_LEVEL.NOTICE);
          return false;
        }
        if (typeof remoteMilestone._rev == "undefined") {
          yield dbret.db.put(remoteMilestone);
        }
      }
      const syncOptionBase = {
        batches_limit: setting.batches_limit,
        batch_size: setting.batch_size
      };
      const syncOption = keepAlive ? __spreadValues({ live: true, retry: true, heartbeat: 3e4 }, syncOptionBase) : __spreadValues({}, syncOptionBase);
      return { db: dbret.db, info: dbret.info, syncOptionBase, syncOption };
    });
  }
  openReplication(setting, keepAlive, showResult, callback) {
    if (keepAlive) {
      this.openContinuousReplication(setting, showResult, callback, false);
    } else {
      this.openOneshotReplication(setting, showResult, callback, false, null, false, false);
    }
  }
  replicationActivated(notice) {
    this.syncStatus = "CONNECTED";
    this.updateInfo();
    Logger("Replication activated");
    if (notice != null)
      notice.setMessage(`Activated..`);
  }
  replicationChangeDetected(e3, notice, docSentOnStart, docArrivedOnStart, callback) {
    return __async(this, null, function* () {
      try {
        if (e3.direction == "pull") {
          yield callback(e3.change.docs);
          Logger(`replicated ${e3.change.docs_read} doc(s)`);
          this.docArrived += e3.change.docs.length;
        } else {
          this.docSent += e3.change.docs.length;
        }
        if (notice != null) {
          notice.setMessage(`\u2191${this.docSent - docSentOnStart} \u2193${this.docArrived - docArrivedOnStart}`);
        }
        this.updateInfo();
      } catch (ex) {
        Logger("Replication callback error", LOG_LEVEL.NOTICE);
        Logger(ex, LOG_LEVEL.NOTICE);
      }
    });
  }
  replicationCompleted(notice, showResult) {
    this.syncStatus = "COMPLETED";
    this.updateInfo();
    Logger("Replication completed", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
    if (notice != null)
      notice.hide();
    this.syncHandler = this.cancelHandler(this.syncHandler);
  }
  replicationDeniend(notice, e3) {
    this.syncStatus = "ERRORED";
    this.updateInfo();
    this.syncHandler = this.cancelHandler(this.syncHandler);
    if (notice != null)
      notice.hide();
    Logger("Replication denied", LOG_LEVEL.NOTICE);
    Logger(e3);
  }
  replicationErrored(notice, e3) {
    this.syncStatus = "ERRORED";
    this.syncHandler = this.cancelHandler(this.syncHandler);
    this.updateInfo();
  }
  replicationPaused(notice) {
    this.syncStatus = "PAUSED";
    this.updateInfo();
    if (notice != null)
      notice.hide();
    Logger("replication paused", LOG_LEVEL.VERBOSE);
  }
  openOneshotReplication(setting, showResult, callback, retrying, callbackDone, pushOnly, pullOnly) {
    return __async(this, null, function* () {
      if (this.syncHandler != null) {
        Logger("Replication is already in progress.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
        return;
      }
      Logger("Oneshot Sync begin...");
      let thisCallback = callbackDone;
      const ret = yield this.checkReplicationConnectivity(setting, true, retrying, showResult);
      let notice = null;
      if (ret === false) {
        Logger("Could not connect to server.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
        return;
      }
      if (showResult) {
        notice = NewNotice("Looking for the point last synchronized point.", 0);
      }
      const { db, syncOptionBase } = ret;
      this.syncStatus = "STARTED";
      this.updateInfo();
      const docArrivedOnStart = this.docArrived;
      const docSentOnStart = this.docSent;
      if (!retrying) {
        this.originalSetting = setting;
      }
      this.syncHandler = this.cancelHandler(this.syncHandler);
      if (!pushOnly && !pullOnly) {
        this.syncHandler = this.localDatabase.sync(db, __spreadValues({ checkpoint: "target" }, syncOptionBase));
        this.syncHandler.on("change", (e3) => __async(this, null, function* () {
          yield this.replicationChangeDetected(e3, notice, docSentOnStart, docArrivedOnStart, callback);
          if (retrying) {
            if (this.docSent - docSentOnStart + (this.docArrived - docArrivedOnStart) > this.originalSetting.batch_size * 2) {
              Logger("Back into original settings once.");
              if (notice != null)
                notice.hide();
              this.syncHandler = this.cancelHandler(this.syncHandler);
              this.openOneshotReplication(this.originalSetting, showResult, callback, false, callbackDone, pushOnly, pullOnly);
            }
          }
        })).on("complete", (e3) => {
          this.replicationCompleted(notice, showResult);
          if (thisCallback != null) {
            thisCallback(true);
          }
        });
      } else if (pullOnly) {
        this.syncHandler = this.localDatabase.replicate.to(db, __spreadValues({ checkpoint: "target" }, syncOptionBase));
        this.syncHandler.on("change", (e3) => __async(this, null, function* () {
          yield this.replicationChangeDetected({ direction: "pull", change: e3 }, notice, docSentOnStart, docArrivedOnStart, callback);
          if (retrying) {
            if (this.docSent - docSentOnStart + (this.docArrived - docArrivedOnStart) > this.originalSetting.batch_size * 2) {
              Logger("Back into original settings once.");
              if (notice != null)
                notice.hide();
              this.syncHandler = this.cancelHandler(this.syncHandler);
              this.openOneshotReplication(this.originalSetting, showResult, callback, false, callbackDone, pushOnly, pullOnly);
            }
          }
        })).on("complete", (e3) => {
          this.replicationCompleted(notice, showResult);
          if (thisCallback != null) {
            thisCallback(true);
          }
        });
      } else if (pushOnly) {
        this.syncHandler = this.localDatabase.replicate.to(db, __spreadValues({ checkpoint: "target" }, syncOptionBase));
        this.syncHandler.on("complete", (e3) => {
          this.replicationCompleted(notice, showResult);
          if (thisCallback != null) {
            thisCallback(true);
          }
        });
      }
      this.syncHandler.on("active", () => this.replicationActivated(notice)).on("denied", (e3) => {
        this.replicationDeniend(notice, e3);
        if (thisCallback != null) {
          thisCallback(e3);
        }
      }).on("error", (e3) => {
        this.replicationErrored(notice, e3);
        Logger("Replication stopped.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
        if (notice != null)
          notice.hide();
        if (getLastPostFailedBySize()) {
          const xsetting = JSON.parse(JSON.stringify(setting));
          xsetting.batch_size = Math.ceil(xsetting.batch_size / 2) + 2;
          xsetting.batches_limit = Math.ceil(xsetting.batches_limit / 2) + 2;
          if (xsetting.batch_size <= 5 && xsetting.batches_limit <= 5) {
            Logger("We can't replicate more lower value.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
          } else {
            Logger(`Retry with lower batch size:${xsetting.batch_size}/${xsetting.batches_limit}`, showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
            thisCallback = null;
            this.openOneshotReplication(xsetting, showResult, callback, true, callbackDone, pushOnly, pullOnly);
          }
        } else {
          Logger("Replication error", LOG_LEVEL.NOTICE);
          Logger(e3);
        }
        if (thisCallback != null) {
          thisCallback(e3);
        }
      }).on("paused", (e3) => this.replicationPaused(notice));
    });
  }
  openContinuousReplication(setting, showResult, callback, retrying) {
    if (this.syncHandler != null) {
      Logger("Replication is already in progress.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
      return;
    }
    Logger("Before LiveSync, start OneShot once...");
    this.openOneshotReplication(setting, showResult, callback, false, () => __async(this, null, function* () {
      Logger("LiveSync begin...");
      const ret = yield this.checkReplicationConnectivity(setting, true, true, showResult);
      let notice = null;
      if (ret === false) {
        Logger("Could not connect to server.", showResult ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO);
        return;
      }
      if (showResult) {
        notice = NewNotice("Looking for the point last synchronized point.", 0);
      }
      const { db, syncOption } = ret;
      this.syncStatus = "STARTED";
      this.updateInfo();
      const docArrivedOnStart = this.docArrived;
      const docSentOnStart = this.docSent;
      if (!retrying) {
        this.originalSetting = setting;
      }
      this.syncHandler = this.cancelHandler(this.syncHandler);
      this.syncHandler = this.localDatabase.sync(db, __spreadProps(__spreadValues({}, syncOption), {
        pull: {
          checkpoint: "target"
        },
        push: {
          checkpoint: "source"
        }
      }));
      this.syncHandler.on("active", () => this.replicationActivated(notice)).on("change", (e3) => __async(this, null, function* () {
        yield this.replicationChangeDetected(e3, notice, docSentOnStart, docArrivedOnStart, callback);
        if (retrying) {
          if (this.docSent - docSentOnStart + (this.docArrived - docArrivedOnStart) > this.originalSetting.batch_size * 2) {
            Logger("Back into original settings once.");
            if (notice != null)
              notice.hide();
            this.syncHandler = this.cancelHandler(this.syncHandler);
            this.openContinuousReplication(this.originalSetting, showResult, callback, false);
          }
        }
      })).on("complete", (e3) => this.replicationCompleted(notice, showResult)).on("denied", (e3) => this.replicationDeniend(notice, e3)).on("error", (e3) => {
        this.replicationErrored(notice, e3);
        Logger("Replication stopped.", LOG_LEVEL.NOTICE);
      }).on("paused", (e3) => this.replicationPaused(notice));
    }), false, true);
  }
  closeReplication() {
    this.syncStatus = "CLOSED";
    this.updateInfo();
    this.syncHandler = this.cancelHandler(this.syncHandler);
    Logger("Replication closed");
  }
  resetLocalOldDatabase() {
    return __async(this, null, function* () {
      const oldDB = yield this.isOldDatabaseExists();
      if (oldDB) {
        oldDB.destroy();
        NewNotice("Deleted! Please re-launch obsidian.", LOG_LEVEL.NOTICE);
      } else {
        NewNotice("Old database is not exist.", LOG_LEVEL.NOTICE);
      }
    });
  }
  resetDatabase() {
    return __async(this, null, function* () {
      yield this.waitForGCComplete();
      this.changeHandler = this.cancelHandler(this.changeHandler);
      yield this.closeReplication();
      Logger("Database closed for reset Database.");
      this.isReady = false;
      yield this.localDatabase.destroy();
      yield this.kvDB.destroy();
      this.localDatabase = null;
      yield this.initializeDatabase();
      Logger("Local Database Reset", LOG_LEVEL.NOTICE);
    });
  }
  tryResetRemoteDatabase(setting) {
    return __async(this, null, function* () {
      yield this.closeReplication();
      const con = yield connectRemoteCouchDBWithSetting(setting, this.isMobile);
      if (typeof con == "string")
        return;
      try {
        yield con.db.destroy();
        Logger("Remote Database Destroyed", LOG_LEVEL.NOTICE);
        yield this.tryCreateRemoteDatabase(setting);
      } catch (ex) {
        Logger("Something happened on Remote Database Destory:", LOG_LEVEL.NOTICE);
        Logger(ex, LOG_LEVEL.NOTICE);
      }
    });
  }
  tryCreateRemoteDatabase(setting) {
    return __async(this, null, function* () {
      yield this.closeReplication();
      const con2 = yield connectRemoteCouchDBWithSetting(setting, this.isMobile);
      if (typeof con2 === "string")
        return;
      Logger("Remote Database Created or Connected", LOG_LEVEL.NOTICE);
    });
  }
  markRemoteLocked(setting, locked) {
    return __async(this, null, function* () {
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const dbret = yield connectRemoteCouchDBWithSetting(setting, this.isMobile);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}:${dbret}`, LOG_LEVEL.NOTICE);
        return;
      }
      if (!(yield checkRemoteVersion(dbret.db, this.migrate.bind(this), VER))) {
        Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL.NOTICE);
        return;
      }
      const defInitPoint = {
        _id: MILSTONE_DOCID,
        type: "milestoneinfo",
        created: new Date() / 1,
        locked,
        accepted_nodes: [this.nodeid]
      };
      const remoteMilestone = yield resolveWithIgnoreKnownError(dbret.db.get(MILSTONE_DOCID), defInitPoint);
      remoteMilestone.accepted_nodes = [this.nodeid];
      remoteMilestone.locked = locked;
      if (locked) {
        Logger("Lock remote database to prevent data corruption", LOG_LEVEL.NOTICE);
      } else {
        Logger("Unlock remote database to prevent data corruption", LOG_LEVEL.NOTICE);
      }
      yield dbret.db.put(remoteMilestone);
    });
  }
  markRemoteResolved(setting) {
    return __async(this, null, function* () {
      const uri = setting.couchDB_URI + (setting.couchDB_DBNAME == "" ? "" : "/" + setting.couchDB_DBNAME);
      const dbret = yield connectRemoteCouchDBWithSetting(setting, this.isMobile);
      if (typeof dbret === "string") {
        Logger(`could not connect to ${uri}:${dbret}`, LOG_LEVEL.NOTICE);
        return;
      }
      if (!(yield checkRemoteVersion(dbret.db, this.migrate.bind(this), VER))) {
        Logger("Remote database is newer or corrupted, make sure to latest version of self-hosted-livesync installed", LOG_LEVEL.NOTICE);
        return;
      }
      const defInitPoint = {
        _id: MILSTONE_DOCID,
        type: "milestoneinfo",
        created: new Date() / 1,
        locked: false,
        accepted_nodes: [this.nodeid]
      };
      const remoteMilestone = yield resolveWithIgnoreKnownError(dbret.db.get(MILSTONE_DOCID), defInitPoint);
      remoteMilestone.accepted_nodes = Array.from(new Set([...remoteMilestone.accepted_nodes, this.nodeid]));
      Logger("Mark this device as 'resolved'.", LOG_LEVEL.NOTICE);
      yield dbret.db.put(remoteMilestone);
    });
  }
  waitForGCComplete() {
    return __async(this, null, function* () {
      while (this.gcRunning) {
        Logger("Waiting for Garbage Collection completed.");
        yield delay(1e3);
      }
    });
  }
  sanCheck(entry) {
    return __async(this, null, function* () {
      if (entry.type == "plain" || entry.type == "newnote") {
        const children2 = entry.children;
        Logger(`sancheck:checking:${entry._id} : ${children2.length}`, LOG_LEVEL.VERBOSE);
        try {
          const dc = yield this.localDatabase.allDocs({ keys: [...children2] });
          if (dc.rows.some((e3) => "error" in e3)) {
            this.corruptedEntries[entry._id] = entry;
            Logger(`sancheck:corrupted:${entry._id} : ${children2.length}`, LOG_LEVEL.VERBOSE);
            return false;
          }
          return true;
        } catch (ex) {
          Logger(ex);
        }
      }
      return false;
    });
  }
  garbageCollect() {
    return __async(this, null, function* () {
      yield runWithLock("replicate", true, () => __async(this, null, function* () {
        if (this.gcRunning)
          return;
        this.gcRunning = true;
        let idbGC = null;
        const storeIDB = "gc";
        const idbname = "idb-" + this.dbname + "-idb-gcx";
        try {
          const procAllDocs = (getLeaf, startkey, endkey, callback) => __async(this, null, function* () {
            let c = 0;
            let readCount = 0;
            do {
              const result = yield this.localDatabase.allDocs({ include_docs: false, skip: c, limit: 2e3, conflicts: !getLeaf, startkey, endkey });
              readCount = result.rows.length;
              if (readCount > 0) {
                yield callback(result.rows.map((e3) => e3.id));
              }
              c += readCount;
            } while (readCount != 0);
          });
          yield deleteDB(idbname);
          idbGC = yield openDB(idbname, 1, {
            upgrade(db) {
              db.createObjectStore(storeIDB, { keyPath: "id" });
            }
          });
          yield procAllDocs(true, "h:", "h_", (docs) => __async(this, null, function* () {
            Logger(`Chunks marked - :${docs.length}`);
            const tx = idbGC.transaction(storeIDB, "readwrite");
            const store = tx.objectStore(storeIDB);
            for (const docId of docs) {
              yield store.put({ id: docId });
            }
            yield tx.done;
          }));
          Logger("All chunks are marked once");
          const unmarkUsedByHashId = (doc) => __async(this, null, function* () {
            if ("children" in doc) {
              const tx = idbGC.transaction(storeIDB, "readwrite");
              const store = tx.objectStore(storeIDB);
              for (const hashId of doc.children) {
                yield store.delete(hashId);
              }
              yield tx.done;
            }
          });
          Logger("Processing existen docs");
          let procDocs = 0;
          yield procAllDocs(false, null, null, (doc) => __async(this, null, function* () {
            const docIds = doc.filter((e3) => !e3.startsWith("h:") && !e3.startsWith("ps:"));
            for (const docId of docIds) {
              procDocs++;
              if (procDocs % 25 == 0)
                Logger(`${procDocs} Processed`);
              const docT = yield this.localDatabase.get(docId, { revs_info: true });
              if (docT._deleted)
                continue;
              unmarkUsedByHashId(docT);
              const revs = docT._revs_info;
              for (const rev of revs) {
                if (rev.status != "available")
                  continue;
                const docRev = yield this.localDatabase.get(docId, { rev: rev.rev });
                unmarkUsedByHashId(docRev);
                if (docRev._conflicts) {
                  for (const cid of docRev._conflicts) {
                    const docConflict = yield this.localDatabase.get(docId, { rev: cid });
                    unmarkUsedByHashId(docConflict);
                  }
                }
              }
              if (docT._conflicts) {
                for (const cid of docT._conflicts) {
                  const docConflict = yield this.localDatabase.get(docId, { rev: cid });
                  unmarkUsedByHashId(docConflict);
                }
              }
            }
          }));
          Logger("Delete non-used chunks");
          let dataLeft = false;
          let chunkKeys = [];
          let totalDelCount = 0;
          do {
            const tx = idbGC.transaction(storeIDB, "readonly");
            const store = tx.objectStore(storeIDB);
            let cursor = yield store.openCursor();
            if (cursor == null)
              break;
            const maxconcurrentDocs = 10;
            let delChunkCount = 0;
            do {
              if (cursor) {
                chunkKeys.push(cursor.key);
                delChunkCount++;
                dataLeft = true;
              } else {
                dataLeft = false;
              }
              cursor = yield cursor.continue();
            } while (cursor && dataLeft && delChunkCount < maxconcurrentDocs);
            totalDelCount += delChunkCount;
            const delDocResult = yield this.localDatabase.allDocs({ keys: chunkKeys, include_docs: true });
            const delDocs = delDocResult.rows.map((e3) => __spreadProps(__spreadValues({}, e3.doc), { _deleted: true }));
            yield this.localDatabase.bulkDocs(delDocs);
            Logger(`deleted from pouchdb:${delDocs.length}`);
            const tx2 = idbGC.transaction(storeIDB, "readwrite");
            const store2 = tx2.objectStore(storeIDB);
            for (const doc of chunkKeys) {
              yield store2.delete(doc);
            }
            Logger(`deleted from workspace:${chunkKeys.length}`);
            yield tx2.done;
            chunkKeys = [];
          } while (dataLeft);
          Logger(`Deleted ${totalDelCount} chunks`);
          Logger("Teardown the database");
          if (idbGC != null) {
            idbGC.close();
            idbGC = null;
          }
          yield deleteDB(idbname);
          this.gcRunning = false;
          Logger("Done");
        } catch (ex) {
          Logger("Error on garbage collection");
          Logger(ex);
        } finally {
          if (idbGC != null) {
            idbGC.close();
          }
          yield deleteDB(idbname);
          this.gcRunning = false;
        }
      }));
    });
  }
};

// src/LogDisplayModal.ts
var import_obsidian3 = __toModule(require("obsidian"));
var LogDisplayModal = class extends import_obsidian3.Modal {
  constructor(app2, plugin) {
    super(app2);
    this.plugin = plugin;
  }
  updateLog() {
    let msg = "";
    for (const v of this.plugin.logMessage) {
      msg += escapeStringToHTML(v) + "<br>";
    }
    this.logEl.innerHTML = msg;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Sync Status" });
    const div = contentEl.createDiv("");
    div.addClass("op-scrollable");
    div.addClass("op-pre");
    this.logEl = div;
    this.updateLog = this.updateLog.bind(this);
    this.plugin.addLogHook = this.updateLog;
    this.updateLog();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.plugin.addLogHook = null;
  }
};

// src/ConflictResolveModal.ts
var import_obsidian4 = __toModule(require("obsidian"));
var import_diff_match_patch = __toModule(require_diff_match_patch());
var ConflictResolveModal = class extends import_obsidian4.Modal {
  constructor(app2, diff, callback) {
    super(app2);
    this.result = diff;
    this.callback = callback;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "This document has conflicted changes." });
    const div = contentEl.createDiv("");
    div.addClass("op-scrollable");
    let diff = "";
    for (const v of this.result.diff) {
      const x1 = v[0];
      const x2 = v[1];
      if (x1 == import_diff_match_patch.DIFF_DELETE) {
        diff += "<span class='deleted'>" + escapeStringToHTML(x2) + "</span>";
      } else if (x1 == import_diff_match_patch.DIFF_EQUAL) {
        diff += "<span class='normal'>" + escapeStringToHTML(x2) + "</span>";
      } else if (x1 == import_diff_match_patch.DIFF_INSERT) {
        diff += "<span class='added'>" + escapeStringToHTML(x2) + "</span>";
      }
    }
    diff = diff.replace(/\n/g, "<br>");
    div.innerHTML = diff;
    const div2 = contentEl.createDiv("");
    const date1 = new Date(this.result.left.mtime).toLocaleString();
    const date2 = new Date(this.result.right.mtime).toLocaleString();
    div2.innerHTML = `
<span class='deleted'>A:${date1}</span><br /><span class='added'>B:${date2}</span><br> 
        `;
    contentEl.createEl("button", { text: "Keep A" }, (e3) => {
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield this.callback(this.result.right.rev);
        this.callback = null;
        this.close();
      }));
    });
    contentEl.createEl("button", { text: "Keep B" }, (e3) => {
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield this.callback(this.result.left.rev);
        this.callback = null;
        this.close();
      }));
    });
    contentEl.createEl("button", { text: "Concat both" }, (e3) => {
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield this.callback("");
        this.callback = null;
        this.close();
      }));
    });
    contentEl.createEl("button", { text: "Not now" }, (e3) => {
      e3.addEventListener("click", () => {
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.callback != null) {
      this.callback(null);
    }
  }
};

// src/ObsidianLiveSyncSettingTab.ts
var import_obsidian5 = __toModule(require("obsidian"));
var ObsidianLiveSyncSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  testConnection() {
    return __async(this, null, function* () {
      const db = yield connectRemoteCouchDBWithSetting(this.plugin.settings, this.plugin.localDatabase.isMobile);
      if (typeof db === "string") {
        this.plugin.addLog(`could not connect to ${this.plugin.settings.couchDB_URI} : ${this.plugin.settings.couchDB_DBNAME} 
(${db})`, LOG_LEVEL.NOTICE);
        return;
      }
      this.plugin.addLog(`Connected to ${db.info.db_name}`, LOG_LEVEL.NOTICE);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Self-hosted LiveSync." });
    const w = containerEl.createDiv("");
    const screenElements = {};
    const addScreenElement = (key, element2) => {
      if (!(key in screenElements)) {
        screenElements[key] = [];
      }
      screenElements[key].push(element2);
    };
    w.addClass("sls-setting-menu");
    w.innerHTML = `
<label class='sls-setting-label selected'><input type='radio' name='disp' value='0' class='sls-setting-tab' checked><div class='sls-setting-menu-btn'>\u{1F6F0}\uFE0F</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='10' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F4E6}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='20' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u2699\uFE0F</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='30' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F501}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='40' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F527}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='50' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F9F0}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='60' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F50C}</div></label>
<label class='sls-setting-label'><input type='radio' name='disp' value='70' class='sls-setting-tab' ><div class='sls-setting-menu-btn'>\u{1F691}</div></label>
        `;
    const menutabs = w.querySelectorAll(".sls-setting-label");
    const changeDisplay = (screen) => {
      for (const k in screenElements) {
        if (k == screen) {
          screenElements[k].forEach((element2) => element2.removeClass("setting-collapsed"));
        } else {
          screenElements[k].forEach((element2) => element2.addClass("setting-collapsed"));
        }
      }
    };
    menutabs.forEach((element2) => {
      const e3 = element2.querySelector(".sls-setting-tab");
      if (!e3)
        return;
      e3.addEventListener("change", (event) => {
        menutabs.forEach((element3) => element3.removeClass("selected"));
        changeDisplay(event.currentTarget.value);
        element2.addClass("selected");
      });
    });
    const containerRemoteDatabaseEl = containerEl.createDiv();
    containerRemoteDatabaseEl.createEl("h3", { text: "Remote Database configuration" });
    const syncWarn = containerRemoteDatabaseEl.createEl("div", { text: `These settings are kept locked while automatic synchronization options are enabled. Disable these options in the "Sync Settings" tab to unlock.` });
    syncWarn.addClass("op-warn-info");
    syncWarn.addClass("sls-hidden");
    const isAnySyncEnabled = () => {
      if (this.plugin.settings.liveSync)
        return true;
      if (this.plugin.settings.periodicReplication)
        return true;
      if (this.plugin.settings.syncOnFileOpen)
        return true;
      if (this.plugin.settings.syncOnSave)
        return true;
      if (this.plugin.settings.syncOnStart)
        return true;
      if (this.plugin.localDatabase.syncStatus == "CONNECTED")
        return true;
      if (this.plugin.localDatabase.syncStatus == "PAUSED")
        return true;
      return false;
    };
    const applyDisplayEnabled = () => {
      if (isAnySyncEnabled()) {
        dbsettings.forEach((e3) => {
          e3.setDisabled(true).setTooltip("When any sync is enabled, It cound't be changed.");
        });
        syncWarn.removeClass("sls-hidden");
      } else {
        dbsettings.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
        syncWarn.addClass("sls-hidden");
      }
      if (this.plugin.settings.liveSync) {
        syncNonLive.forEach((e3) => {
          e3.setDisabled(true).setTooltip("");
        });
        syncLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
      } else if (this.plugin.settings.syncOnFileOpen || this.plugin.settings.syncOnSave || this.plugin.settings.syncOnStart || this.plugin.settings.periodicReplication) {
        syncNonLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
        syncLive.forEach((e3) => {
          e3.setDisabled(true).setTooltip("");
        });
      } else {
        syncNonLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
        syncLive.forEach((e3) => {
          e3.setDisabled(false).setTooltip("");
        });
      }
    };
    const dbsettings = [];
    dbsettings.push(new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("URI").addText((text2) => text2.setPlaceholder("https://........").setValue(this.plugin.settings.couchDB_URI).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.couchDB_URI = value;
      yield this.plugin.saveSettings();
    }))), new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Username").setDesc("username").addText((text2) => text2.setPlaceholder("").setValue(this.plugin.settings.couchDB_USER).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.couchDB_USER = value;
      yield this.plugin.saveSettings();
    }))), new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Password").setDesc("password").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.couchDB_PASSWORD).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.couchDB_PASSWORD = value;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "password");
    }), new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Database name").addText((text2) => text2.setPlaceholder("").setValue(this.plugin.settings.couchDB_DBNAME).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.couchDB_DBNAME = value;
      yield this.plugin.saveSettings();
    }))));
    new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("End to End Encryption").setDesc("Encrypting contents on the database.").addToggle((toggle) => toggle.setValue(this.plugin.settings.workingEncrypt).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.workingEncrypt = value;
      phasspharase.setDisabled(!value);
      yield this.plugin.saveSettings();
    })));
    const phasspharase = new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Passphrase").setDesc("Encrypting passphrase").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.workingPassphrase).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.workingPassphrase = value;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "password");
    });
    phasspharase.setDisabled(!this.plugin.settings.workingEncrypt);
    containerRemoteDatabaseEl.createEl("div", {
      text: "If you change the passphrase, rebuilding the remote database is required. Please press 'Apply and send'. Or, If you have configured it to connect to an existing database, click 'Just apply'."
    });
    const checkWorkingPassphrase = () => __async(this, null, function* () {
      const settingForCheck = __spreadProps(__spreadValues({}, this.plugin.settings), {
        encrypt: this.plugin.settings.workingEncrypt,
        passphrase: this.plugin.settings.workingPassphrase
      });
      console.dir(settingForCheck);
      const db = yield connectRemoteCouchDBWithSetting(settingForCheck, this.plugin.localDatabase.isMobile);
      if (typeof db === "string") {
        Logger("Could not connect to the database.", LOG_LEVEL.NOTICE);
        return false;
      } else {
        if (yield checkSyncInfo(db.db)) {
          return true;
        } else {
          Logger("Failed to read remote database", LOG_LEVEL.NOTICE);
          return false;
        }
      }
    });
    const applyEncryption = (sendToServer) => __async(this, null, function* () {
      if (this.plugin.settings.workingEncrypt && this.plugin.settings.workingPassphrase == "") {
        Logger("If you enable encryption, you have to set the passphrase", LOG_LEVEL.NOTICE);
        return;
      }
      if (this.plugin.settings.workingEncrypt && !(yield testCrypt())) {
        Logger("WARNING! Your device would not support encryption.", LOG_LEVEL.NOTICE);
        return;
      }
      if (!(yield checkWorkingPassphrase())) {
        return;
      }
      if (!this.plugin.settings.workingEncrypt) {
        this.plugin.settings.workingPassphrase = "";
      }
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      this.plugin.settings.syncOnSave = false;
      this.plugin.settings.syncOnStart = false;
      this.plugin.settings.syncOnFileOpen = false;
      this.plugin.settings.encrypt = this.plugin.settings.workingEncrypt;
      this.plugin.settings.passphrase = this.plugin.settings.workingPassphrase;
      yield this.plugin.saveSettings();
      if (sendToServer) {
        yield this.plugin.initializeDatabase(true);
        yield this.plugin.markRemoteLocked();
        yield this.plugin.tryResetRemoteDatabase();
        yield this.plugin.markRemoteLocked();
        yield this.plugin.replicateAllToServer(true);
      } else {
        yield this.plugin.markRemoteResolved();
        yield this.plugin.replicate(true);
      }
    });
    new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Apply").setDesc("apply encryption settinngs, and re-initialize remote database").addButton((button) => button.setButtonText("Apply and send").setWarning().setDisabled(false).setClass("sls-btn-left").onClick(() => __async(this, null, function* () {
      yield applyEncryption(true);
    }))).addButton((button) => button.setButtonText("Just apply").setWarning().setDisabled(false).setClass("sls-btn-right").onClick(() => __async(this, null, function* () {
      yield applyEncryption(false);
    })));
    new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Test Database Connection").setDesc("Open database connection. If the remote database is not found and you have the privilege to create a database, the database will be created.").addButton((button) => button.setButtonText("Test").setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.testConnection();
    })));
    new import_obsidian5.Setting(containerRemoteDatabaseEl).setName("Check database configuration").addButton((button) => button.setButtonText("Check").setDisabled(false).onClick(() => __async(this, null, function* () {
      const checkConfig = () => __async(this, null, function* () {
        var _a, _b, _c, _d, _e, _f, _g;
        try {
          const requestToCouchDB = (baseUri, username, password, origin2, key, body) => __async(this, null, function* () {
            const utf8str = String.fromCharCode.apply(null, new TextEncoder().encode(`${username}:${password}`));
            const encoded = window.btoa(utf8str);
            const authHeader = "Basic " + encoded;
            const transformedHeaders = { authorization: authHeader, origin: origin2 };
            const uri = `${baseUri}/_node/_local/_config${key ? "/" + key : ""}`;
            const requestParam = {
              url: uri,
              method: body ? "PUT" : "GET",
              headers: transformedHeaders,
              contentType: "application/json",
              body: body ? JSON.stringify(body) : void 0
            };
            return yield (0, import_obsidian5.requestUrl)(requestParam);
          });
          const r2 = yield requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, window.origin);
          Logger(JSON.stringify(r2.json, null, 2));
          const responseConfig = r2.json;
          const emptyDiv = createDiv();
          emptyDiv.innerHTML = "<span></span>";
          checkResultDiv.replaceChildren(...[emptyDiv]);
          const addResult = (msg, classes) => {
            const tmpDiv = createDiv();
            tmpDiv.addClass("ob-btn-config-fix");
            if (classes) {
              tmpDiv.addClasses(classes);
            }
            tmpDiv.innerHTML = `${msg}`;
            checkResultDiv.appendChild(tmpDiv);
          };
          const addConfigFixButton = (title, key, value) => {
            const tmpDiv = createDiv();
            tmpDiv.addClass("ob-btn-config-fix");
            tmpDiv.innerHTML = `<label>${title}</label><button>Fix</button>`;
            const x = checkResultDiv.appendChild(tmpDiv);
            x.querySelector("button").addEventListener("click", () => __async(this, null, function* () {
              console.dir({ key, value });
              const res = yield requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, void 0, key, value);
              console.dir(res);
              if (res.status == 200) {
                Logger(`${title} successfly updated`, LOG_LEVEL.NOTICE);
                checkResultDiv.removeChild(x);
                checkConfig();
              } else {
                Logger(`${title} failed`, LOG_LEVEL.NOTICE);
                Logger(res.text);
              }
            }));
          };
          addResult("---Notice---", ["ob-btn-config-head"]);
          addResult("If the server configuration is not persistent (e.g., running on docker), the values set from here will also be volatile. Once you are able to connect, please reflect the settings in the server's local.ini.", ["ob-btn-config-info"]);
          addResult("Your configuration is dumped to Log", ["ob-btn-config-info"]);
          addResult("--Config check--", ["ob-btn-config-head"]);
          if (!(this.plugin.settings.couchDB_USER in responseConfig.admins)) {
            addResult(`\u26A0 You do not have administrative privileges.`);
          } else {
            addResult("\u2714 You have administrative privileges.");
          }
          if (((_a = responseConfig == null ? void 0 : responseConfig.chttpd) == null ? void 0 : _a.require_valid_user) != "true") {
            addResult("\u2757 chttpd.require_valid_user looks like wrong.");
            addConfigFixButton("Set chttpd.require_valid_user = true", "chttpd/require_valid_user", "true");
          } else {
            addResult("\u2714 chttpd.require_valid_user is ok.");
          }
          if (((_b = responseConfig == null ? void 0 : responseConfig.chttpd_auth) == null ? void 0 : _b.require_valid_user) != "true") {
            addResult("\u2757 chttpd_auth.require_valid_user looks like wrong.");
            addConfigFixButton("Set chttpd_auth.require_valid_user = true", "chttpd_auth/require_valid_user", "true");
          } else {
            addResult("\u2714 chttpd_auth.require_valid_user is ok.");
          }
          if (!(responseConfig == null ? void 0 : responseConfig.httpd["WWW-Authenticate"])) {
            addResult("\u2757 httpd.WWW-Authenticate is missing");
            addConfigFixButton("Set httpd.WWW-Authenticate", "httpd/WWW-Authenticate", 'Basic realm="couchdb"');
          } else {
            addResult("\u2714 httpd.WWW-Authenticate is ok.");
          }
          if (((_c = responseConfig == null ? void 0 : responseConfig.httpd) == null ? void 0 : _c.enable_cors) != "true") {
            addResult("\u2757 httpd.enable_cors is wrong");
            addConfigFixButton("Set httpd.enable_cors", "httpd/enable_cors", "true");
          } else {
            addResult("\u2714 httpd.enable_cors is ok.");
          }
          if (((_d = responseConfig == null ? void 0 : responseConfig.cors) == null ? void 0 : _d.credentials) != "true") {
            addResult("\u2757 cors.credentials is wrong");
            addConfigFixButton("Set cors.credentials", "cors/credentials", "true");
          } else {
            addResult("\u2714 cors.credentials is ok.");
          }
          const ConfiguredOrigins = (((_f = (_e = responseConfig == null ? void 0 : responseConfig.cors) == null ? void 0 : _e.origins) != null ? _f : "") + "").split(",");
          if (((_g = responseConfig == null ? void 0 : responseConfig.cors) == null ? void 0 : _g.origins) == "*" || ConfiguredOrigins.indexOf("app://obsidian.md") !== -1 && ConfiguredOrigins.indexOf("capacitor://localhost") !== -1 && ConfiguredOrigins.indexOf("http://localhost") !== -1) {
            addResult("\u2714 cors.origins is ok.");
          } else {
            addResult("\u2757 cors.origins is wrong");
            addConfigFixButton("Set cors.origins", "cors/origins", "app://obsidian.md,capacitor://localhost,http://localhost");
          }
          addResult("--Connection check--", ["ob-btn-config-head"]);
          addResult(`Current origin:${window.location.origin}`);
          const origins = ["app://obsidian.md", "capacitor://localhost", "http://localhost"];
          for (const org of origins) {
            const rr = yield requestToCouchDB(this.plugin.settings.couchDB_URI, this.plugin.settings.couchDB_USER, this.plugin.settings.couchDB_PASSWORD, org);
            const responseHeaders = Object.entries(rr.headers).map((e3) => {
              e3[0] = (e3[0] + "").toLowerCase();
              return e3;
            }).reduce((obj, [key, val]) => {
              obj[key] = val;
              return obj;
            }, {});
            addResult(`Origin check:${org}`);
            if (responseHeaders["access-control-allow-credentials"] != "true") {
              addResult("\u2757 CORS is not allowing credential");
            } else {
              addResult("\u2714 CORS credential OK");
            }
            if (responseHeaders["access-control-allow-origin"] != org) {
              addResult(`\u2757 CORS Origin is unmatched:${origin}->${responseHeaders["access-control-allow-origin"]}`);
            } else {
              addResult("\u2714 CORS origin OK");
            }
          }
          addResult("--Done--", ["ob-btn-config-haed"]);
          addResult("If you have some trouble with Connection-check even though all Config-check has been passed, Please check your reverse proxy's configuration.", ["ob-btn-config-info"]);
        } catch (ex) {
          Logger(`Checking configration failed`);
          Logger(ex);
        }
      });
      yield checkConfig();
    })));
    const checkResultDiv = containerRemoteDatabaseEl.createEl("div", {
      text: ""
    });
    addScreenElement("0", containerRemoteDatabaseEl);
    const containerLocalDatabaseEl = containerEl.createDiv();
    containerLocalDatabaseEl.createEl("h3", { text: "Local Database configuration" });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Batch database update").setDesc("Delay all changes, save once before replication or opening another file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.batchSave).onChange((value) => __async(this, null, function* () {
      if (value && this.plugin.settings.liveSync) {
        Logger("LiveSync and Batch database update cannot be used at the same time.", LOG_LEVEL.NOTICE);
        toggle.setValue(false);
        return;
      }
      this.plugin.settings.batchSave = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Auto Garbage Collection delay").setDesc("(seconds), if you set zero, you have to run manually.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.gcDelay + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v > 5e3) {
          v = 0;
        }
        this.plugin.settings.gcDelay = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Manual Garbage Collect").addButton((button) => button.setButtonText("Collect now").setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.plugin.garbageCollect();
    })));
    containerLocalDatabaseEl.createEl("div", {
      text: (0, import_obsidian5.sanitizeHTMLToDom)(`Advanced settings<br>
                Configuration of how LiveSync makes chunks from the file.`)
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("Minimum chunk size").setDesc("(letters), minimum chunk size.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.minimumChunkSize + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10 || v > 1e3) {
          v = 10;
        }
        this.plugin.settings.minimumChunkSize = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    new import_obsidian5.Setting(containerLocalDatabaseEl).setName("LongLine Threshold").setDesc("(letters), If the line is longer than this, make the line to chunk").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.longLineThreshold + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10 || v > 1e3) {
          v = 10;
        }
        this.plugin.settings.longLineThreshold = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    addScreenElement("10", containerLocalDatabaseEl);
    const containerGeneralSettingsEl = containerEl.createDiv();
    containerGeneralSettingsEl.createEl("h3", { text: "General Settings" });
    new import_obsidian5.Setting(containerGeneralSettingsEl).setName("Do not show low-priority Log").setDesc("Reduce log infomations").addToggle((toggle) => toggle.setValue(this.plugin.settings.lessInformationInLog).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.lessInformationInLog = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerGeneralSettingsEl).setName("Verbose Log").setDesc("Show verbose log ").addToggle((toggle) => toggle.setValue(this.plugin.settings.showVerboseLog).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showVerboseLog = value;
      yield this.plugin.saveSettings();
    })));
    addScreenElement("20", containerGeneralSettingsEl);
    const containerSyncSettingEl = containerEl.createDiv();
    containerSyncSettingEl.createEl("h3", { text: "Sync setting" });
    if (this.plugin.settings.versionUpFlash != "") {
      const c = containerSyncSettingEl.createEl("div", { text: this.plugin.settings.versionUpFlash });
      c.createEl("button", { text: "I got it and updated." }, (e3) => {
        e3.addClass("mod-cta");
        e3.addEventListener("click", () => __async(this, null, function* () {
          this.plugin.settings.versionUpFlash = "";
          yield this.plugin.saveSettings();
          applyDisplayEnabled();
          c.remove();
        }));
      });
      c.addClass("op-warn");
    }
    const syncLive = [];
    const syncNonLive = [];
    syncLive.push(new import_obsidian5.Setting(containerSyncSettingEl).setName("LiveSync").setDesc("Sync realtime").addToggle((toggle) => toggle.setValue(this.plugin.settings.liveSync).onChange((value) => __async(this, null, function* () {
      if (value && this.plugin.settings.batchSave) {
        Logger("LiveSync and Batch database update cannot be used at the same time.", LOG_LEVEL.NOTICE);
        toggle.setValue(false);
        return;
      }
      this.plugin.settings.liveSync = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
      yield this.plugin.realizeSettingSyncMode();
    }))));
    syncNonLive.push(new import_obsidian5.Setting(containerSyncSettingEl).setName("Periodic Sync").setDesc("Sync periodically").addToggle((toggle) => toggle.setValue(this.plugin.settings.periodicReplication).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.periodicReplication = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))), new import_obsidian5.Setting(containerSyncSettingEl).setName("Periodic sync intreval").setDesc("Interval (sec)").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.periodicReplicationInterval + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v > 5e3) {
          v = 0;
        }
        this.plugin.settings.periodicReplicationInterval = v;
        yield this.plugin.saveSettings();
        applyDisplayEnabled();
      }));
      text2.inputEl.setAttribute("type", "number");
    }), new import_obsidian5.Setting(containerSyncSettingEl).setName("Sync on Save").setDesc("When you save file, sync automatically").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnSave).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.syncOnSave = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))), new import_obsidian5.Setting(containerSyncSettingEl).setName("Sync on File Open").setDesc("When you open file, sync automatically").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnFileOpen).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.syncOnFileOpen = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))), new import_obsidian5.Setting(containerSyncSettingEl).setName("Sync on Start").setDesc("Start synchronization on Obsidian started.").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnStart).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.syncOnStart = value;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
    }))));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Use Trash for deleted files").setDesc("Do not delete files that deleted in remote, just move to trash.").addToggle((toggle) => toggle.setValue(this.plugin.settings.trashInsteadDelete).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.trashInsteadDelete = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Do not delete empty folder").setDesc("Normally, folder is deleted When the folder became empty by replication. enable this, leave it as is").addToggle((toggle) => toggle.setValue(this.plugin.settings.doNotDeleteFolder).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.doNotDeleteFolder = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Use newer file if conflicted (beta)").setDesc("Resolve conflicts by newer files automatically.").addToggle((toggle) => toggle.setValue(this.plugin.settings.resolveConflictsByNewerFile).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.resolveConflictsByNewerFile = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Check conflict only on opening file.").setDesc("Do not check conflict while replication").addToggle((toggle) => toggle.setValue(this.plugin.settings.checkConflictOnlyOnOpen).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.checkConflictOnlyOnOpen = value;
      yield this.plugin.saveSettings();
    })));
    containerSyncSettingEl.createEl("div", {
      text: (0, import_obsidian5.sanitizeHTMLToDom)(`Advanced settings<br>
            If you reached the payload size limit when using IBM Cloudant, please set batch size and batch limit to a lower value.`)
    });
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Batch size").setDesc("Number of change feed items to process at a time. Defaults to 250.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.batch_size + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10) {
          v = 10;
        }
        this.plugin.settings.batch_size = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    new import_obsidian5.Setting(containerSyncSettingEl).setName("Batch limit").setDesc("Number of batches to process at a time. Defaults to 40. This along with batch size controls how many docs are kept in memory at a time.").addText((text2) => {
      text2.setPlaceholder("").setValue(this.plugin.settings.batches_limit + "").onChange((value) => __async(this, null, function* () {
        let v = Number(value);
        if (isNaN(v) || v < 10) {
          v = 10;
        }
        this.plugin.settings.batches_limit = v;
        yield this.plugin.saveSettings();
      }));
      text2.inputEl.setAttribute("type", "number");
    });
    addScreenElement("30", containerSyncSettingEl);
    const containerMiscellaneousEl = containerEl.createDiv();
    containerMiscellaneousEl.createEl("h3", { text: "Miscellaneous" });
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Show status inside editor").setDesc("").addToggle((toggle) => toggle.setValue(this.plugin.settings.showStatusOnEditor).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showStatusOnEditor = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Check integrity on saving").setDesc("Check database integrity on saving to database").addToggle((toggle) => toggle.setValue(this.plugin.settings.checkIntegrityOnSave).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.checkIntegrityOnSave = value;
      yield this.plugin.saveSettings();
    })));
    let currentPrest = "NONE";
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Presets").setDesc("Apply preset configuration").addDropdown((dropdown) => dropdown.addOptions({ NONE: "", LIVESYNC: "LiveSync", PERIODIC: "Periodic w/ batch", DISABLE: "Disable all sync" }).setValue(currentPrest).onChange((value) => currentPrest = value)).addButton((button) => button.setButtonText("Apply").setDisabled(false).setCta().onClick(() => __async(this, null, function* () {
      if (currentPrest == "") {
        Logger("Select any preset.", LOG_LEVEL.NOTICE);
        return;
      }
      this.plugin.settings.batchSave = false;
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      this.plugin.settings.syncOnSave = false;
      this.plugin.settings.syncOnStart = false;
      this.plugin.settings.syncOnFileOpen = false;
      if (currentPrest == "LIVESYNC") {
        this.plugin.settings.liveSync = true;
        Logger("Synchronization setting configured as LiveSync.", LOG_LEVEL.NOTICE);
      } else if (currentPrest == "PERIODIC") {
        this.plugin.settings.batchSave = true;
        this.plugin.settings.periodicReplication = true;
        this.plugin.settings.syncOnSave = false;
        this.plugin.settings.syncOnStart = true;
        this.plugin.settings.syncOnFileOpen = true;
        Logger("Synchronization setting configured as Periodic sync with batch database update.", LOG_LEVEL.NOTICE);
      } else {
        Logger("All synchronization disabled.", LOG_LEVEL.NOTICE);
      }
      this.plugin.saveSettings();
      yield this.plugin.realizeSettingSyncMode();
    })));
    new import_obsidian5.Setting(containerMiscellaneousEl).setName("Use history").setDesc("Use history dialog (Restart required, auto compaction would be disabled, and more storage will be consumed)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useHistory).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.useHistory = value;
      yield this.plugin.saveSettings();
    })));
    addScreenElement("40", containerMiscellaneousEl);
    const containerHatchEl = containerEl.createDiv();
    containerHatchEl.createEl("h3", { text: "Hatch" });
    if (this.plugin.localDatabase.remoteLockedAndDeviceNotAccepted) {
      const c = containerHatchEl.createEl("div", {
        text: "To prevent unwanted vault corruption, the remote database has been locked for synchronization, and this device was not marked as 'resolved'. it caused by some operations like this. re-initialized. Local database initialization should be required. please back your vault up, reset local database, and press 'Mark this device as resolved'. "
      });
      c.createEl("button", { text: "I'm ready, mark this device 'resolved'" }, (e3) => {
        e3.addClass("mod-warning");
        e3.addEventListener("click", () => __async(this, null, function* () {
          yield this.plugin.markRemoteResolved();
          c.remove();
        }));
      });
      c.addClass("op-warn");
    } else {
      if (this.plugin.localDatabase.remoteLocked) {
        const c = containerHatchEl.createEl("div", {
          text: "To prevent unwanted vault corruption, the remote database has been locked for synchronization. (This device is marked 'resolved') When all your devices are marked 'resolved', unlock the database."
        });
        c.createEl("button", { text: "I'm ready, unlock the database" }, (e3) => {
          e3.addClass("mod-warning");
          e3.addEventListener("click", () => __async(this, null, function* () {
            yield this.plugin.markRemoteUnlocked();
            c.remove();
          }));
        });
        c.addClass("op-warn");
      }
    }
    const hatchWarn = containerHatchEl.createEl("div", { text: `To stop the bootup sequence for fixing problems on databases, you can put redflag.md on top of your vault (Rebooting obsidian is required).` });
    hatchWarn.addClass("op-warn-info");
    const dropHistory = (sendToServer) => __async(this, null, function* () {
      this.plugin.settings.liveSync = false;
      this.plugin.settings.periodicReplication = false;
      this.plugin.settings.syncOnSave = false;
      this.plugin.settings.syncOnStart = false;
      this.plugin.settings.syncOnFileOpen = false;
      yield this.plugin.saveSettings();
      applyDisplayEnabled();
      yield this.plugin.resetLocalDatabase();
      if (sendToServer) {
        yield this.plugin.initializeDatabase(true);
        yield this.plugin.markRemoteLocked();
        yield this.plugin.tryResetRemoteDatabase();
        yield this.plugin.markRemoteLocked();
        yield this.plugin.replicateAllToServer(true);
      } else {
        yield this.plugin.markRemoteResolved();
        yield this.plugin.replicate(true);
      }
    });
    new import_obsidian5.Setting(containerHatchEl).setName("Verify and repair all files").setDesc("Verify and repair all files and update database without dropping history").addButton((button) => button.setButtonText("Verify and repair").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      const files = this.app.vault.getFiles();
      Logger("Verify and repair all files started", LOG_LEVEL.NOTICE);
      const notice = NewNotice("", 0);
      let i2 = 0;
      for (const file of files) {
        i2++;
        Logger(`Update into ${file.path}`);
        notice.setMessage(`${i2}/${files.length}
${file.path}`);
        try {
          yield this.plugin.updateIntoDB(file);
        } catch (ex) {
          Logger("could not update:");
          Logger(ex);
        }
      }
      notice.hide();
      Logger("done", LOG_LEVEL.NOTICE);
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Sanity check").setDesc("Verify").addButton((button) => button.setButtonText("Sanity check").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      const notice = NewNotice("", 0);
      Logger(`Begin sanity check`, LOG_LEVEL.INFO);
      notice.setMessage(`Begin sanity check`);
      yield runWithLock("sancheck", true, () => __async(this, null, function* () {
        const db = this.plugin.localDatabase.localDatabase;
        const wf = yield db.allDocs();
        const filesDatabase = wf.rows.filter((e3) => !e3.id.startsWith("h:") && !e3.id.startsWith("ps:") && e3.id != "obsydian_livesync_version").map((e3) => e3.id);
        let count = 0;
        for (const id of filesDatabase) {
          count++;
          notice.setMessage(`${count}/${filesDatabase.length}
${id2path(id)}`);
          const w2 = yield db.get(id);
          if (!(yield this.plugin.localDatabase.sanCheck(w2))) {
            Logger(`The file ${id2path(id)} missing child(ren)`, LOG_LEVEL.NOTICE);
          }
        }
      }));
      notice.hide();
      Logger(`Done`, LOG_LEVEL.NOTICE);
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Drop History").setDesc("Initialize local and remote database, and send all or retrieve all again.").addButton((button) => button.setButtonText("Drop and send").setWarning().setDisabled(false).setClass("sls-btn-left").onClick(() => __async(this, null, function* () {
      yield dropHistory(true);
    }))).addButton((button) => button.setButtonText("Drop and receive").setWarning().setDisabled(false).setClass("sls-btn-right").onClick(() => __async(this, null, function* () {
      yield dropHistory(false);
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Lock remote database").setDesc("Lock remote database for synchronize").addButton((button) => button.setButtonText("Lock").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      yield this.plugin.markRemoteLocked();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Suspend file watching").setDesc("if enables it, all file operations are ignored.").addToggle((toggle) => toggle.setValue(this.plugin.settings.suspendFileWatching).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.suspendFileWatching = value;
      yield this.plugin.saveSettings();
    })));
    containerHatchEl.createEl("div", {
      text: (0, import_obsidian5.sanitizeHTMLToDom)(`Advanced buttons<br>
                These buttons could break your database easily.`)
    });
    new import_obsidian5.Setting(containerHatchEl).setName("Reset remote database").setDesc("Reset remote database, this affects only database. If you replicate again, remote database will restored by local database.").addButton((button) => button.setButtonText("Reset").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      yield this.plugin.tryResetRemoteDatabase();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Reset local database").setDesc("Reset local database, this affects only database. If you replicate again, local database will restored by remote database.").addButton((button) => button.setButtonText("Reset").setDisabled(false).setWarning().onClick(() => __async(this, null, function* () {
      yield this.plugin.resetLocalDatabase();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Initialize local database again").setDesc("WARNING: Reset local database and reconstruct by storage data. It affects local database, but if you replicate remote as is, remote data will be merged or corrupted.").addButton((button) => button.setButtonText("INITIALIZE").setWarning().setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.plugin.resetLocalDatabase();
      yield this.plugin.initializeDatabase();
    })));
    new import_obsidian5.Setting(containerHatchEl).setName("Drop old encrypted database").setDesc("WARNING: Please use this button only when you have failed on converting old-style localdatabase at v0.10.0.").addButton((button) => button.setButtonText("Drop").setWarning().setDisabled(false).onClick(() => __async(this, null, function* () {
      yield this.plugin.resetLocalOldDatabase();
      yield this.plugin.initializeDatabase();
    })));
    addScreenElement("50", containerHatchEl);
    const containerPluginSettings = containerEl.createDiv();
    containerPluginSettings.createEl("h3", { text: "Plugins and settings (beta)" });
    const updateDisabledOfDeviceAndVaultName = () => {
      vaultName.setDisabled(this.plugin.settings.autoSweepPlugins || this.plugin.settings.autoSweepPluginsPeriodic);
      vaultName.setTooltip(this.plugin.settings.autoSweepPlugins || this.plugin.settings.autoSweepPluginsPeriodic ? "You could not change when you enabling auto scan." : "");
    };
    new import_obsidian5.Setting(containerPluginSettings).setName("Enable plugin synchronization").addToggle((toggle) => toggle.setValue(this.plugin.settings.usePluginSync).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.usePluginSync = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Scan plugins automatically").setDesc("Scan plugins before replicating.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSweepPlugins).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoSweepPlugins = value;
      updateDisabledOfDeviceAndVaultName();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Scan plugins periodically").setDesc("Scan plugins each 1 minutes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSweepPluginsPeriodic).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoSweepPluginsPeriodic = value;
      updateDisabledOfDeviceAndVaultName();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian5.Setting(containerPluginSettings).setName("Notify updates").setDesc("Notify when any device has a newer plugin or its setting.").addToggle((toggle) => toggle.setValue(this.plugin.settings.notifyPluginOrSettingUpdated).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.notifyPluginOrSettingUpdated = value;
      yield this.plugin.saveSettings();
    })));
    const vaultName = new import_obsidian5.Setting(containerPluginSettings).setName("Device and Vault name").setDesc("").addText((text2) => {
      text2.setPlaceholder("desktop-main").setValue(this.plugin.deviceAndVaultName).onChange((value) => __async(this, null, function* () {
        this.plugin.deviceAndVaultName = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian5.Setting(containerPluginSettings).setName("Open").setDesc("Open the plugin dialog").addButton((button) => {
      button.setButtonText("Open").setDisabled(false).onClick(() => {
        this.plugin.showPluginSyncModal();
      });
    });
    updateDisabledOfDeviceAndVaultName();
    addScreenElement("60", containerPluginSettings);
    const containerCorruptedDataEl = containerEl.createDiv();
    containerCorruptedDataEl.createEl("h3", { text: "Corrupted or missing data" });
    containerCorruptedDataEl.createEl("h4", { text: "Corrupted" });
    if (Object.keys(this.plugin.localDatabase.corruptedEntries).length > 0) {
      const cx = containerCorruptedDataEl.createEl("div", { text: "If you have copy of these items on any device, simply edit once or twice. Or not, delete this. sorry.." });
      for (const k in this.plugin.localDatabase.corruptedEntries) {
        const xx = cx.createEl("div", { text: `${k}` });
        const ba = xx.createEl("button", { text: `Delete this` }, (e3) => {
          e3.addEventListener("click", () => __async(this, null, function* () {
            yield this.plugin.localDatabase.deleteDBEntry(k);
            xx.remove();
          }));
        });
        ba.addClass("mod-warning");
        xx.createEl("button", { text: `Restore from file` }, (e3) => {
          e3.addEventListener("click", () => __async(this, null, function* () {
            const f = yield this.app.vault.getFiles().filter((e4) => path2id(e4.path) == k);
            if (f.length == 0) {
              Logger("Not found in vault", LOG_LEVEL.NOTICE);
              return;
            }
            yield this.plugin.updateIntoDB(f[0]);
            xx.remove();
          }));
        });
        xx.addClass("mod-warning");
      }
    } else {
      containerCorruptedDataEl.createEl("div", { text: "There is no corrupted data." });
    }
    containerCorruptedDataEl.createEl("h4", { text: "Missing or waiting" });
    if (Object.keys(this.plugin.queuedFiles).length > 0) {
      const cx = containerCorruptedDataEl.createEl("div", {
        text: "These files have missing or waiting chunks. Perhaps almost chunks will be found in a while after replication. But if there're no chunk, you have to restore database entry from existed file by hitting the button below."
      });
      const files = [...new Set([...this.plugin.queuedFiles.map((e3) => e3.entry._id)])];
      for (const k of files) {
        const xx = cx.createEl("div", { text: `${id2path(k)}` });
        const ba = xx.createEl("button", { text: `Delete this` }, (e3) => {
          e3.addEventListener("click", () => __async(this, null, function* () {
            yield this.plugin.localDatabase.deleteDBEntry(k);
            xx.remove();
          }));
        });
        ba.addClass("mod-warning");
        xx.createEl("button", { text: `Restore from file` }, (e3) => {
          e3.addEventListener("click", () => __async(this, null, function* () {
            const f = yield this.app.vault.getFiles().filter((e4) => path2id(e4.path) == k);
            if (f.length == 0) {
              Logger("Not found in vault", LOG_LEVEL.NOTICE);
              return;
            }
            yield this.plugin.updateIntoDB(f[0]);
            xx.remove();
          }));
        });
        xx.addClass("mod-warning");
      }
    } else {
      containerCorruptedDataEl.createEl("div", { text: "There is no missing or waiting chunk." });
    }
    applyDisplayEnabled();
    addScreenElement("70", containerCorruptedDataEl);
    changeDisplay("0");
  }
};

// src/DocumentHistoryModal.ts
var import_obsidian6 = __toModule(require("obsidian"));
var import_diff_match_patch2 = __toModule(require_diff_match_patch());
var DocumentHistoryModal = class extends import_obsidian6.Modal {
  constructor(app2, plugin, file) {
    super(app2);
    this.showDiff = false;
    this.revs_info = [];
    this.currentText = "";
    this.plugin = plugin;
    this.file = file.path;
    if (localStorage.getItem("ols-history-highlightdiff") == "1") {
      this.showDiff = true;
    }
  }
  loadFile() {
    return __async(this, null, function* () {
      const db = this.plugin.localDatabase;
      const w = yield db.localDatabase.get(path2id(this.file), { revs_info: true });
      this.revs_info = w._revs_info.filter((e3) => e3.status == "available");
      this.range.max = `${this.revs_info.length - 1}`;
      this.range.value = this.range.max;
      this.fileInfo.setText(`${this.file} / ${this.revs_info.length} revisions`);
      yield this.loadRevs();
    });
  }
  loadRevs() {
    return __async(this, null, function* () {
      const db = this.plugin.localDatabase;
      const index = this.revs_info.length - 1 - this.range.value / 1;
      const rev = this.revs_info[index];
      const w = yield db.getDBEntry(path2id(this.file), { rev: rev.rev }, false, false);
      this.currentText = "";
      if (w === false) {
        this.info.innerHTML = "";
        this.contentView.innerHTML = `Could not read this revision<br>(${rev.rev})`;
      } else {
        this.info.innerHTML = `Modified:${new Date(w.mtime).toLocaleString()}`;
        let result = "";
        this.currentText = w.data;
        if (this.showDiff) {
          const prevRevIdx = this.revs_info.length - 1 - (this.range.value / 1 - 1);
          if (prevRevIdx >= 0 && prevRevIdx < this.revs_info.length) {
            const oldRev = this.revs_info[prevRevIdx].rev;
            const w2 = yield db.getDBEntry(path2id(this.file), { rev: oldRev }, false, false);
            if (w2 != false) {
              const dmp = new import_diff_match_patch2.diff_match_patch();
              const diff = dmp.diff_main(w2.data, w.data);
              dmp.diff_cleanupSemantic(diff);
              for (const v of diff) {
                const x1 = v[0];
                const x2 = v[1];
                if (x1 == import_diff_match_patch2.DIFF_DELETE) {
                  result += "<span class='history-deleted'>" + escapeStringToHTML(x2) + "</span>";
                } else if (x1 == import_diff_match_patch2.DIFF_EQUAL) {
                  result += "<span class='history-normal'>" + escapeStringToHTML(x2) + "</span>";
                } else if (x1 == import_diff_match_patch2.DIFF_INSERT) {
                  result += "<span class='history-added'>" + escapeStringToHTML(x2) + "</span>";
                }
              }
              result = result.replace(/\n/g, "<br>");
            } else {
              result = escapeStringToHTML(w.data);
            }
          } else {
            result = escapeStringToHTML(w.data);
          }
        } else {
          result = escapeStringToHTML(w.data);
        }
        this.contentView.innerHTML = result;
      }
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Document History" });
    this.fileInfo = contentEl.createDiv("");
    this.fileInfo.addClass("op-info");
    const divView = contentEl.createDiv("");
    divView.addClass("op-flex");
    divView.createEl("input", { type: "range" }, (e3) => {
      this.range = e3;
      e3.addEventListener("change", (e4) => {
        this.loadRevs();
      });
      e3.addEventListener("input", (e4) => {
        this.loadRevs();
      });
    });
    contentEl.createDiv("", (e3) => {
      e3.createEl("label", {}, (label) => {
        label.appendChild(createEl("input", { type: "checkbox" }, (checkbox) => {
          if (this.showDiff) {
            checkbox.checked = true;
          }
          checkbox.addEventListener("input", (evt) => {
            this.showDiff = checkbox.checked;
            localStorage.setItem("ols-history-highlightdiff", this.showDiff == true ? "1" : "");
            this.loadRevs();
          });
        }));
        label.appendText("Highlight diff");
      });
    }).addClass("op-info");
    this.info = contentEl.createDiv("");
    this.info.addClass("op-info");
    this.loadFile();
    const div = contentEl.createDiv({ text: "Loading old revisions..." });
    this.contentView = div;
    div.addClass("op-scrollable");
    div.addClass("op-pre");
    const buttons = contentEl.createDiv("");
    buttons.createEl("button", { text: "Copy to clipboard" }, (e3) => {
      e3.addClass("mod-cta");
      e3.addEventListener("click", () => __async(this, null, function* () {
        yield navigator.clipboard.writeText(this.currentText);
        Logger(`Old content copied to clipboard`, LOG_LEVEL.NOTICE);
      }));
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// src/PluginPane.svelte
function add_css(target) {
  append_styles(target, "svelte-1907s6a", ".ols-plugins-div-buttons.svelte-1907s6a{display:flex;flex-direction:row;justify-content:flex-end;margin-top:8px}.wrapToggle.svelte-1907s6a{display:flex;justify-content:center;align-content:center}");
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2][0];
  child_ctx[26] = list[i2][1];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i2];
  return child_ctx;
}
function create_else_block(ctx) {
  let each_1_anchor;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 204) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="3" class="sls-table-tail tcenter">No plugins found.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="3" class="sls-table-tail tcenter">Retrieving...</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_else_block_2(ctx) {
  let div1;
  let div0;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[20](ctx[0]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "checkbox-container");
      toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---plugin"]);
      attr(div1, "class", "wrapToggle svelte-1907s6a");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(div0, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 12) {
        toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---plugin"]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let t3;
  return {
    c() {
      t3 = text("-");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block_1(ctx) {
  let div1;
  let div0;
  let mounted;
  let dispose;
  function click_handler_2() {
    return ctx[21](ctx[0]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "checkbox-container");
      toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---setting"]);
      attr(div1, "class", "wrapToggle svelte-1907s6a");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(div0, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 12) {
        toggle_class(div0, "is-enabled", ctx[3][ctx[0].deviceVaultName + "---" + ctx[0].manifest.id + "---setting"]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2(ctx) {
  let t3;
  return {
    c() {
      t3 = text("-");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_1(ctx) {
  let tr0;
  let td0;
  let t0_value = ctx[0].manifest.name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[0].versionInfo + "";
  let t22;
  let t3_value = getDispString(ctx[0].versionFlag) + "";
  let t3;
  let t4;
  let td2;
  let t5;
  let tr1;
  let td3;
  let t7;
  let td4;
  let t8_value = ctx[0].mtimeInfo + "";
  let t8;
  let t9_value = getDispString(ctx[0].mtimeFlag) + "";
  let t9;
  let t10;
  let td5;
  let t11;
  let tr2;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].versionFlag === "EVEN" || ctx2[0].versionFlag === "")
      return create_if_block_3;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block0 = current_block_type(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[0].mtimeFlag === "EVEN" || ctx2[0].mtimeFlag === "")
      return create_if_block_2;
    return create_else_block_1;
  }
  let current_block_type_1 = select_block_type_2(ctx, -1);
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      tr0 = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t22 = text(t2_value);
      t3 = text(t3_value);
      t4 = space();
      td2 = element("td");
      if_block0.c();
      t5 = space();
      tr1 = element("tr");
      td3 = element("td");
      td3.textContent = "Settings";
      t7 = space();
      td4 = element("td");
      t8 = text(t8_value);
      t9 = text(t9_value);
      t10 = space();
      td5 = element("td");
      if_block1.c();
      t11 = space();
      tr2 = element("tr");
      tr2.innerHTML = `<th colspan="3"></th> 
                        `;
      attr(td0, "class", "sls-table-head");
      attr(td1, "class", "sls-table-tail tcenter");
      attr(td2, "class", "sls-table-tail tcenter");
      attr(td3, "class", "sls-table-head");
      attr(td4, "class", "sls-table-tail tcenter");
      attr(td5, "class", "sls-table-tail tcenter");
      attr(tr2, "class", "divider");
    },
    m(target, anchor) {
      insert(target, tr0, anchor);
      append(tr0, td0);
      append(td0, t0);
      append(tr0, t1);
      append(tr0, td1);
      append(td1, t22);
      append(td1, t3);
      append(tr0, t4);
      append(tr0, td2);
      if_block0.m(td2, null);
      insert(target, t5, anchor);
      insert(target, tr1, anchor);
      append(tr1, td3);
      append(tr1, t7);
      append(tr1, td4);
      append(td4, t8);
      append(td4, t9);
      append(tr1, t10);
      append(tr1, td5);
      if_block1.m(td5, null);
      insert(target, t11, anchor);
      insert(target, tr2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[0].manifest.name + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && t2_value !== (t2_value = ctx2[0].versionInfo + ""))
        set_data(t22, t2_value);
      if (dirty & 4 && t3_value !== (t3_value = getDispString(ctx2[0].versionFlag) + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(td2, null);
        }
      }
      if (dirty & 4 && t8_value !== (t8_value = ctx2[0].mtimeInfo + ""))
        set_data(t8, t8_value);
      if (dirty & 4 && t9_value !== (t9_value = getDispString(ctx2[0].mtimeFlag) + ""))
        set_data(t9, t9_value);
      if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td5, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr0);
      if_block0.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(tr1);
      if_block1.d();
      if (detaching)
        detach(t11);
      if (detaching)
        detach(tr2);
    }
  };
}
function create_each_block(ctx) {
  let tr;
  let th0;
  let t0_value = ctx[25] + "";
  let t0;
  let t1;
  let th1;
  let button;
  let t3;
  let each_1_anchor;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[19](ctx[25]);
  }
  let each_value_1 = ctx[26];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  return {
    c() {
      tr = element("tr");
      th0 = element("th");
      t0 = text(t0_value);
      t1 = space();
      th1 = element("th");
      button = element("button");
      button.textContent = "\u2714";
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(th0, "colspan", "2");
      attr(th0, "class", "sls-plugins-tbl-device-head");
      attr(button, "class", "mod-cta");
      attr(th1, "class", "sls-plugins-tbl-device-head");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, th0);
      append(th0, t0);
      append(tr, t1);
      append(tr, th1);
      append(th1, button);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t0_value !== (t0_value = ctx[25] + ""))
        set_data(t0, t0_value);
      if (dirty & 76) {
        each_value_1 = ctx[26];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div5;
  let h1;
  let t1;
  let div1;
  let t22;
  let div0;
  let t3;
  let div2;
  let table;
  let tr;
  let t9;
  let t10;
  let div3;
  let button0;
  let t12;
  let button1;
  let t14;
  let div4;
  let button2;
  let t16;
  let button3;
  let t18;
  let button4;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (!ctx2[2])
      return create_if_block;
    if (ctx2[2].length == 0)
      return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div5 = element("div");
      h1 = element("h1");
      h1.textContent = "Plugins and their settings";
      t1 = space();
      div1 = element("div");
      t22 = text("Show own items\r\n        ");
      div0 = element("div");
      t3 = space();
      div2 = element("div");
      table = element("table");
      tr = element("tr");
      tr.innerHTML = `<th class="sls-plugins-tbl-device-head">Name</th> 
                <th class="sls-plugins-tbl-device-head">Info</th> 
                <th class="sls-plugins-tbl-device-head">Target</th>`;
      t9 = space();
      if_block.c();
      t10 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Replicate and refresh";
      t12 = space();
      button1 = element("button");
      button1.textContent = "Clear Selection";
      t14 = space();
      div4 = element("div");
      button2 = element("button");
      button2.textContent = "Check Updates";
      t16 = space();
      button3 = element("button");
      button3.textContent = "Scan installed";
      t18 = space();
      button4 = element("button");
      button4.textContent = "Apply all";
      attr(div0, "class", "checkbox-container");
      toggle_class(div0, "is-enabled", ctx[1]);
      attr(div1, "class", "ols-plugins-div-buttons svelte-1907s6a");
      set_style(tr, "position", "sticky");
      attr(table, "class", "sls-plugins-tbl");
      attr(div2, "class", "sls-plugins-wrap");
      attr(button0, "class", "");
      attr(button1, "class", "");
      attr(div3, "class", "ols-plugins-div-buttons svelte-1907s6a");
      attr(button2, "class", "mod-cta");
      attr(button3, "class", "mod-cta");
      attr(button4, "class", "mod-cta");
      attr(div4, "class", "ols-plugins-div-buttons svelte-1907s6a");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, h1);
      append(div5, t1);
      append(div5, div1);
      append(div1, t22);
      append(div1, div0);
      append(div5, t3);
      append(div5, div2);
      append(div2, table);
      append(table, tr);
      append(table, t9);
      if_block.m(table, null);
      append(div5, t10);
      append(div5, div3);
      append(div3, button0);
      append(div3, t12);
      append(div3, button1);
      append(div5, t14);
      append(div5, div4);
      append(div4, button2);
      append(div4, t16);
      append(div4, button3);
      append(div4, t18);
      append(div4, button4);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[5]),
          listen(button0, "click", ctx[11]),
          listen(button1, "click", ctx[4]),
          listen(button2, "click", ctx[10]),
          listen(button3, "click", ctx[8]),
          listen(button4, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        toggle_class(div0, "is-enabled", ctx2[1]);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(table, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div5);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function getDispString(stat) {
  if (stat == "")
    return "";
  if (stat == "NEWER")
    return " (Newer)";
  if (stat == "OLDER")
    return " (Older)";
  if (stat == "EVEN")
    return " (Even)";
  if (stat == "EVEN_BUT_DIFFERENT")
    return " (Even but different)";
  if (stat == "REMOTE_ONLY")
    return " (Remote Only)";
  return "";
}
function instance($$self, $$props, $$invalidate) {
  var _a, _b, _c, _d;
  let { plugin } = $$props;
  let plugins = [];
  let deviceAndPlugins = {};
  let devicePluginList = null;
  let ownPlugins = null;
  let showOwnPlugins = false;
  let targetList = {};
  function saveTargetList() {
    window.localStorage.setItem("ols-plugin-targetlist", JSON.stringify(targetList));
  }
  function loadTargetList() {
    let e3 = window.localStorage.getItem("ols-plugin-targetlist") || "{}";
    try {
      $$invalidate(3, targetList = JSON.parse(e3));
    } catch (_) {
    }
  }
  function clearSelection() {
    $$invalidate(3, targetList = {});
  }
  function updateList() {
    return __awaiter(this, void 0, void 0, function* () {
      let x = yield plugin.getPluginList();
      $$invalidate(18, ownPlugins = x.thisDevicePlugins);
      $$invalidate(16, plugins = Object.values(x.allPlugins));
      let targetListItems = Array.from(new Set(plugins.map((e3) => e3.deviceVaultName + "---" + e3.manifest.id)));
      let newTargetList = {};
      for (const id of targetListItems) {
        for (const tag of ["---plugin", "---setting"]) {
          newTargetList[id + tag] = id + tag in targetList && targetList[id + tag];
        }
      }
      $$invalidate(3, targetList = newTargetList);
      saveTargetList();
    });
  }
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    loadTargetList();
    yield updateList();
  }));
  function toggleShowOwnPlugins() {
    $$invalidate(1, showOwnPlugins = !showOwnPlugins);
  }
  function toggleTarget(key) {
    $$invalidate(3, targetList[key] = !targetList[key], targetList);
    saveTargetList();
  }
  function toggleAll(devicename) {
    for (const c in targetList) {
      if (c.startsWith(devicename)) {
        $$invalidate(3, targetList[c] = true, targetList);
      }
    }
  }
  function sweepPlugins() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.app.plugins.loadManifests();
      yield plugin.sweepPlugin(true);
      updateList();
    });
  }
  function applyPlugins() {
    return __awaiter(this, void 0, void 0, function* () {
      for (const c in targetList) {
        if (targetList[c] == true) {
          const [deviceAndVault, id, opt] = c.split("---");
          if (deviceAndVault in deviceAndPlugins) {
            const entry = deviceAndPlugins[deviceAndVault].find((e3) => e3.manifest.id == id);
            if (entry) {
              if (opt == "plugin") {
                if (entry.versionFlag != "EVEN")
                  yield plugin.applyPlugin(entry);
              } else if (opt == "setting") {
                if (entry.mtimeFlag != "EVEN")
                  yield plugin.applyPluginData(entry);
              }
            }
          }
        }
      }
      yield plugin.app.plugins.loadManifests();
      yield plugin.sweepPlugin(true);
      updateList();
    });
  }
  function checkUpdates() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.checkPluginUpdate();
    });
  }
  function replicateAndRefresh() {
    return __awaiter(this, void 0, void 0, function* () {
      yield plugin.replicate(true);
      updateList();
    });
  }
  const click_handler = (deviceName) => toggleAll(deviceName);
  const click_handler_1 = (plugin2) => toggleTarget(plugin2.deviceVaultName + "---" + plugin2.manifest.id + "---plugin");
  const click_handler_2 = (plugin2) => toggleTarget(plugin2.deviceVaultName + "---" + plugin2.manifest.id + "---setting");
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 520195) {
      $: {
        $$invalidate(17, deviceAndPlugins = {});
        for (const p of plugins) {
          if (p.deviceVaultName == plugin.deviceAndVaultName && !showOwnPlugins) {
            continue;
          }
          if (!(p.deviceVaultName in deviceAndPlugins)) {
            $$invalidate(17, deviceAndPlugins[p.deviceVaultName] = [], deviceAndPlugins);
          }
          let dispInfo = Object.assign(Object.assign({}, p), {
            versionInfo: "",
            mtimeInfo: "",
            versionFlag: "",
            mtimeFlag: ""
          });
          dispInfo.versionInfo = p.manifest.version;
          let x = new Date().getTime() / 1e3;
          let mtime = p.mtime / 1e3;
          let diff = (x - mtime) / 60;
          if (p.mtime == 0) {
            dispInfo.mtimeInfo = `-`;
          } else if (diff < 60) {
            dispInfo.mtimeInfo = `${diff | 0} Mins ago`;
          } else if (diff < 60 * 24) {
            dispInfo.mtimeInfo = `${diff / 60 | 0} Hours ago`;
          } else if (diff < 60 * 24 * 10) {
            dispInfo.mtimeInfo = `${diff / (60 * 24) | 0} Days ago`;
          } else {
            dispInfo.mtimeInfo = new Date(dispInfo.mtime).toLocaleString();
          }
          let id = p.manifest.id;
          if (id in ownPlugins) {
            const ownPlugin = ownPlugins[id];
            let localVer = versionNumberString2Number(ownPlugin.manifest.version);
            let pluginVer = versionNumberString2Number(p.manifest.version);
            if (localVer > pluginVer) {
              dispInfo.versionFlag = "OLDER";
            } else if (localVer == pluginVer) {
              if (ownPlugin.manifestJson + ($$invalidate(12, _a = ownPlugin.styleCss) !== null && _a !== void 0 ? _a : "") + ownPlugin.mainJs != p.manifestJson + ($$invalidate(13, _b = p.styleCss) !== null && _b !== void 0 ? _b : "") + p.mainJs) {
                dispInfo.versionFlag = "EVEN_BUT_DIFFERENT";
              } else {
                dispInfo.versionFlag = "EVEN";
              }
            } else if (localVer < pluginVer) {
              dispInfo.versionFlag = "NEWER";
            }
            if (($$invalidate(14, _c = ownPlugin.dataJson) !== null && _c !== void 0 ? _c : "") == ($$invalidate(15, _d = p.dataJson) !== null && _d !== void 0 ? _d : "")) {
              if (ownPlugin.mtime == 0 && p.mtime == 0) {
                dispInfo.mtimeFlag = "";
              } else {
                dispInfo.mtimeFlag = "EVEN";
              }
            } else {
              if ((ownPlugin.mtime / 1e3 | 0) > (p.mtime / 1e3 | 0)) {
                dispInfo.mtimeFlag = "OLDER";
              } else if ((ownPlugin.mtime / 1e3 | 0) == (p.mtime / 1e3 | 0)) {
                dispInfo.mtimeFlag = "EVEN_BUT_DIFFERENT";
              } else if ((ownPlugin.mtime / 1e3 | 0) < (p.mtime / 1e3 | 0)) {
                dispInfo.mtimeFlag = "NEWER";
              }
            }
          } else {
            dispInfo.versionFlag = "REMOTE_ONLY";
            dispInfo.mtimeFlag = "REMOTE_ONLY";
          }
          deviceAndPlugins[p.deviceVaultName].push(dispInfo);
        }
        $$invalidate(2, devicePluginList = Object.entries(deviceAndPlugins));
      }
    }
  };
  return [
    plugin,
    showOwnPlugins,
    devicePluginList,
    targetList,
    clearSelection,
    toggleShowOwnPlugins,
    toggleTarget,
    toggleAll,
    sweepPlugins,
    applyPlugins,
    checkUpdates,
    replicateAndRefresh,
    _a,
    _b,
    _c,
    _d,
    plugins,
    deviceAndPlugins,
    ownPlugins,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var PluginPane = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: 0 }, add_css);
  }
};
var PluginPane_default = PluginPane;

// src/main.ts
var isDebug = false;
setNoticeClass(import_obsidian7.Notice);
var PluginDialogModal = class extends import_obsidian7.Modal {
  constructor(app2, plugin) {
    super(app2);
    this.component = null;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    if (this.component == null) {
      this.component = new PluginPane_default({
        target: contentEl,
        props: { plugin: this.plugin }
      });
    }
  }
  onClose() {
    if (this.component != null) {
      this.component.$destroy();
      this.component = null;
    }
  }
};
var PopoverYesNo = class extends import_obsidian7.FuzzySuggestModal {
  constructor(app2, note, callback) {
    super(app2);
    this.callback = () => {
    };
    this.app = app2;
    this.setPlaceholder("y/n) " + note);
    this.callback = callback;
  }
  getItems() {
    return ["yes", "no"];
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.callback(item);
    this.callback = null;
  }
  onClose() {
    setTimeout(() => {
      if (this.callback != null) {
        this.callback("");
      }
    }, 100);
  }
};
var askYesNo = (app2, message) => {
  return new Promise((res) => {
    const popover = new PopoverYesNo(app2, message, (result) => res(result));
    popover.open();
  });
};
var ObsidianLiveSyncPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.logMessage = [];
    this.isMobile = false;
    this.pluginDialog = null;
    this.gcTimerHandler = null;
    this.batchFileChange = [];
    this.addLogHook = null;
    this.notifies = {};
    this.lastLog = "";
    this.queuedFiles = [];
    this.chunkWaitTimeout = 6e4;
    this.periodicSyncHandler = null;
    this.periodicPluginSweepHandler = null;
    this.lastMessage = "";
    this.logHideTimer = null;
    this.conflictedCheckFiles = [];
  }
  setInterval(handler, timeout) {
    const timer = window.setInterval(handler, timeout);
    this.registerInterval(timer);
    return timer;
  }
  isRedFlagRaised() {
    const redflag = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(FLAGMD_REDFLAG));
    if (redflag != null) {
      return true;
    }
    return false;
  }
  showHistory(file) {
    if (!this.settings.useHistory) {
      Logger("You have to enable Use History in misc.", LOG_LEVEL.NOTICE);
    } else {
      new DocumentHistoryModal(this.app, this, file).open();
    }
  }
  onload() {
    return __async(this, null, function* () {
      setLogger(this.addLog.bind(this));
      Logger("loading plugin");
      const lsname = "obsidian-live-sync-ver" + this.app.vault.getName();
      const last_version = localStorage.getItem(lsname);
      yield this.loadSettings();
      if (this.app.isMobile) {
        this.isMobile = true;
        this.settings.disableRequestURI = true;
      }
      if (last_version && Number(last_version) < VER) {
        this.settings.liveSync = false;
        this.settings.syncOnSave = false;
        this.settings.syncOnStart = false;
        this.settings.syncOnFileOpen = false;
        this.settings.periodicReplication = false;
        this.settings.versionUpFlash = "I changed specifications incompatiblly, so when you enable sync again, be sure to made version up all nother devides.";
        this.saveSettings();
      }
      localStorage.setItem(lsname, `${VER}`);
      yield this.openDatabase();
      (0, import_obsidian7.addIcon)("replicate", `<g transform="matrix(1.15 0 0 1.15 -8.31 -9.52)" fill="currentColor" fill-rule="evenodd">
            <path d="m85 22.2c-0.799-4.74-4.99-8.37-9.88-8.37-0.499 0-1.1 0.101-1.6 0.101-2.4-3.03-6.09-4.94-10.3-4.94-6.09 0-11.2 4.14-12.8 9.79-5.59 1.11-9.78 6.05-9.78 12 0 6.76 5.39 12.2 12 12.2h29.9c5.79 0 10.1-4.74 10.1-10.6 0-4.84-3.29-8.88-7.68-10.2zm-2.99 14.7h-29.5c-2.3-0.202-4.29-1.51-5.29-3.53-0.899-2.12-0.699-4.54 0.698-6.46 1.2-1.61 2.99-2.52 4.89-2.52 0.299 0 0.698 0 0.998 0.101l1.8 0.303v-2.02c0-3.63 2.4-6.76 5.89-7.57 0.599-0.101 1.2-0.202 1.8-0.202 2.89 0 5.49 1.62 6.79 4.24l0.598 1.21 1.3-0.504c0.599-0.202 1.3-0.303 2-0.303 1.3 0 2.5 0.404 3.59 1.11 1.6 1.21 2.6 3.13 2.6 5.15v1.61h2c2.6 0 4.69 2.12 4.69 4.74-0.099 2.52-2.2 4.64-4.79 4.64z"/>
            <path d="m53.2 49.2h-41.6c-1.8 0-3.2 1.4-3.2 3.2v28.6c0 1.8 1.4 3.2 3.2 3.2h15.8v4h-7v6h24v-6h-7v-4h15.8c1.8 0 3.2-1.4 3.2-3.2v-28.6c0-1.8-1.4-3.2-3.2-3.2zm-2.8 29h-36v-23h36z"/>
            <path d="m73 49.2c1.02 1.29 1.53 2.97 1.53 4.56 0 2.97-1.74 5.65-4.39 7.04v-4.06l-7.46 7.33 7.46 7.14v-4.06c7.66-1.98 12.2-9.61 10-17-0.102-0.297-0.205-0.595-0.307-0.892z"/>
            <path d="m24.1 43c-0.817-0.991-1.53-2.97-1.53-4.56 0-2.97 1.74-5.65 4.39-7.04v4.06l7.46-7.33-7.46-7.14v4.06c-7.66 1.98-12.2 9.61-10 17 0.102 0.297 0.205 0.595 0.307 0.892z"/>
           </g>`);
      (0, import_obsidian7.addIcon)("view-log", `<g transform="matrix(1.28 0 0 1.28 -131 -411)" fill="currentColor" fill-rule="evenodd">
        <path d="m103 330h76v12h-76z"/>
        <path d="m106 346v44h70v-44zm45 16h-20v-8h20z"/>
       </g>`);
      this.addRibbonIcon("replicate", "Replicate", () => __async(this, null, function* () {
        yield this.replicate(true);
      }));
      this.addRibbonIcon("view-log", "Show log", () => {
        new LogDisplayModal(this.app, this).open();
      });
      this.statusBar = this.addStatusBarItem();
      this.statusBar.addClass("syncstatusbar");
      this.refreshStatusText = this.refreshStatusText.bind(this);
      this.statusBar2 = this.addStatusBarItem();
      this.watchVaultChange = this.watchVaultChange.bind(this);
      this.watchVaultCreate = this.watchVaultCreate.bind(this);
      this.watchVaultDelete = this.watchVaultDelete.bind(this);
      this.watchVaultRename = this.watchVaultRename.bind(this);
      this.watchWorkspaceOpen = (0, import_obsidian7.debounce)(this.watchWorkspaceOpen.bind(this), 1e3, false);
      this.watchWindowVisiblity = (0, import_obsidian7.debounce)(this.watchWindowVisiblity.bind(this), 1e3, false);
      this.parseReplicationResult = this.parseReplicationResult.bind(this);
      this.periodicSync = this.periodicSync.bind(this);
      this.setPeriodicSync = this.setPeriodicSync.bind(this);
      this.getPluginList = this.getPluginList.bind(this);
      this.addSettingTab(new ObsidianLiveSyncSettingTab(this.app, this));
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        if (this.localDatabase.isReady)
          try {
            if (this.isRedFlagRaised()) {
              this.settings.batchSave = false;
              this.settings.liveSync = false;
              this.settings.periodicReplication = false;
              this.settings.syncOnSave = false;
              this.settings.syncOnStart = false;
              this.settings.syncOnFileOpen = false;
              this.settings.autoSweepPlugins = false;
              this.settings.usePluginSync = false;
              this.settings.suspendFileWatching = true;
              yield this.saveSettings();
              yield this.openDatabase();
              const warningMessage = "The red flag is raised! The whole initialize steps are skipped, and any file changes are not captured.";
              Logger(warningMessage, LOG_LEVEL.NOTICE);
              this.setStatusBarText(warningMessage);
            } else {
              if (this.settings.suspendFileWatching) {
                Logger("'Suspend file watching' turned on. Are you sure this is what you intended? Every modification on the vault will be ignored.", LOG_LEVEL.NOTICE);
              }
              const isInitalized = yield this.initializeDatabase();
              if (!isInitalized) {
                return false;
              }
            }
            yield this.realizeSettingSyncMode();
            this.registerWatchEvents();
            if (this.settings.syncOnStart) {
              this.localDatabase.openReplication(this.settings, false, false, this.parseReplicationResult);
            }
          } catch (ex) {
            Logger("Error while loading Self-hosted LiveSync", LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.VERBOSE);
          }
      }));
      this.addCommand({
        id: "livesync-exportconfig",
        name: "Copy setup uri (beta)",
        callback: () => __async(this, null, function* () {
          const encryptedSetting = encodeURIComponent(yield encrypt(JSON.stringify(this.settings), "---"));
          const uri = `obsidian://setuplivesync?settings=${encryptedSetting}`;
          yield navigator.clipboard.writeText(uri);
          Logger("Setup uri copied to clipboard", LOG_LEVEL.NOTICE);
        })
      });
      this.registerObsidianProtocolHandler("setuplivesync", (conf) => __async(this, null, function* () {
        try {
          const oldConf = JSON.parse(JSON.stringify(this.settings));
          const newconf = yield JSON.parse(yield decrypt(conf.settings, "---"));
          if (newconf) {
            const result = yield askYesNo(this.app, "Importing LiveSync's conf, OK?");
            if (result == "yes") {
              const newSettingW = Object.assign({}, this.settings, newconf);
              this.localDatabase.closeReplication();
              this.settings.suspendFileWatching = true;
              console.dir(newSettingW);
              const keepLocalDB = yield askYesNo(this.app, "Keep local DB?");
              const keepRemoteDB = yield askYesNo(this.app, "Keep remote DB?");
              if (keepLocalDB == "yes" && keepRemoteDB == "yes") {
                this.settings = newSettingW;
                yield this.saveSettings();
                Logger("Configuration loaded.", LOG_LEVEL.NOTICE);
                return;
              }
              if (keepLocalDB == "no" && keepRemoteDB == "no") {
                const reset = yield askYesNo(this.app, "Drop everything?");
                if (reset != "yes") {
                  Logger("Cancelled", LOG_LEVEL.NOTICE);
                  this.settings = oldConf;
                  return;
                }
              }
              let initDB;
              yield this.saveSettings();
              if (keepLocalDB == "no") {
                this.resetLocalOldDatabase();
                this.resetLocalDatabase();
                this.localDatabase.initializeDatabase();
                const rebuild = yield askYesNo(this.app, "Rebuild the database?");
                if (rebuild == "yes") {
                  initDB = this.initializeDatabase(true);
                } else {
                  this.markRemoteResolved();
                }
              }
              if (keepRemoteDB == "no") {
                yield this.tryResetRemoteDatabase();
                yield this.markRemoteLocked();
              }
              if (keepLocalDB == "no" || keepRemoteDB == "no") {
                const replicate = yield askYesNo(this.app, "Replicate once?");
                if (replicate == "yes") {
                  if (initDB != null) {
                    yield initDB;
                  }
                  yield this.replicate(true);
                }
              }
            }
            Logger("Configuration loaded.", LOG_LEVEL.NOTICE);
          } else {
            Logger("Cancelled.", LOG_LEVEL.NOTICE);
          }
        } catch (ex) {
          Logger("Couldn't parse configuration uri.", LOG_LEVEL.NOTICE);
        }
      }));
      this.addCommand({
        id: "livesync-replicate",
        name: "Replicate now",
        callback: () => __async(this, null, function* () {
          yield this.replicate();
        })
      });
      this.addCommand({
        id: "livesync-dump",
        name: "Dump informations of this doc ",
        editorCallback: (editor, view) => {
          this.localDatabase.getDBEntry(view.file.path, {}, true, false);
        }
      });
      this.addCommand({
        id: "livesync-checkdoc-conflicted",
        name: "Resolve if conflicted.",
        editorCallback: (editor, view) => __async(this, null, function* () {
          yield this.showIfConflicted(view.file);
        })
      });
      this.addCommand({
        id: "livesync-gc",
        name: "garbage collect now",
        callback: () => {
          this.garbageCollect();
        }
      });
      this.addCommand({
        id: "livesync-toggle",
        name: "Toggle LiveSync",
        callback: () => __async(this, null, function* () {
          if (this.settings.liveSync) {
            this.settings.liveSync = false;
            Logger("LiveSync Disabled.", LOG_LEVEL.NOTICE);
          } else {
            this.settings.liveSync = true;
            Logger("LiveSync Enabled.", LOG_LEVEL.NOTICE);
          }
          yield this.realizeSettingSyncMode();
          this.saveSettings();
        })
      });
      this.addCommand({
        id: "livesync-suspendall",
        name: "Toggle All Sync.",
        callback: () => __async(this, null, function* () {
          if (this.suspended) {
            this.suspended = false;
            Logger("Self-hosted LiveSync resumed", LOG_LEVEL.NOTICE);
          } else {
            this.suspended = true;
            Logger("Self-hosted LiveSync suspended", LOG_LEVEL.NOTICE);
          }
          yield this.realizeSettingSyncMode();
          this.saveSettings();
        })
      });
      this.addCommand({
        id: "livesync-history",
        name: "Show history",
        editorCallback: (editor, view) => {
          this.showHistory(view.file);
        }
      });
      this.triggerRealizeSettingSyncMode = (0, import_obsidian7.debounce)(this.triggerRealizeSettingSyncMode.bind(this), 1e3);
      this.triggerCheckPluginUpdate = (0, import_obsidian7.debounce)(this.triggerCheckPluginUpdate.bind(this), 3e3);
      setLockNotifier(() => {
        this.refreshStatusText();
      });
      this.addCommand({
        id: "livesync-plugin-dialog",
        name: "Show Plugins and their settings",
        callback: () => {
          this.showPluginSyncModal();
        }
      });
    });
  }
  showPluginSyncModal() {
    if (this.pluginDialog != null) {
      this.pluginDialog.open();
    } else {
      this.pluginDialog = new PluginDialogModal(this.app, this);
      this.pluginDialog.open();
    }
  }
  hidePluginSyncModal() {
    if (this.pluginDialog != null) {
      this.pluginDialog.close();
      this.pluginDialog = null;
    }
  }
  onunload() {
    this.hidePluginSyncModal();
    this.localDatabase.onunload();
    if (this.gcTimerHandler != null) {
      clearTimeout(this.gcTimerHandler);
      this.gcTimerHandler = null;
    }
    this.clearPeriodicSync();
    this.clearPluginSweep();
    this.localDatabase.closeReplication();
    this.localDatabase.close();
    window.removeEventListener("visibilitychange", this.watchWindowVisiblity);
    Logger("unloading plugin");
  }
  openDatabase() {
    return __async(this, null, function* () {
      if (this.localDatabase != null) {
        this.localDatabase.close();
      }
      const vaultName = this.app.vault.getName();
      Logger("Open Database...");
      const isMobile = this.app.isMobile;
      this.localDatabase = new LocalPouchDB(this.settings, vaultName, isMobile);
      this.localDatabase.updateInfo = () => {
        this.refreshStatusText();
      };
      return yield this.localDatabase.initializeDatabase();
    });
  }
  garbageCollect() {
    return __async(this, null, function* () {
      yield this.localDatabase.garbageCollect();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.settings.workingEncrypt = this.settings.encrypt;
      this.settings.workingPassphrase = this.settings.passphrase;
      this.settings.disableRequestURI = true;
      const lsname = "obsidian-live-sync-vaultanddevicename-" + this.app.vault.getName();
      if (this.settings.deviceAndVaultName != "") {
        if (!localStorage.getItem(lsname)) {
          this.deviceAndVaultName = this.settings.deviceAndVaultName;
          localStorage.setItem(lsname, this.deviceAndVaultName);
          this.settings.deviceAndVaultName = "";
        }
      }
      this.deviceAndVaultName = localStorage.getItem(lsname) || "";
    });
  }
  triggerRealizeSettingSyncMode() {
    (() => __async(this, null, function* () {
      return yield this.realizeSettingSyncMode();
    }))();
  }
  saveSettings() {
    return __async(this, null, function* () {
      const lsname = "obsidian-live-sync-vaultanddevicename-" + this.app.vault.getName();
      localStorage.setItem(lsname, this.deviceAndVaultName || "");
      yield this.saveData(this.settings);
      this.localDatabase.settings = this.settings;
      this.triggerRealizeSettingSyncMode();
    });
  }
  gcHook() {
    if (this.settings.gcDelay == 0)
      return;
    if (this.settings.useHistory)
      return;
    const GC_DELAY = this.settings.gcDelay * 1e3;
    if (this.gcTimerHandler != null) {
      clearTimeout(this.gcTimerHandler);
      this.gcTimerHandler = null;
    }
    this.gcTimerHandler = setTimeout(() => {
      this.gcTimerHandler = null;
      this.garbageCollect();
    }, GC_DELAY);
  }
  registerWatchEvents() {
    this.registerEvent(this.app.vault.on("modify", this.watchVaultChange));
    this.registerEvent(this.app.vault.on("delete", this.watchVaultDelete));
    this.registerEvent(this.app.vault.on("rename", this.watchVaultRename));
    this.registerEvent(this.app.vault.on("create", this.watchVaultCreate));
    this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
    window.addEventListener("visibilitychange", this.watchWindowVisiblity);
  }
  watchWindowVisiblity() {
    this.watchWindowVisiblityAsync();
  }
  watchWindowVisiblityAsync() {
    return __async(this, null, function* () {
      if (this.settings.suspendFileWatching)
        return;
      const isHidden = document.hidden;
      yield this.applyBatchChange();
      if (isHidden) {
        this.localDatabase.closeReplication();
        this.clearPeriodicSync();
      } else {
        if (this.suspended)
          return;
        if (this.settings.autoSweepPlugins) {
          yield this.sweepPlugin(false);
        }
        if (this.settings.liveSync) {
          this.localDatabase.openReplication(this.settings, true, false, this.parseReplicationResult);
        }
        if (this.settings.syncOnStart) {
          this.localDatabase.openReplication(this.settings, false, false, this.parseReplicationResult);
        }
        if (this.settings.periodicReplication) {
          this.setPeriodicSync();
        }
      }
      this.gcHook();
    });
  }
  watchWorkspaceOpen(file) {
    if (this.settings.suspendFileWatching)
      return;
    this.watchWorkspaceOpenAsync(file);
  }
  watchWorkspaceOpenAsync(file) {
    return __async(this, null, function* () {
      yield this.applyBatchChange();
      if (file == null) {
        return;
      }
      if (this.settings.syncOnFileOpen && !this.suspended) {
        yield this.replicate();
      }
      yield this.showIfConflicted(file);
      this.gcHook();
    });
  }
  watchVaultCreate(file, ...args) {
    if (this.settings.suspendFileWatching)
      return;
    this.watchVaultChangeAsync(file, ...args);
  }
  watchVaultChange(file, ...args) {
    if (!(file instanceof import_obsidian7.TFile)) {
      return;
    }
    if (this.settings.suspendFileWatching)
      return;
    if (this.settings.batchSave) {
      ~(() => __async(this, null, function* () {
        const meta = yield this.localDatabase.getDBEntryMeta(file.path);
        if (meta != false) {
          const localMtime = ~~(file.stat.mtime / 1e3);
          const docMtime = ~~(meta.mtime / 1e3);
          if (localMtime !== docMtime) {
            this.batchFileChange = Array.from(new Set([...this.batchFileChange, file.path]));
            this.refreshStatusText();
          }
        }
      }))();
      return;
    }
    this.watchVaultChangeAsync(file, ...args);
  }
  applyBatchChange() {
    return __async(this, null, function* () {
      if (!this.settings.batchSave || this.batchFileChange.length == 0) {
        return;
      }
      return yield runWithLock("batchSave", false, () => __async(this, null, function* () {
        const batchItems = JSON.parse(JSON.stringify(this.batchFileChange));
        this.batchFileChange = [];
        const promises = batchItems.map((e3) => __async(this, null, function* () {
          try {
            const f = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(e3));
            if (f && f instanceof import_obsidian7.TFile) {
              yield this.updateIntoDB(f);
              Logger(`Batch save:${e3}`);
            }
          } catch (ex) {
            Logger(`Batch save error:${e3}`, LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.VERBOSE);
          }
        }));
        this.refreshStatusText();
        yield allSettledWithConcurrencyLimit(promises, 3);
        return;
      }));
    });
  }
  watchVaultChangeAsync(file, ...args) {
    return __async(this, null, function* () {
      if (file instanceof import_obsidian7.TFile) {
        yield this.updateIntoDB(file);
        this.gcHook();
      }
    });
  }
  watchVaultDelete(file) {
    this.batchFileChange = this.batchFileChange.filter((e3) => e3 == file.path);
    if (this.settings.suspendFileWatching)
      return;
    this.watchVaultDeleteAsync(file).then(() => {
    });
  }
  watchVaultDeleteAsync(file) {
    return __async(this, null, function* () {
      if (file instanceof import_obsidian7.TFile) {
        yield this.deleteFromDB(file);
      } else if (file instanceof import_obsidian7.TFolder) {
        yield this.deleteFolderOnDB(file);
      }
      this.gcHook();
    });
  }
  GetAllFilesRecursively(file) {
    if (file instanceof import_obsidian7.TFile) {
      return [file];
    } else if (file instanceof import_obsidian7.TFolder) {
      const result = [];
      for (const v of file.children) {
        result.push(...this.GetAllFilesRecursively(v));
      }
      return result;
    } else {
      Logger(`Filetype error:${file.path}`, LOG_LEVEL.NOTICE);
      throw new Error(`Filetype error:${file.path}`);
    }
  }
  watchVaultRename(file, oldFile) {
    if (this.settings.suspendFileWatching)
      return;
    this.watchVaultRenameAsync(file, oldFile).then(() => {
    });
  }
  getFilePath(file) {
    if (file instanceof import_obsidian7.TFolder) {
      if (file.isRoot())
        return "";
      return this.getFilePath(file.parent) + "/" + file.name;
    }
    if (file instanceof import_obsidian7.TFile) {
      return this.getFilePath(file.parent) + "/" + file.name;
    }
    return this.getFilePath(file.parent) + "/" + file.name;
  }
  watchVaultRenameAsync(file, oldFile) {
    return __async(this, null, function* () {
      Logger(`${oldFile} renamed to ${file.path}`, LOG_LEVEL.VERBOSE);
      try {
        yield this.applyBatchChange();
      } catch (ex) {
        Logger(ex);
      }
      if (file instanceof import_obsidian7.TFolder) {
        const newFiles = this.GetAllFilesRecursively(file);
        for (const i2 of newFiles) {
          try {
            const newFilePath = (0, import_obsidian7.normalizePath)(this.getFilePath(i2));
            const newFile = this.app.vault.getAbstractFileByPath(newFilePath);
            if (newFile instanceof import_obsidian7.TFile) {
              Logger(`save ${newFile.path} into db`);
              yield this.updateIntoDB(newFile);
            }
          } catch (ex) {
            Logger(ex);
          }
        }
        Logger(`delete below ${oldFile} from db`);
        yield this.deleteFromDBbyPath(oldFile);
      } else if (file instanceof import_obsidian7.TFile) {
        try {
          Logger(`file save ${file.path} into db`);
          yield this.updateIntoDB(file);
          Logger(`deleted ${oldFile} into db`);
          yield this.deleteFromDBbyPath(oldFile);
        } catch (ex) {
          Logger(ex);
        }
      }
      this.gcHook();
    });
  }
  addLog(_0) {
    return __async(this, arguments, function* (message, level = LOG_LEVEL.INFO) {
      if (level == LOG_LEVEL.DEBUG && !isDebug) {
        return;
      }
      if (level < LOG_LEVEL.INFO && this.settings && this.settings.lessInformationInLog) {
        return;
      }
      if (this.settings && !this.settings.showVerboseLog && level == LOG_LEVEL.VERBOSE) {
        return;
      }
      const valutName = this.app.vault.getName();
      const timestamp = new Date().toLocaleString();
      const messagecontent = typeof message == "string" ? message : message instanceof Error ? `${message.name}:${message.message}` : JSON.stringify(message, null, 2);
      const newmessage = timestamp + "->" + messagecontent;
      this.logMessage = [].concat(this.logMessage).concat([newmessage]).slice(-100);
      console.log(valutName + ":" + newmessage);
      this.setStatusBarText(null, messagecontent.substring(0, 30));
      if (level >= LOG_LEVEL.NOTICE) {
        if (messagecontent in this.notifies) {
          clearTimeout(this.notifies[messagecontent].timer);
          this.notifies[messagecontent].count++;
          this.notifies[messagecontent].notice.setMessage(`(${this.notifies[messagecontent].count}):${messagecontent}`);
          this.notifies[messagecontent].timer = setTimeout(() => {
            const notify = this.notifies[messagecontent].notice;
            delete this.notifies[messagecontent];
            try {
              notify.hide();
            } catch (ex) {
            }
          }, 5e3);
        } else {
          const notify = new import_obsidian7.Notice(messagecontent, 0);
          this.notifies[messagecontent] = {
            count: 0,
            notice: notify,
            timer: setTimeout(() => {
              delete this.notifies[messagecontent];
              notify.hide();
            }, 5e3)
          };
        }
      }
      if (this.addLogHook != null)
        this.addLogHook();
    });
  }
  ensureDirectory(fullpath) {
    return __async(this, null, function* () {
      const pathElements = fullpath.split("/");
      pathElements.pop();
      let c = "";
      for (const v of pathElements) {
        c += v;
        try {
          yield this.app.vault.createFolder(c);
        } catch (ex) {
          if (ex.message && ex.message == "Folder already exists.") {
          } else {
            Logger("Folder Create Error");
            Logger(ex);
          }
        }
        c += "/";
      }
    });
  }
  doc2storage_create(docEntry, force) {
    return __async(this, null, function* () {
      const pathSrc = id2path(docEntry._id);
      if (shouldBeIgnored(pathSrc)) {
        return;
      }
      const doc = yield this.localDatabase.getDBEntry(pathSrc, { rev: docEntry._rev });
      if (doc === false)
        return;
      const path = id2path(doc._id);
      if (doc.datatype == "newnote") {
        const bin = base64ToArrayBuffer(doc.data);
        if (bin != null) {
          if (!isValidPath(path)) {
            Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
            return;
          }
          yield this.ensureDirectory(path);
          try {
            const newfile = yield this.app.vault.createBinary((0, import_obsidian7.normalizePath)(path), bin, {
              ctime: doc.ctime,
              mtime: doc.mtime
            });
            Logger("live : write to local (newfile:b) " + path);
            this.app.vault.trigger("create", newfile);
          } catch (ex) {
            Logger("could not write to local (newfile:bin) " + path, LOG_LEVEL.NOTICE);
            Logger(ex, LOG_LEVEL.VERBOSE);
          }
        }
      } else if (doc.datatype == "plain") {
        if (!isValidPath(path)) {
          Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
          return;
        }
        yield this.ensureDirectory(path);
        try {
          const newfile = yield this.app.vault.create((0, import_obsidian7.normalizePath)(path), doc.data, {
            ctime: doc.ctime,
            mtime: doc.mtime
          });
          Logger("live : write to local (newfile:p) " + path);
          this.app.vault.trigger("create", newfile);
        } catch (ex) {
          Logger("could not write to local (newfile:plain) " + path, LOG_LEVEL.NOTICE);
          Logger(ex, LOG_LEVEL.VERBOSE);
        }
      } else {
        Logger("live : New data imcoming, but we cound't parse that." + doc.datatype, LOG_LEVEL.NOTICE);
      }
    });
  }
  deleteVaultItem(file) {
    return __async(this, null, function* () {
      const dir = file.parent;
      if (this.settings.trashInsteadDelete) {
        yield this.app.vault.trash(file, false);
      } else {
        yield this.app.vault.delete(file);
      }
      Logger(`deleted:${file.path}`);
      Logger(`other items:${dir.children.length}`);
      if (dir.children.length == 0) {
        if (!this.settings.doNotDeleteFolder) {
          Logger(`all files deleted by replication, so delete dir`);
          yield this.deleteVaultItem(dir);
        }
      }
    });
  }
  doc2storage_modify(docEntry, file, force) {
    return __async(this, null, function* () {
      const pathSrc = id2path(docEntry._id);
      if (shouldBeIgnored(pathSrc)) {
        return;
      }
      if (docEntry._deleted) {
        const lastDocs = yield this.localDatabase.getDBEntry(pathSrc);
        if (lastDocs === false) {
          yield this.deleteVaultItem(file);
        } else {
          yield this.pullFile(pathSrc, null, true);
          Logger(`delete skipped:${lastDocs._id}`);
        }
        return;
      }
      const localMtime = ~~(file.stat.mtime / 1e3);
      const docMtime = ~~(docEntry.mtime / 1e3);
      if (localMtime < docMtime || force) {
        const doc = yield this.localDatabase.getDBEntry(pathSrc);
        let msg = "livesync : newer local files so write to local:" + file.path;
        if (force)
          msg = "livesync : force write to local:" + file.path;
        if (doc === false)
          return;
        const path = id2path(doc._id);
        if (doc.datatype == "newnote") {
          const bin = base64ToArrayBuffer(doc.data);
          if (bin != null) {
            if (!isValidPath(path)) {
              Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
              return;
            }
            yield this.ensureDirectory(path);
            try {
              yield this.app.vault.modifyBinary(file, bin, { ctime: doc.ctime, mtime: doc.mtime });
              Logger(msg);
              this.app.vault.trigger("modify", file);
            } catch (ex) {
              Logger("could not write to local (modify:bin) " + path, LOG_LEVEL.NOTICE);
            }
          }
        } else if (doc.datatype == "plain") {
          if (!isValidPath(path)) {
            Logger(`The file that having platform dependent name has been arrived. This file has skipped: ${path}`, LOG_LEVEL.NOTICE);
            return;
          }
          yield this.ensureDirectory(path);
          try {
            yield this.app.vault.modify(file, doc.data, { ctime: doc.ctime, mtime: doc.mtime });
            Logger(msg);
            this.app.vault.trigger("modify", file);
          } catch (ex) {
            Logger("could not write to local (modify:plain) " + path, LOG_LEVEL.NOTICE);
          }
        } else {
          Logger("live : New data imcoming, but we cound't parse that.:" + doc.datatype + "-", LOG_LEVEL.NOTICE);
        }
      } else if (localMtime > docMtime) {
      } else {
      }
    });
  }
  handleDBChanged(change) {
    return __async(this, null, function* () {
      const targetFile = this.app.vault.getAbstractFileByPath(id2path(change._id));
      if (targetFile == null) {
        if (change._deleted) {
          return;
        }
        const doc = change;
        yield this.doc2storage_create(doc);
      } else if (targetFile instanceof import_obsidian7.TFile) {
        const doc = change;
        const file = targetFile;
        yield this.doc2storage_modify(doc, file);
        if (!this.settings.checkConflictOnlyOnOpen) {
          this.queueConflictedCheck(file);
        } else {
          const af = app.workspace.getActiveFile();
          if (af && af.path == file.path) {
            this.queueConflictedCheck(file);
          }
        }
      } else {
        Logger(`${id2path(change._id)} is already exist as the folder`);
      }
    });
  }
  saveQueuedFiles() {
    return __async(this, null, function* () {
      const saveData = JSON.stringify(this.queuedFiles.filter((e3) => !e3.done).map((e3) => e3.entry._id));
      const lsname = "obsidian-livesync-queuefiles-" + this.app.vault.getName();
      localStorage.setItem(lsname, saveData);
    });
  }
  loadQueuedFiles() {
    return __async(this, null, function* () {
      const lsname = "obsidian-livesync-queuefiles-" + this.app.vault.getName();
      const ids = JSON.parse(localStorage.getItem(lsname) || "[]");
      const ret = yield this.localDatabase.localDatabase.allDocs({ keys: ids, include_docs: true });
      for (const doc of ret.rows) {
        if (doc.doc && !this.queuedFiles.some((e3) => e3.entry._id == doc.doc._id)) {
          yield this.parseIncomingDoc(doc.doc);
        }
      }
    });
  }
  procQueuedFiles() {
    return __async(this, null, function* () {
      yield runWithLock("procQueue", false, () => __async(this, null, function* () {
        this.saveQueuedFiles();
        for (const queue of this.queuedFiles) {
          if (queue.done)
            continue;
          const now = new Date().getTime();
          if (queue.missingChildren.length == 0) {
            queue.done = true;
            if (isValidPath(id2path(queue.entry._id))) {
              Logger(`Applying ${queue.entry._id} (${queue.entry._rev}) change...`);
              yield this.handleDBChanged(queue.entry);
            }
          } else if (now > queue.timeout) {
            if (!queue.warned)
              Logger(`Timed out: ${queue.entry._id} could not collect ${queue.missingChildren.length} chunks. plugin keeps watching, but you have to check the file after the replication.`, LOG_LEVEL.NOTICE);
            queue.warned = true;
            continue;
          }
        }
        this.queuedFiles = this.queuedFiles.filter((e3) => !e3.done);
        this.saveQueuedFiles();
      }));
    });
  }
  parseIncomingChunk(chunk) {
    const now = new Date().getTime();
    let isNewFileCompleted = false;
    for (const queue of this.queuedFiles) {
      if (queue.done)
        continue;
      if (queue.missingChildren.indexOf(chunk._id) !== -1) {
        queue.missingChildren = queue.missingChildren.filter((e3) => e3 != chunk._id);
        queue.timeout = now + this.chunkWaitTimeout;
      }
      if (queue.missingChildren.length == 0) {
        for (const e3 of this.queuedFiles) {
          if (e3.entry._id == queue.entry._id && e3.entry.mtime < queue.entry.mtime) {
            e3.done = true;
          }
        }
        isNewFileCompleted = true;
      }
    }
    if (isNewFileCompleted)
      this.procQueuedFiles();
  }
  parseIncomingDoc(doc) {
    return __async(this, null, function* () {
      const skipOldFile = this.settings.skipOlderFilesOnSync && false;
      if (skipOldFile) {
        const info = this.app.vault.getAbstractFileByPath(id2path(doc._id));
        if (info && info instanceof import_obsidian7.TFile) {
          const localMtime = ~~(info.stat.mtime / 1e3);
          const docMtime = ~~(doc.mtime / 1e3);
          if (localMtime >= docMtime) {
            Logger(`${doc._id} Skipped, older than storage.`, LOG_LEVEL.VERBOSE);
            return;
          }
        }
      }
      const now = new Date().getTime();
      const newQueue = {
        entry: doc,
        missingChildren: [],
        timeout: now + this.chunkWaitTimeout
      };
      if ("children" in doc) {
        const c = yield this.localDatabase.localDatabase.allDocs({ keys: doc.children, include_docs: false });
        const missing = c.rows.filter((e3) => "error" in e3).map((e3) => e3.key);
        Logger(`${doc._id}(${doc._rev}) Queued (waiting ${missing.length} items)`, LOG_LEVEL.VERBOSE);
        newQueue.missingChildren = missing;
        this.queuedFiles.push(newQueue);
      } else {
        this.queuedFiles.push(newQueue);
      }
      this.saveQueuedFiles();
      this.procQueuedFiles();
    });
  }
  parseReplicationResult(docs) {
    return __async(this, null, function* () {
      this.refreshStatusText();
      for (const change of docs) {
        if (change._id.startsWith("ps:")) {
          if (this.settings.notifyPluginOrSettingUpdated) {
            this.triggerCheckPluginUpdate();
          }
          continue;
        }
        if (change._id.startsWith("h:")) {
          yield this.parseIncomingChunk(change);
          continue;
        }
        if (change._id == SYNCINFO_ID) {
          continue;
        }
        if (change.type != "leaf" && change.type != "versioninfo" && change.type != "milestoneinfo" && change.type != "nodeinfo") {
          yield this.parseIncomingDoc(change);
          continue;
        }
        if (change.type == "versioninfo") {
          if (change.version > VER) {
            this.localDatabase.closeReplication();
            Logger(`Remote database updated to incompatible version. update your self-hosted-livesync plugin.`, LOG_LEVEL.NOTICE);
          }
        }
        this.gcHook();
      }
    });
  }
  triggerCheckPluginUpdate() {
    (() => __async(this, null, function* () {
      return yield this.checkPluginUpdate();
    }))();
  }
  checkPluginUpdate() {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.settings.usePluginSync)
        return;
      yield this.sweepPlugin(false);
      const { allPlugins, thisDevicePlugins } = yield this.getPluginList();
      const arrPlugins = Object.values(allPlugins);
      let updateFound = false;
      for (const plugin of arrPlugins) {
        const ownPlugin = thisDevicePlugins[plugin.manifest.id];
        if (ownPlugin) {
          const remoteVersion = versionNumberString2Number(plugin.manifest.version);
          const ownVersion = versionNumberString2Number(ownPlugin.manifest.version);
          if (remoteVersion > ownVersion) {
            updateFound = true;
          }
          if ((plugin.mtime / 1e3 | 0) > (ownPlugin.mtime / 1e3 | 0) && ((_a = plugin.dataJson) != null ? _a : "") != ((_b = ownPlugin.dataJson) != null ? _b : "")) {
            updateFound = true;
          }
        }
      }
      if (updateFound) {
        const fragment = createFragment((doc) => {
          doc.createEl("a", null, (a) => {
            a.text = "There're some new plugins or their settings";
            a.addEventListener("click", () => this.showPluginSyncModal());
          });
        });
        NewNotice(fragment, 1e4);
      } else {
        Logger("Everything is up to date.", LOG_LEVEL.NOTICE);
      }
    });
  }
  clearPeriodicSync() {
    if (this.periodicSyncHandler != null) {
      clearInterval(this.periodicSyncHandler);
      this.periodicSyncHandler = null;
    }
  }
  setPeriodicSync() {
    if (this.settings.periodicReplication && this.settings.periodicReplicationInterval > 0) {
      this.clearPeriodicSync();
      this.periodicSyncHandler = this.setInterval(() => __async(this, null, function* () {
        return yield this.periodicSync();
      }), Math.max(this.settings.periodicReplicationInterval, 30) * 1e3);
    }
  }
  periodicSync() {
    return __async(this, null, function* () {
      yield this.replicate();
    });
  }
  clearPluginSweep() {
    if (this.periodicPluginSweepHandler != null) {
      clearInterval(this.periodicPluginSweepHandler);
      this.periodicPluginSweepHandler = null;
    }
  }
  setPluginSweep() {
    if (this.settings.autoSweepPluginsPeriodic) {
      this.clearPluginSweep();
      this.periodicPluginSweepHandler = this.setInterval(() => __async(this, null, function* () {
        return yield this.periodicPluginSweep();
      }), PERIODIC_PLUGIN_SWEEP * 1e3);
    }
  }
  periodicPluginSweep() {
    return __async(this, null, function* () {
      yield this.sweepPlugin(false);
    });
  }
  realizeSettingSyncMode() {
    return __async(this, null, function* () {
      this.localDatabase.closeReplication();
      this.clearPeriodicSync();
      this.clearPluginSweep();
      yield this.applyBatchChange();
      if (this.suspended)
        return;
      if (this.settings.autoSweepPlugins) {
        yield this.sweepPlugin(false);
      }
      if (this.settings.liveSync) {
        this.localDatabase.openReplication(this.settings, true, false, this.parseReplicationResult);
        this.refreshStatusText();
      }
      this.setPeriodicSync();
      this.setPluginSweep();
    });
  }
  refreshStatusText() {
    const sent = this.localDatabase.docSent;
    const arrived = this.localDatabase.docArrived;
    let w = "";
    switch (this.localDatabase.syncStatus) {
      case "CLOSED":
      case "COMPLETED":
      case "NOT_CONNECTED":
        w = "\u23F9";
        break;
      case "STARTED":
        w = "\u{1F300}";
        break;
      case "PAUSED":
        w = "\u{1F4A4}";
        break;
      case "CONNECTED":
        w = "\u26A1";
        break;
      case "ERRORED":
        w = "\u26A0";
        break;
      default:
        w = "?";
    }
    this.statusBar.title = this.localDatabase.syncStatus;
    let waiting = "";
    if (this.settings.batchSave) {
      waiting = " " + this.batchFileChange.map((e3) => "\u{1F6EB}").join("");
      waiting = waiting.replace(/(🛫){10}/g, "\u{1F680}");
    }
    let queued = "";
    const queue = Object.entries(this.queuedFiles).filter((e3) => !e3[1].warned);
    const queuedCount = queue.length;
    if (queuedCount) {
      const pieces = queue.map((e3) => e3[1].missingChildren).reduce((prev, cur) => prev + cur.length, 0);
      queued = ` \u{1F9E9} ${queuedCount} (${pieces})`;
    }
    const procs = getProcessingCounts();
    const procsDisp = procs == 0 ? "" : ` \u23F3${procs}`;
    const message = `Sync:${w} \u2191${sent} \u2193${arrived}${waiting}${procsDisp}${queued}`;
    const locks2 = getLocks();
    const pendingTask = locks2.pending.length ? "\nPending: " + Object.entries([...new Set([...locks2.pending])].reduce((p, c) => {
      var _a;
      return __spreadProps(__spreadValues({}, p), { [c]: (_a = p[c]) != null ? _a : 0 + 1 });
    }, {})).map((e3) => `${e3[0]}${e3[1] == 1 ? "" : `(${e3[1]})`}`).join(", ") : "";
    const runningTask = locks2.running.length ? "\nRunning: " + Object.entries([...new Set([...locks2.running])].reduce((p, c) => {
      var _a;
      return __spreadProps(__spreadValues({}, p), { [c]: (_a = p[c]) != null ? _a : 0 + 1 });
    }, {})).map((e3) => `${e3[0]}${e3[1] == 1 ? "" : `(${e3[1]})`}`).join(", ") : "";
    this.setStatusBarText(message + pendingTask + runningTask);
  }
  setStatusBarText(message = null, log = null) {
    if (!this.statusBar)
      return;
    const newMsg = typeof message == "string" ? message : this.lastMessage;
    const newLog = typeof log == "string" ? log : this.lastLog;
    if (`${this.lastMessage}-${this.lastLog}` != `${newMsg}-${newLog}`) {
      this.statusBar.setText(newMsg.split("\n")[0]);
      if (this.settings.showStatusOnEditor) {
        const root = document.documentElement;
        root.style.setProperty("--slsmessage", '"' + (newMsg + "\n" + newLog).split("\n").join("\\a ") + '"');
      } else {
        const root = document.documentElement;
        root.style.setProperty("--slsmessage", '""');
      }
      if (this.logHideTimer != null) {
        clearTimeout(this.logHideTimer);
      }
      this.logHideTimer = setTimeout(() => this.setStatusBarText(null, ""), 3e3);
      this.lastMessage = newMsg;
      this.lastLog = newLog;
    }
  }
  updateStatusBarText() {
  }
  replicate(showMessage) {
    return __async(this, null, function* () {
      if (this.settings.versionUpFlash != "") {
        NewNotice("Open settings and check message, please.");
        return;
      }
      yield this.applyBatchChange();
      if (this.settings.autoSweepPlugins) {
        yield this.sweepPlugin(false);
      }
      yield this.loadQueuedFiles();
      this.localDatabase.openReplication(this.settings, false, showMessage, this.parseReplicationResult);
    });
  }
  initializeDatabase(showingNotice) {
    return __async(this, null, function* () {
      if (yield this.openDatabase()) {
        if (this.localDatabase.isReady) {
          yield this.syncAllFiles(showingNotice);
        }
        return true;
      } else {
        return false;
      }
    });
  }
  replicateAllToServer(showingNotice) {
    return __async(this, null, function* () {
      if (this.settings.autoSweepPlugins) {
        yield this.sweepPlugin(showingNotice);
      }
      return yield this.localDatabase.replicateAllToServer(this.settings, showingNotice);
    });
  }
  markRemoteLocked() {
    return __async(this, null, function* () {
      return yield this.localDatabase.markRemoteLocked(this.settings, true);
    });
  }
  markRemoteUnlocked() {
    return __async(this, null, function* () {
      return yield this.localDatabase.markRemoteLocked(this.settings, false);
    });
  }
  markRemoteResolved() {
    return __async(this, null, function* () {
      return yield this.localDatabase.markRemoteResolved(this.settings);
    });
  }
  syncAllFiles(showingNotice) {
    return __async(this, null, function* () {
      let notice = null;
      if (showingNotice) {
        notice = NewNotice("Initializing", 0);
      }
      const filesStorage = this.app.vault.getFiles();
      const filesStorageName = filesStorage.map((e3) => e3.path);
      const wf = yield this.localDatabase.localDatabase.allDocs();
      const filesDatabase = wf.rows.filter((e3) => !e3.id.startsWith("h:") && !e3.id.startsWith("ps:") && e3.id != "obsydian_livesync_version").map((e3) => id2path(e3.id));
      const onlyInStorage = filesStorage.filter((e3) => filesDatabase.indexOf(e3.path) == -1);
      const onlyInDatabase = filesDatabase.filter((e3) => filesStorageName.indexOf(e3) == -1);
      const onlyInStorageNames = onlyInStorage.map((e3) => e3.path);
      const syncFiles = filesStorage.filter((e3) => onlyInStorageNames.indexOf(e3.path) == -1);
      Logger("Initialize and checking database files");
      Logger("Updating database by new files");
      this.setStatusBarText(`UPDATE DATABASE`);
      const runAll = (procedurename, objects, callback) => __async(this, null, function* () {
        const count = objects.length;
        Logger(procedurename);
        let i2 = 0;
        let workProcs = 0;
        const procs = objects.map((e3) => __async(this, null, function* () {
          try {
            workProcs++;
            yield callback(e3);
            i2++;
            if (i2 % 25 == 0) {
              const notify = `${procedurename} : ${workProcs}/${count} (Pending:${workProcs})`;
              if (notice != null)
                notice.setMessage(notify);
              Logger(notify);
              this.setStatusBarText(notify);
            }
          } catch (ex) {
            Logger(`Error while ${procedurename}`, LOG_LEVEL.NOTICE);
            Logger(ex);
          } finally {
            workProcs--;
          }
        }));
        yield allSettledWithConcurrencyLimit(procs, 10);
        Logger(`${procedurename} done.`);
      });
      yield runAll("UPDATE DATABASE", onlyInStorage, (e3) => __async(this, null, function* () {
        Logger(`Update into ${e3.path}`);
        yield this.updateIntoDB(e3);
      }));
      yield runAll("UPDATE STORAGE", onlyInDatabase, (e3) => __async(this, null, function* () {
        Logger(`Pull from db:${e3}`);
        yield this.pullFile(e3, filesStorage, false, null, false);
      }));
      yield runAll("CHECK FILE STATUS", syncFiles, (e3) => __async(this, null, function* () {
        yield this.syncFileBetweenDBandStorage(e3, filesStorage);
      }));
      this.setStatusBarText(`NOW TRACKING!`);
      Logger("Initialized,NOW TRACKING!");
      if (showingNotice) {
        notice.hide();
        Logger("Initialize done!", LOG_LEVEL.NOTICE);
      }
    });
  }
  deleteFolderOnDB(folder) {
    return __async(this, null, function* () {
      Logger(`delete folder:${folder.path}`);
      yield this.localDatabase.deleteDBEntryPrefix(folder.path + "/");
      for (const v of folder.children) {
        const entry = v;
        Logger(`->entry:${entry.path}`, LOG_LEVEL.VERBOSE);
        if (entry.children) {
          Logger(`->is dir`, LOG_LEVEL.VERBOSE);
          yield this.deleteFolderOnDB(entry);
          try {
            if (this.settings.trashInsteadDelete) {
              yield this.app.vault.trash(entry, false);
            } else {
              yield this.app.vault.delete(entry);
            }
          } catch (ex) {
            if (ex.code && ex.code == "ENOENT") {
            } else {
              Logger(`error while delete folder:${entry.path}`, LOG_LEVEL.NOTICE);
              Logger(ex);
            }
          }
        } else {
          Logger(`->is file`, LOG_LEVEL.VERBOSE);
          yield this.deleteFromDB(entry);
        }
      }
      try {
        if (this.settings.trashInsteadDelete) {
          yield this.app.vault.trash(folder, false);
        } else {
          yield this.app.vault.delete(folder);
        }
      } catch (ex) {
        if (ex.code && ex.code == "ENOENT") {
        } else {
          Logger(`error while delete filder:${folder.path}`, LOG_LEVEL.NOTICE);
          Logger(ex);
        }
      }
    });
  }
  renameFolder(folder, oldFile) {
    return __async(this, null, function* () {
      for (const v of folder.children) {
        const entry = v;
        if (entry.children) {
          yield this.deleteFolderOnDB(entry);
          if (this.settings.trashInsteadDelete) {
            yield this.app.vault.trash(entry, false);
          } else {
            yield this.app.vault.delete(entry);
          }
        } else {
          yield this.deleteFromDB(entry);
        }
      }
    });
  }
  getConflictedDoc(path, rev) {
    return __async(this, null, function* () {
      try {
        const doc = yield this.localDatabase.getDBEntry(path, { rev }, false, false);
        if (doc === false)
          return false;
        let data = doc.data;
        if (doc.datatype == "newnote") {
          data = base64ToString(doc.data);
        } else if (doc.datatype == "plain") {
          data = doc.data;
        }
        return {
          ctime: doc.ctime,
          mtime: doc.mtime,
          rev,
          data
        };
      } catch (ex) {
        if (ex.status && ex.status == 404) {
          return false;
        }
      }
      return false;
    });
  }
  getConflictedStatus(path) {
    return __async(this, null, function* () {
      const test = yield this.localDatabase.getDBEntry(path, { conflicts: true }, false, false);
      if (test === false)
        return false;
      if (test == null)
        return false;
      if (!test._conflicts)
        return false;
      if (test._conflicts.length == 0)
        return false;
      const leftLeaf = yield this.getConflictedDoc(path, test._rev);
      const rightLeaf = yield this.getConflictedDoc(path, test._conflicts[0]);
      if (leftLeaf == false) {
        Logger(`could not get current revisions:${path}`, LOG_LEVEL.NOTICE);
        return false;
      }
      if (rightLeaf == false) {
        yield this.localDatabase.deleteDBEntry(path, { rev: test._conflicts[0] });
        yield this.pullFile(path, null, true);
        Logger(`could not get old revisions, automaticaly used newer one:${path}`, LOG_LEVEL.NOTICE);
        return true;
      }
      if (leftLeaf.data == rightLeaf.data) {
        let leaf = leftLeaf;
        if (leftLeaf.mtime > rightLeaf.mtime) {
          leaf = rightLeaf;
        }
        yield this.localDatabase.deleteDBEntry(path, { rev: leaf.rev });
        yield this.pullFile(path, null, true);
        Logger(`automaticaly merged:${path}`);
        return true;
      }
      if (this.settings.resolveConflictsByNewerFile) {
        const lmtime = ~~(leftLeaf.mtime / 1e3);
        const rmtime = ~~(rightLeaf.mtime / 1e3);
        let loser = leftLeaf;
        if (lmtime > rmtime) {
          loser = rightLeaf;
        }
        yield this.localDatabase.deleteDBEntry(path, { rev: loser.rev });
        yield this.pullFile(path, null, true);
        Logger(`Automaticaly merged (newerFileResolve) :${path}`, LOG_LEVEL.NOTICE);
        return true;
      }
      const dmp = new import_diff_match_patch3.diff_match_patch();
      const diff = dmp.diff_main(leftLeaf.data, rightLeaf.data);
      dmp.diff_cleanupSemantic(diff);
      Logger(`conflict(s) found:${path}`);
      return {
        left: leftLeaf,
        right: rightLeaf,
        diff
      };
    });
  }
  showMergeDialog(file, conflictCheckResult) {
    return new Promise((res, rej) => {
      Logger("open conflict dialog", LOG_LEVEL.VERBOSE);
      new ConflictResolveModal(this.app, conflictCheckResult, (selected) => __async(this, null, function* () {
        const testDoc = yield this.localDatabase.getDBEntry(file.path, { conflicts: true });
        if (testDoc === false) {
          Logger("Missing file..", LOG_LEVEL.VERBOSE);
          return res(true);
        }
        if (!testDoc._conflicts) {
          Logger("Nothing have to do with this conflict", LOG_LEVEL.VERBOSE);
          return res(true);
        }
        const toDelete = selected;
        const toKeep = conflictCheckResult.left.rev != toDelete ? conflictCheckResult.left.rev : conflictCheckResult.right.rev;
        if (toDelete == "") {
          const p = conflictCheckResult.diff.map((e3) => e3[1]).join("");
          yield this.localDatabase.deleteDBEntry(file.path, { rev: conflictCheckResult.left.rev });
          yield this.localDatabase.deleteDBEntry(file.path, { rev: conflictCheckResult.right.rev });
          yield this.app.vault.modify(file, p);
          yield this.updateIntoDB(file);
          yield this.pullFile(file.path);
          Logger("concat both file");
          setTimeout(() => {
            this.showIfConflicted(file);
          }, 500);
        } else if (toDelete == null) {
          Logger("Leave it still conflicted");
        } else {
          Logger(`resolved conflict:${file.path}`);
          yield this.localDatabase.deleteDBEntry(file.path, { rev: toDelete });
          yield this.pullFile(file.path, null, true, toKeep);
          setTimeout(() => {
            this.showIfConflicted(file);
          }, 500);
        }
        return res(true);
      })).open();
    });
  }
  queueConflictedCheck(file) {
    this.conflictedCheckFiles = this.conflictedCheckFiles.filter((e3) => e3 != file.path);
    this.conflictedCheckFiles.push(file.path);
    if (this.conflictedCheckTimer != null) {
      window.clearTimeout(this.conflictedCheckTimer);
    }
    this.conflictedCheckTimer = window.setTimeout(() => __async(this, null, function* () {
      this.conflictedCheckTimer = null;
      const checkFiles = JSON.parse(JSON.stringify(this.conflictedCheckFiles));
      for (const filename of checkFiles) {
        try {
          const file2 = this.app.vault.getAbstractFileByPath(filename);
          if (file2 != null && file2 instanceof import_obsidian7.TFile) {
            yield this.showIfConflicted(file2);
          }
        } catch (ex) {
          Logger(ex);
        }
      }
    }), 1e3);
  }
  showIfConflicted(file) {
    return __async(this, null, function* () {
      yield runWithLock("conflicted", false, () => __async(this, null, function* () {
        const conflictCheckResult = yield this.getConflictedStatus(file.path);
        if (conflictCheckResult === false) {
          return;
        }
        if (conflictCheckResult === true) {
          Logger("conflict:Automatically merged, but we have to check it again");
          setTimeout(() => {
            this.showIfConflicted(file);
          }, 500);
          return;
        }
        yield this.showMergeDialog(file, conflictCheckResult);
      }));
    });
  }
  pullFile(filename, fileList, force, rev, waitForReady = true) {
    return __async(this, null, function* () {
      const targetFile = this.app.vault.getAbstractFileByPath(id2path(filename));
      if (targetFile == null) {
        const doc = yield this.localDatabase.getDBEntry(filename, rev ? { rev } : null, false, waitForReady);
        if (doc === false)
          return;
        yield this.doc2storage_create(doc, force);
      } else if (targetFile instanceof import_obsidian7.TFile) {
        const file = targetFile;
        const doc = yield this.localDatabase.getDBEntry(filename, rev ? { rev } : null, false, waitForReady);
        if (doc === false)
          return;
        yield this.doc2storage_modify(doc, file, force);
      } else {
        Logger(`target files:${filename} is exists as the folder`);
      }
    });
  }
  syncFileBetweenDBandStorage(file, fileList) {
    return __async(this, null, function* () {
      const doc = yield this.localDatabase.getDBEntryMeta(file.path);
      if (doc === false)
        return;
      const storageMtime = ~~(file.stat.mtime / 1e3);
      const docMtime = ~~(doc.mtime / 1e3);
      const dK = `${file.path}-diff`;
      const isLastDiff = (yield this.localDatabase.kvDB.get(dK)) || { storageMtime: 0, docMtime: 0 };
      if (isLastDiff.docMtime == docMtime && isLastDiff.storageMtime == storageMtime) {
      } else {
        if (storageMtime > docMtime) {
          Logger("STORAGE -> DB :" + file.path);
          Logger(`${storageMtime} > ${docMtime}`);
          yield this.updateIntoDB(file);
        } else if (storageMtime < docMtime) {
          Logger("STORAGE <- DB :" + file.path);
          Logger(`${storageMtime} < ${docMtime}`);
          const docx = yield this.localDatabase.getDBEntry(file.path, null, false, false);
          if (docx != false) {
            yield this.doc2storage_modify(docx, file);
          }
        } else {
        }
        yield this.localDatabase.kvDB.set(dK, { storageMtime, docMtime });
      }
    });
  }
  updateIntoDB(file) {
    return __async(this, null, function* () {
      if (shouldBeIgnored(file.path)) {
        return;
      }
      yield this.localDatabase.waitForGCComplete();
      let content = "";
      let datatype = "newnote";
      if (!isPlainText(file.name)) {
        const contentBin = yield this.app.vault.readBinary(file);
        content = yield arrayBufferToBase64(contentBin);
        datatype = "newnote";
      } else {
        content = yield this.app.vault.read(file);
        datatype = "plain";
      }
      const fullpath = path2id(file.path);
      const d = {
        _id: fullpath,
        data: content,
        ctime: file.stat.ctime,
        mtime: file.stat.mtime,
        size: file.stat.size,
        children: [],
        datatype
      };
      const isNotChanged = yield runWithLock("file:" + fullpath, false, () => __async(this, null, function* () {
        const old = yield this.localDatabase.getDBEntry(fullpath, null, false, false);
        if (old !== false) {
          const oldData = { data: old.data, deleted: old._deleted };
          const newData = { data: d.data, deleted: d._deleted };
          if (JSON.stringify(oldData) == JSON.stringify(newData)) {
            Logger("not changed:" + fullpath + (d._deleted ? " (deleted)" : ""), LOG_LEVEL.VERBOSE);
            return true;
          }
        }
        return false;
      }));
      if (isNotChanged)
        return;
      yield this.localDatabase.putDBEntry(d);
      this.queuedFiles = this.queuedFiles.map((e3) => __spreadValues(__spreadValues({}, e3), e3.entry._id == d._id ? { done: true } : {}));
      Logger("put database:" + fullpath + "(" + datatype + ") ");
      if (this.settings.syncOnSave && !this.suspended) {
        yield this.replicate();
      }
    });
  }
  deleteFromDB(file) {
    return __async(this, null, function* () {
      const fullpath = file.path;
      Logger(`deleteDB By path:${fullpath}`);
      yield this.deleteFromDBbyPath(fullpath);
      if (this.settings.syncOnSave && !this.suspended) {
        yield this.replicate();
      }
    });
  }
  deleteFromDBbyPath(fullpath) {
    return __async(this, null, function* () {
      yield this.localDatabase.deleteDBEntry(fullpath);
      if (this.settings.syncOnSave && !this.suspended) {
        yield this.replicate();
      }
    });
  }
  resetLocalDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.resetDatabase();
    });
  }
  resetLocalOldDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.resetLocalOldDatabase();
    });
  }
  tryResetRemoteDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.tryResetRemoteDatabase(this.settings);
    });
  }
  tryCreateRemoteDatabase() {
    return __async(this, null, function* () {
      yield this.localDatabase.tryCreateRemoteDatabase(this.settings);
    });
  }
  getPluginList() {
    return __async(this, null, function* () {
      const db = this.localDatabase.localDatabase;
      const docList = yield db.allDocs({ startkey: `ps:`, endkey: `ps;`, include_docs: false });
      const oldDocs = (yield Promise.all(docList.rows.map((e3) => __async(this, null, function* () {
        return yield this.localDatabase.getDBEntry(e3.id);
      })))).filter((e3) => e3 !== false).map((e3) => JSON.parse(e3.data));
      const plugins = {};
      const allPlugins = {};
      const thisDevicePlugins = {};
      for (const v of oldDocs) {
        if (typeof plugins[v.deviceVaultName] === "undefined") {
          plugins[v.deviceVaultName] = [];
        }
        plugins[v.deviceVaultName].push(v);
        allPlugins[v._id] = v;
        if (v.deviceVaultName == this.deviceAndVaultName) {
          thisDevicePlugins[v.manifest.id] = v;
        }
      }
      return { plugins, allPlugins, thisDevicePlugins };
    });
  }
  sweepPlugin(showMessage = false) {
    return __async(this, null, function* () {
      if (!this.settings.usePluginSync)
        return;
      if (!this.localDatabase.isReady)
        return;
      yield runWithLock("sweepplugin", true, () => __async(this, null, function* () {
        const logLevel = showMessage ? LOG_LEVEL.NOTICE : LOG_LEVEL.INFO;
        if (!this.settings.encrypt) {
          Logger("You have to encrypt the database to use plugin setting sync.", LOG_LEVEL.NOTICE);
          return;
        }
        if (!this.deviceAndVaultName) {
          Logger("You have to set your device and vault name.", LOG_LEVEL.NOTICE);
          return;
        }
        Logger("Scanning plugins", logLevel);
        const db = this.localDatabase.localDatabase;
        const oldDocs = yield db.allDocs({
          startkey: `ps:${this.deviceAndVaultName}-`,
          endkey: `ps:${this.deviceAndVaultName}.`,
          include_docs: true
        });
        const pl = this.app.plugins;
        const manifests = Object.values(pl.manifests);
        for (const m of manifests) {
          Logger(`Reading plugin:${m.name}(${m.id})`, LOG_LEVEL.VERBOSE);
          const path = (0, import_obsidian7.normalizePath)(m.dir) + "/";
          const adapter = this.app.vault.adapter;
          const files = ["manifest.json", "main.js", "styles.css", "data.json"];
          const pluginData = {};
          for (const file of files) {
            const thePath = path + file;
            if (yield adapter.exists(thePath)) {
              pluginData[file] = yield adapter.read(thePath);
            }
          }
          let mtime = 0;
          if (yield adapter.exists(path + "/data.json")) {
            mtime = (yield adapter.stat(path + "/data.json")).mtime;
          }
          const p = {
            _id: `ps:${this.deviceAndVaultName}-${m.id}`,
            dataJson: pluginData["data.json"],
            deviceVaultName: this.deviceAndVaultName,
            mainJs: pluginData["main.js"],
            styleCss: pluginData["styles.css"],
            manifest: m,
            manifestJson: pluginData["manifest.json"],
            mtime,
            type: "plugin"
          };
          const d = {
            _id: p._id,
            data: JSON.stringify(p),
            ctime: mtime,
            mtime,
            size: 0,
            children: [],
            datatype: "plain"
          };
          Logger(`check diff:${m.name}(${m.id})`, LOG_LEVEL.VERBOSE);
          yield runWithLock("plugin-" + m.id, false, () => __async(this, null, function* () {
            const old = yield this.localDatabase.getDBEntry(p._id, null, false, false);
            if (old !== false) {
              const oldData = { data: old.data, deleted: old._deleted };
              const newData = { data: d.data, deleted: d._deleted };
              if (JSON.stringify(oldData) == JSON.stringify(newData)) {
                oldDocs.rows = oldDocs.rows.filter((e3) => e3.id != d._id);
                Logger(`Nothing changed:${m.name}`);
                return;
              }
            }
            yield this.localDatabase.putDBEntry(d);
            oldDocs.rows = oldDocs.rows.filter((e3) => e3.id != d._id);
            Logger(`Plugin saved:${m.name}`, logLevel);
          }));
        }
        Logger(`Deleting old plugins`, LOG_LEVEL.VERBOSE);
        const delDocs = oldDocs.rows.map((e3) => {
          e3.doc._deleted = true;
          return e3.doc;
        });
        yield db.bulkDocs(delDocs);
        Logger(`Scan plugin done.`, logLevel);
      }));
    });
  }
  applyPluginData(plugin) {
    return __async(this, null, function* () {
      yield runWithLock("plugin-" + plugin.manifest.id, false, () => __async(this, null, function* () {
        const pluginTargetFolderPath = (0, import_obsidian7.normalizePath)(plugin.manifest.dir) + "/";
        const adapter = this.app.vault.adapter;
        const stat = this.app.plugins.enabledPlugins.has(plugin.manifest.id) == true;
        if (stat) {
          yield this.app.plugins.unloadPlugin(plugin.manifest.id);
          Logger(`Unload plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
        if (plugin.dataJson)
          yield adapter.write(pluginTargetFolderPath + "data.json", plugin.dataJson);
        Logger("wrote:" + pluginTargetFolderPath + "data.json", LOG_LEVEL.NOTICE);
        if (stat) {
          yield this.app.plugins.loadPlugin(plugin.manifest.id);
          Logger(`Load plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
      }));
    });
  }
  applyPlugin(plugin) {
    return __async(this, null, function* () {
      yield runWithLock("plugin-" + plugin.manifest.id, false, () => __async(this, null, function* () {
        const stat = this.app.plugins.enabledPlugins.has(plugin.manifest.id) == true;
        if (stat) {
          yield this.app.plugins.unloadPlugin(plugin.manifest.id);
          Logger(`Unload plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
        const pluginTargetFolderPath = (0, import_obsidian7.normalizePath)(plugin.manifest.dir) + "/";
        const adapter = this.app.vault.adapter;
        if ((yield adapter.exists(pluginTargetFolderPath)) === false) {
          yield adapter.mkdir(pluginTargetFolderPath);
        }
        yield adapter.write(pluginTargetFolderPath + "main.js", plugin.mainJs);
        yield adapter.write(pluginTargetFolderPath + "manifest.json", plugin.manifestJson);
        if (plugin.styleCss)
          yield adapter.write(pluginTargetFolderPath + "styles.css", plugin.styleCss);
        if (stat) {
          yield this.app.plugins.loadPlugin(plugin.manifest.id);
          Logger(`Load plugin:${plugin.manifest.id}`, LOG_LEVEL.NOTICE);
        }
      }));
    });
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
